{"meta":{"title":"小白程序之路","subtitle":null,"description":"本站是小白程序之路（顾立剑）的技术分享博客。内容涵盖Java后端技术、大数据、优秀开发工具、Mac推荐工具、视屏书籍分享、运维开发、系统监控等相关的研究与知识分享","author":"顾立剑","url":"http://www.gulj.cn"},"pages":[],"posts":[{"title":"Java版-数据结构-栈","slug":"Java版-数据结构-栈","date":"2019-03-11T19:13:59.000Z","updated":"2019-03-11T19:15:17.583Z","comments":true,"path":"2019/03/12/Java版-数据结构-栈/","link":"","permalink":"http://www.gulj.cn/2019/03/12/Java版-数据结构-栈/","excerpt":"介绍栈是一种后进先出的线性表数据结构，分为栈顶和栈底两端，仅允许在表的一端插入元素，这一端被称为栈顶，另外一端称之为栈底。栈，只有两种操作，分为入栈（压栈）和出栈（退栈）；向栈中添加元素的操作叫做入栈，相反从栈中删除元素叫做出栈。 特点 只能从栈顶添加元素或者删除元素 后进先出的数据结构，Last In First Out（LIFO）","text":"介绍栈是一种后进先出的线性表数据结构，分为栈顶和栈底两端，仅允许在表的一端插入元素，这一端被称为栈顶，另外一端称之为栈底。栈，只有两种操作，分为入栈（压栈）和出栈（退栈）；向栈中添加元素的操作叫做入栈，相反从栈中删除元素叫做出栈。 特点 只能从栈顶添加元素或者删除元素 后进先出的数据结构，Last In First Out（LIFO） 为了大家更好的形象了解我们通过示意图来看一下栈的入栈和出栈操作 入栈操作示意图 出栈操作示意图（后进的元素先出） 栈的基本操作 向栈中添加一个元素（入栈） 1void push(E e) 从栈中删除一个元素（出栈） 1E pop() 查看栈顶元素 1E peek() 查看栈中元素个数 1int getSize() 判断栈是否为空 1boolean isEmpty() 实现栈的方式，实际上底层有多种实现方式，比如：动态数组等，这里我们使用Java语言本身为我们提供的集合LinkedList 接口定义：Stack123456789101112131415161718192021222324252627282930313233343536public interface Stack&lt;E&gt; &#123; /** * 向栈中添加元素 * * @param e */ void push(E e); /** * 从栈中删除元素 */ void pop(); /** * 获取栈顶元素 * * @return */ E peek(); /** * 获取栈中元素个数 * * @return */ int getSize(); /** * 判断栈中是否为空 * * @return */ boolean isEmpty();&#125; LinkedListStack 类实现接口Stack123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt; &#123; /** * 存放栈元素 */ LinkedList&lt;E&gt; list; /** * 构造栈结构 */ public LinkedListStack() &#123; list = new LinkedList&lt;&gt;(); &#125; @Override public void push(E e) &#123; list.addLast(e); &#125; @Override public void pop() &#123; list.removeLast(); &#125; @Override public E peek() &#123; return list.getLast(); &#125; @Override public int getSize() &#123; return list.size(); &#125; @Override public boolean isEmpty() &#123; return list.isEmpty(); &#125; @Override public String toString() &#123; return \"LinkedListStack&#123;\" + \"list=\" + list + '&#125;'; &#125;&#125; 测试类：LinkedListStackTest123456789101112131415161718192021@Testpublic void testLinkedListStack() &#123; // 栈 Stack&lt;String&gt; stack = new LinkedListStack&lt;&gt;(); // 准备入栈元素 List&lt;String&gt; prepareElements = Arrays.asList(\"A\", \"B\", \"C\", \"D\", \"E\"); // 入栈 prepareElements.forEach(x -&gt; &#123; stack.push(x); System.out.println(\"入栈操作：\" + stack); &#125;); // 出栈 stack.pop(); System.out.println(\"出栈操作：\" + stack); // 获取栈顶元素 String peekElement = stack.peek(); System.out.println(\"栈顶元素：\" + peekElement); // 获取栈中元素的个数 int stackSize = stack.getSize(); System.out.println(\"栈中元素个数：\" + stackSize);&#125; 运行结果12345678入栈操作：LinkedListStack&#123;list=[A]&#125;入栈操作：LinkedListStack&#123;list=[A, B]&#125;入栈操作：LinkedListStack&#123;list=[A, B, C]&#125;入栈操作：LinkedListStack&#123;list=[A, B, C, D]&#125;入栈操作：LinkedListStack&#123;list=[A, B, C, D, E]&#125;出栈操作：LinkedListStack&#123;list=[A, B, C, D]&#125;栈顶元素：D栈中元素个数：4 栈的应用虚拟机栈的入栈和出栈操作在Java虚拟机运行时数据区有一块被称之为：虚拟机栈，它是线程私有的，声明周期与线程相同。 我们编写的每个Java方法，每个方法都会在执行的时候同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应这一个栈帧在虚拟机栈中入栈到出栈的过程。 现在我们假设有A、B、C三个方法，在A方法中调用B方法（A-&gt;B），在B方法中调用C方法（B-&gt;C），C方法执行本方法业务逻辑。 当程序执行到A()方法的中的第二行时，此时程序会中断A()方法并开始调用B()方法，然后会在虚拟机栈中记录调用B()方法的栈帧，我这里暂且称之为A2（实际存储的并不是O(∩_∩)O哈！）示意图如下： 同理，当程序执行到B()方法中第二行时，此时程序也会中断B()方法开始调用C()方法，然后同样地会在虚拟机栈中生成调用C()方法的栈帧并记录，我这里暂且称之为B2，示意图如下： 当程序开始执行到C()方法时，直到执行完C()方法时，这时候，程序该如何执行呢？ 此时就要查看一下虚拟机栈了，发现虚拟机栈，栈中栈顶的元素是B2，我们的程序就知道了，它是执行到B()方法的B2位置就中断了，去执行C()方法了；现在C()方法执行完成之后，它就可以跳回到B2的位置继续执行了，当B()方法执行完之后，虚拟机栈中的B2栈帧也就可以出栈了，依次类推…. 如果一个方法，使用递归调用，若递归临界点判断有误，则方法就会一直的被进行入栈操作，如果超过虚拟机栈的默认容量大小，则会出现我们常见的 StackOverflowError 异常 完整版代码GitHub仓库地址：Java版数据结构-栈 欢迎大家【关注】和【Star】 本次我们完成的是基于Java自身自带的集合LinkedList来实现栈，有兴趣的童鞋，可以使用动态数组方式来实现；接下来，笔者还会一一的实现其它常见的数组结构。 静态数组 动态数组 栈 队列 链表 循环链表 二分搜索树 优先队列 堆 线段树 字典树 AVL 红黑树 哈希表 …. 持续更新中，欢迎大家关注公众号：小白程序之路（whiteontheroad），第一时间获取最新信息！！！","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.gulj.cn/tags/数据结构/"}]},{"title":"Java版-数据结构-数组","slug":"Java版-数据结构-数组","date":"2019-03-10T12:19:33.000Z","updated":"2019-03-10T12:21:08.706Z","comments":true,"path":"2019/03/10/Java版-数据结构-数组/","link":"","permalink":"http://www.gulj.cn/2019/03/10/Java版-数据结构-数组/","excerpt":"数组知识点回顾声明Java数组时，会在内存中开辟一块连续指定大小的空间，用来存储固定大小的同类型元素 在java中定义个名为scores，长度为8，类型为int类型的数组如下： 123public static void main(String[] args) &#123; int[] scores = new int[8];&#125;","text":"数组知识点回顾声明Java数组时，会在内存中开辟一块连续指定大小的空间，用来存储固定大小的同类型元素 在java中定义个名为scores，长度为8，类型为int类型的数组如下： 123public static void main(String[] args) &#123; int[] scores = new int[8];&#125; 为了便于理解，我们看下它在内存的中的分布示意图： 图中的一个个小格子是用来存放数组的元素，小格子上方的0-7数字，是数组中每个元素的下标（也可以叫索引），如果我们要查询数组中指定位置的元素，我们可以通过数组名[索引]来获取，比如图中的scores[2] 在图中我们还可以看到，数组的起始下标是从0开始的（也就是第一个元素），最后一个元素的下标是7(也就是数组的长度8减1)由此类推，数组长度若是n，那么数组最后一个元素的下标是n-1（数组的起始下标总是从0开始的） 各位不要闲唠叨哈，为了照顾所有人（其实我的内心是很纠结的。。。😆） 自定义数组类思路分析使用data属性表示存放数组的元素， 使用capacity属性表示数组的容量（等价于数组的长度），但是真正自定义数组类的时候我们不需要显示声明，因为隐示等价于（Array.length） 使用size属性表示数组中真正存放元素的个数（注意和capacity概念的区分）。 我们画出示意图： 下面我们来完成初始代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ArrayExample &#123; /** * 存放数组的元素 */ private int data[]; /** * 数组中元素的个数 */ private int size; /** * 根据指定capacity容量初始化数组 * * @param capacity 容量 */ public ArrayExample(int capacity) &#123; data = new int[capacity]; size = 0; &#125; /** * 无参构造函数，指定默认数组容量capacity=10 */ public ArrayExample() &#123; this(10); &#125; /** * 获取数组中元素的个数 * * @return */ public int getSize() &#123; return size; &#125; /** * 获取数组容量 * * @return */ public int getCapacity() &#123; return data.length; &#125;&#125; 向数组中添加元素向指定位置添加元素假设现在数组的形态是这样，我们需要将77元素插入到索引为1的位置 思路分析：把当前索引为1的位置元素以及后面的元素都向后挪一个位置，然后将77这个元素放到索引为1的位置（注意：挪位置的时候，我们应该从最后一个元素100向后挪一个位置，换句话说从后往前挪），完成之后，维护一下size的索引，进行size++操作（size是始终指向数组中下一个没有元素的位置） 下面我们基于前面写的代码，来完成数组元素的添加操作 1234567891011121314151617181920212223242526/** * 在index位置插入元素 * * @param index 指定索引 * @param element 插入的元素 */public void add(int index, int element) &#123; // 简单的边界判断 if (size == data.length) &#123; throw new IllegalArgumentException(\"数组添加失败，数组已满\"); &#125; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"index索引不合法\"); &#125; // 从最后一个元素一直到size位置的元素，往后挪动一位 for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; // 位置赋值 data[index] = element; // 维护size大小 size++;&#125; 由于方面大家查看，只贴出添加数组元素的代码，本文文末，会贴出完成的代码示例地址 现在如果我们想把一个元素添加到数组头部的位置或者尾部的位置，我们可以这么做 1234567891011121314151617/** * 向数组头的位置添加元素 * * @param element 元素 */public void addFirst(int element) &#123; add(0, element);&#125;/** * 向数组尾的位置添加元素 * * @param element 元素 */public void addLast(int element) &#123; add(size, element);&#125; 大家一定要注重代码的复用性哈 查询数组元素和修改数组元素查询数组元素123456789101112/** * 获取index索引位置的元素 * * @param index 索引 * @return */public int get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"获取失败，索引不合法\"); &#125; return data[index];&#125; 修改数组元素123456789101112/** * 修改index索引位置的元素为element * * @param index 索引 * @param element 元素 */public void set(int index, int element) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"获取失败，索引不合法\"); &#125; data[index] = element;&#125; 包含数组元素和搜索数组元素包含数组元素123456789/** * 查找数组中是否有元素element * * @param element * @return */public boolean contains(int element) &#123; return Arrays.stream(data).filter(x -&gt; x == element).findAny().isPresent();&#125; 这里使用了Java8的lambda表达式，不知晓的盆友，可以自行去了解一下 搜索数组元素1234567891011121314/** * 查找数组中元素element所在的索引，如果不存在元素element，则返回-1 * * @param element * @return */public int find(int element) &#123; for (int i = 0; i &lt; data.length; i++) &#123; if (data[i] == element) &#123; return i; &#125; &#125; return -1;&#125; 删除数组中的元素现在我们要删除索引为1的元素77 思路分析：我们知晓了数组的插入思路，那么数组的删除思路，刚好和数组的插入思路相反，如果要删除索引为1位置的元素77，我们只需要，从索引2开始，将索引2位置的元素向左移动到索引为1的位置，也就是将索引2位置的元素的值赋值给索引为1位置的元素（等价于data[1]=data[2]），依次类推，将索引为3位置的元素，移动到索引为2位置的元素，一直到最后一个元素，比如图中的元素100，完成之后，这时候，我们需要再次维护一下size的大小，我们要进行size--操作 重要 size 既表示数组中元素的大小，又表示始终指向数组中第一个没有元素的位置 代码完成数组的删除操作 123456789101112131415161718192021222324/** * 删除索引index位置的元素，并将删除的元素返回 * * @param index * @return */public int remove(int index) &#123; // 简单判断数组索引的合法性 if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"删除数组元素失败，索引不合法\"); &#125; // 存放删除指定索引的位置元素 int result = data[index]; // 从删除指定索引的后一个位置，一直往前挪一位，直到最后一个元素 for (int i = index + 1; i &lt; size; i++) &#123; data[i - 1] = data[i]; &#125; // 维护size的位置 size--; return result;&#125; 完成了数组元素的删除操作，我们还可以便捷地为数组添加删除数组中第一个元素的方法和删除数组中最后一个元的方法。 删除数组中第一个元素的方法 12345678/** * 删除数组中第一个元素，并将删除的元素进行返回 * * @return */public int removeFirst() &#123; return remove(0);&#125; 删除数组中最后一个元素的方法 12345678/** * 删除数组中最后一个元素，并将删除的元素进行返回 * * @return */public int removeLast() &#123; return remove(size - 1);&#125; 至此，我们已经完成了数组的增删改查操作，下面我们写个测试类，来使用一下我们自己写的简单版数组 12345678910111213141516171819202122public class ArrayExampleTest &#123; @Test public void testAdd() &#123; // 初始化数组容量大小为5，目前数组中没有任何元素 ArrayExample arrayExample = new ArrayExample(5); System.out.println(arrayExample); // 向数组中欧添加第一个元素 arrayExample.addFirst(1); System.out.println(arrayExample); // 向数组中添加最后一个元素 arrayExample.addLast(2); System.out.println(arrayExample); // 向数组中索引为0的位置添加元素 arrayExample.add(0, 10); System.out.println(arrayExample); &#125; // TODO 其它测试方法，读者可以自行测试&#125; 运行结果 1234ArrayExample&#123;data=[0, 0, 0, 0, 0], size=0,capacity=5&#125;ArrayExample&#123;data=[1, 0, 0, 0, 0], size=1,capacity=5&#125;ArrayExample&#123;data=[1, 2, 0, 0, 0], size=2,capacity=5&#125;ArrayExample&#123;data=[10, 1, 2, 0, 0], size=3,capacity=5&#125; 完整版代码GitHub仓库地址：Java版数据结构-数组 欢迎大家关注和 Star 本次我们完成的是静态数组的实现，往往静态数组不够灵活，后面笔者会在代码仓库中实现动态数组，就不作为一个篇幅来讲解了，接下来，笔者还会一一的实现其它常见的数组结构。 静态数组 动态数组 栈 队列 链表 循环链表 二分搜索树 优先队列 堆 线段树 字典树 AVL 红黑树 哈希表 …. 持续更新中，欢迎大家关注公众号：小白程序之路（whiteontheroad），第一时间获取最新信息！！！","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.gulj.cn/tags/数据结构/"}]},{"title":"Java并发之原子性、有序性、可见性","slug":"Java并发之原子性、有序性、可见性","date":"2019-03-04T12:34:40.000Z","updated":"2019-03-10T12:21:17.695Z","comments":true,"path":"2019/03/04/Java并发之原子性、有序性、可见性/","link":"","permalink":"http://www.gulj.cn/2019/03/04/Java并发之原子性、有序性、可见性/","excerpt":"原子性​ 原子性指的是一个或者多个操作在 CPU 执行的过程中不被中断的特性 线程切换 带来的原子性问题 Java 并发程序都是基于多线程的，操作系统为了充分利用CPU的资源，将CPU分成若干个时间片，在多线程环境下，线程会被操作系统调度进行任务切换。","text":"原子性​ 原子性指的是一个或者多个操作在 CPU 执行的过程中不被中断的特性 线程切换 带来的原子性问题 Java 并发程序都是基于多线程的，操作系统为了充分利用CPU的资源，将CPU分成若干个时间片，在多线程环境下，线程会被操作系统调度进行任务切换。 为了直观的了解什么是原子性，我们看下下面哪些操作是原子性操作 123int count = 0; //1count++; //2int a = count; //3 上面展示语句中，除了语句1是原子操作，其它两个语句都不是原子性操作，下面我们来分析一下语句2 其实语句2在执行的时候，包含三个指令操作 指令 1：首先，需要把变量 count 从内存加载到 CPU的寄存器 指令 2：之后，在寄存器中执行 +1 操作； 指令 3：最后，将结果写入内存 对于上面的三条指令来说，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。 操作系统做任务切换，可以发生在任何一条CPU 指令执行完 有序性​ 有序性指的是程序按照代码的先后顺序执行 编译优化 带来的有序性问题 为了性能优化，编译器和处理器会进行指令重排序，有时候会改变程序中语句的先后顺序，比如程序： 123a = 5; //1b = 20; //2c = a + b; //3 编译器优化后可能变成 123b = 20; //1a = 5; //2c = a + b; //3 在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果 synchronized（具有有序性、原子性、可见性）表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。 在单例模式的实现上有一种双重检验锁定的方式（Double-checked Locking） 123456789101112public class Singleton &#123; static Singleton instance; static Singleton getInstance()&#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 我们先看 instance = new Singleton() 的未被编译器优化的操作 指令 1：分配一块内存 M； 指令 2：在内存 M 上初始化 Singleton 对象； 指令 3：然后 M 的地址赋值给 instance 变量。 编译器优化后的操作指令 指令 1：分配一块内存 M； 指令 2：将 M 的地址赋值给 instance 变量； 指令 3：然后在内存 M 上初始化 Singleton 对象。 现在有A，B两个线程，我们假设线程A先执行getInstance()方法，当执行编译器优化后的操作指令2时（此时候未完成对象的初始化），这时候发生了线程切换，那么线程B进入，刚好执行到第一次判断 instance==null会发现instance不等于null了，所以直接返回instance，而此时的 instance 是没有初始化过的。 现行的比较通用的做法就是采用静态内部类的方式来实现 12345678910public class SingletonDemo &#123; private SingletonDemo() &#123; &#125; private static class SingletonDemoHandler&#123; private static SingletonDemo instance = new SingletonDemo(); &#125; public static SingletonDemo getInstance() &#123; return SingletonDemoHandler.instance; &#125;&#125; 可见性​ 可见性指的是当一个线程修改了共享变量后，其他线程能够立即得知这个修改 缓存 导致的可见性问题 首先我们来看一下Java内存模型（JMM） 我们定义的所有变量都储存在主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝） 线程对共享变量所有的操作都必须在自己的工作内存中进行，不能直接从主内存中读写（不能越级） 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行。（同级不能相互访问） 共享变量可见性的实现原理： 线程1对共享变量的修改要被线程2及时看到的话，要经过如下步骤： 把工作内存1中更新的变量值刷新到主内存 把主内存中的变量的值更新到工作内存2中 可以使用 synchronized 、volatile 、final 来保证可见性","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://www.gulj.cn/tags/并发编程/"}]},{"title":"awk命令使用详解","slug":"awk命令使用详解","date":"2019-02-24T23:37:10.000Z","updated":"2019-02-24T23:38:40.419Z","comments":true,"path":"2019/02/25/awk命令使用详解/","link":"","permalink":"http://www.gulj.cn/2019/02/25/awk命令使用详解/","excerpt":"awk 命令介绍AWK是一种处理文本文件的语言，是一个强大的文本分析工具，之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger， 和 Brian Kernighan 的 Family Name 的首字符。 语法 第一种形式 1$ awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file 第二种形式 1$ standard output | 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;'","text":"awk 命令介绍AWK是一种处理文本文件的语言，是一个强大的文本分析工具，之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger， 和 Brian Kernighan 的 Family Name 的首字符。 语法 第一种形式 1$ awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file 第二种形式 1$ standard output | 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' 工作原理 其中数字1，2，3…代表是文本中的数据行 BEGIN{} 表示在处理文本数据之前进行一些操作 pattern{commands} 表示从文本中的第一行开始匹配满足pattern规则的行，执行commands命令，直到文本最后一行 END{} 表示在处理文本数据之后进行一些操作 内建变量 内置变量 含义 $0 整行内容 $1-$n 当前行的第1-n个字段 NF 当前行的字段个数，也就是有多少列 NR 当前的行号，从1开始计数 FNR 各文件分别计数的行号 FS 字段分隔符(默认以空格或tab键分割) RS 输入行分隔符。默认回车换行 OFS 输出字段分隔符。默认为空格 ORS 输出行分隔符。默认为回车换行 FILENAME 当前文件名 内置变量如何使用，我们以文本score.txt内容来做演示 12345$ cat score.txtmarry 90 49 23 14join 44 55 66 24smile 55 78 80 34jack 20 51 66 44 使用$0来打印输出文件的每一整行的内容 12345$ awk '&#123;print $0&#125;' score.txtmarry 90 49 23 14join 44 55 66 24smile 55 78 80 34jack 20 51 66 44 注意：行匹配语句 awk ‘ ‘ 只能用单引号 使用$1、$3来打印输出文件的的每一行第1列和第3列内容 12345$ awk '&#123;print $1,$3&#125;' score.txtmarry 49join 55smile 78jack 51 使用NF来输出每一行的列数 12345$ awk '&#123;print NF&#125;' score.txt5555 使用awk没有指定分隔符，默认是以空格或者tab键来作分隔，在score.txt 文件中，经过分隔，每行都有5列 使用变量$NF来输出文件 12345$ awk '&#123;print $NF&#125;' score.txt14243444 从输出结果我们总结出，$NF就表示每一行的最后一列，因为文件中每一行有5列，则 $NF = $5 之前我们打印每一行的第1列和第3列我们使用的是：$1，$3；那么现在我们也可以使用：$(NF-2)，$(NF-4) 12345$ awk '&#123;print $(NF-4),$(NF-2)&#125;' score.txtmarry 49join 55smile 78jack 51 使用NR来输出每一行的行号，这次我们把每一行的内容也打印出来 12345$ awk '&#123;print NR \"\\t\" $0&#125;' score.txt1 marry 90 49 23 852 join 44 55 66 223 smile 55 78 80 244 jack 20 51 66 89 使用ORS来指定输出每一行的指定的分隔符 12$ awk 'BEGIN&#123;ORS=\"---\"&#125; &#123;print $1,$NF&#125;' score.txtmarry 14---join 24---smile 34---jack 44--- 指定了每一行的分隔符为”—“，现在输出的每一行都用—做分隔，而不在是默认的回车换行做分隔 使用ORS指定了行的分隔符为”—“，但是现在我们看到每一行输出的分隔符还是默认的空格来做分隔，比如：输出第一行的 marry 14，现在我们使用OFS来指定输出字段的分隔符，比如：*号 12$ awk 'BEGIN&#123;ORS=\"---\";OFS=\"*\"&#125; &#123;print $1,$NF&#125;' score.txtmarry*14---join*24---smile*34---jack*44--- 使用FS指定每一行的字段分隔符 123$ awk 'BEGIN&#123;FS=\":\"&#125; &#123;print $1,$NF&#125;' /etc/passwdroot /bin/bashbin /sbin/nologin 也可以使用这种形式指定分隔符（-F的意思就是指定分隔符） 1$ awk -F: '&#123;print $1,$NF&#125;' /etc/passwd 如果指定多个分隔符，使用中括号[]包起来，里面指定具体的分隔符 1$ awk -F '[-:]' 使用FILENAME在处理多文件时候，可以打印出当前的文件名 1234567$ awk 'BEGIN&#123;FS=\"[ :]\"&#125; &#123;print FILENAME \"\\t\" $1,$NF&#125;' score.txt /etc/passwdscore.txt marry 14score.txt join 24score.txt smile 34score.txt jack 44/etc/passwd root /bin/bash/etc/passwd bin /sbin/nologin 使用重定向拆分文件准备文件 netstat.txt 1234567891011121314$ cat netstat.txtProto Recv-Q Send-Q Local-Address Foreign-Address Statetcp 0 0 0.0.0.0:111 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTENtcp 0 0 127.0.0.1:25 0.0.0.0:* LISTENtcp 0 0 192.168.10.10:22 192.168.10.1:65016 ESTABLISHEDtcp 0 0 192.168.10.10:22 192.168.10.1:57253 ESTABLISHEDtcp6 0 0 :::111 :::* LISTENtcp6 0 0 :::22 :::* LISTENtcp6 0 0 ::1:25 :::* LISTENudp 0 0 0.0.0.0:1018 0.0.0.0:* FIN_WAIT2udp6 0 0 :::1018 :::* FIN_WAIT2udp6 0 0 :::111 :::* ESTABLISHEDudp6 0 0 ::1:323 :::* ESTABLISHED 以空格为分隔符，按照$6(第6列)也就是State列进行拆分文件netstat.txt（其中NR!=1表示不处理表头） 12345678910111213141516171819202122$ awk 'NR!=1&#123;print &gt; $6&#125;' netstat.txt$ lsESTABLISHED FIN_WAIT2 LISTEN netstat.txt$ cat ESTABLISHEDtcp 0 0 192.168.10.10:22 192.168.10.1:65016 ESTABLISHEDtcp 0 0 192.168.10.10:22 192.168.10.1:57253 ESTABLISHEDudp6 0 0 :::111 :::* ESTABLISHEDudp6 0 0 ::1:323 :::* ESTABLISHED$ cat FIN_WAIT2udp 0 0 0.0.0.0:1018 0.0.0.0:* FIN_WAIT2udp6 0 0 :::1018 :::* FIN_WAIT2$ cat LISTENtcp 0 0 0.0.0.0:111 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTENtcp 0 0 127.0.0.1:25 0.0.0.0:* LISTENtcp6 0 0 :::111 :::* LISTENtcp6 0 0 :::22 :::* LISTENtcp6 0 0 ::1:25 :::* LISTEN {print &gt; $6} 是按照第6列进行拆分，将所有列输出到文件中，我们也可以指定列输出到文件中 1$ awk 'NR!=1&#123;print $1,$4&gt; $6&#125;' netstat.txt awk使用printf格式化输出printf 格式说明符 格式符 含义 %s 打印字符串 %d 打印十进制数 %f 打印一个浮点数 %x 打印十六进制数 %o 打印八进制数 %e 打印数字的科学计数法形式 %c 打印单个字符的ASCII码 printf 修饰符 修饰符 含义 - 左对齐 + 右对齐 # 8进制显示在前面加0，16进制显示在前面加0X 上面演示的案例，我们都是用print来做输出（默认是输出每行内容，用回车键作为换行），现在我们使用printf（默认没有加任何的输出分隔符）来进行格式化打印输出 使用%s以字符串形式输出/etc/passwd文件中第一列 12345$ awk -F: '&#123;printf \"%s\\n\",$1&#125;' /etc/passwdrootbindaemon... 使用 \\n 来指定输出每行的的分隔符 使用$s、%f、%d、%x等多个格式符来输出 123456$ awk -F: '&#123;printf \"%s %f %d %x\\n\",$1,$3,$3,$3&#125;' /etc/passwdsshd 74.000000 74 4apostfix 89.000000 89 59chrony 998.000000 998 3e6vagrant 1000.000000 1000 3e8vboxadd 997.000000 997 3e5 使用了不同的格式符，输出了/etc/passwd文件中的$1，$3列，对于稍微有点强迫症患者的朋友来说，可以看出输出结果并不美观，比如：每列都没有对齐（向左或者向右），浮点数列没有控制指定个数的精度等，下面我们就来解决这个问题 123456$ awk -F: '&#123;printf \"%-20s %-0.2f \\t\\t %-20d %-20x\\n\",$1,$3,$3,$3&#125;' /etc/passwdsshd 74.00 74 4apostfix 89.00 89 59chrony 998.00 998 3e6vagrant 1000.00 1000 3e8vboxadd 997.00 997 3e5 我们可以在每个格式符的前面加上数字，比如：%20s，表示这一列占位20个字符 使用 %0.2f 来指定这一列输出的精度，保留2位小数 使用 -格式符，表示输出的结果向左对齐 关系运算符、布尔运算符和匹配正则表达式 运算符 含义 &lt;、 &lt;=、 &gt;、 &gt;=、 != 、 == 小于、小于等于…（关系运算符） ~ 匹配正则表达式 ~！ 不匹配正则表达式 \\ \\ 逻辑或 &amp;&amp; 逻辑与 ！ 非 匹配输出第一列字符等于smile的行 12$ awk '$1==\"smile\" &#123;print $0&#125;' score.txtsmile 55 78 80 34 匹配输出第一列字符等于smile的行 ，或者第2列大于 80的行 123$ awk '$1==\"smile\" || $2 &gt; 80 &#123;print $0&#125;' score.txtmarry 90 49 23 14smile 55 78 80 34 使用正则，匹配输出包含44的行 123$ awk '/44/ &#123;print $0&#125;' score.txtjoin 44 55 66 24jack 20 51 66 44 使用正则，匹配输出不包含44的行 123$ awk '!/44/ &#123;print $0&#125;' score.txtmarry 90 49 23 14smile 55 78 80 34 使用正则，匹配输出以join字符开头的行到以jack字符开头结束的行 1234$ awk '/^join/,/^jack/ &#123;print $0&#125;' score.txtjoin 44 55 66 24smile 55 78 80 34jack 20 51 66 44 使用正则，匹配第1列字符包含jack并且最后一列大于等于34 12$ awk '$1 ~ /jack/ &amp;&amp; $NF &gt;= 34 &#123;print $0&#125;' score.txtjack 20 51 66 44 ~ 表示模式开始；/ / 中表示的是匹配的具体模式 现在看下正则模式取反的示例 123$ awk '$1 !~ /jack/ &amp;&amp; $NF &gt;= 24 &#123;print $0&#125;' score.txtjoin 44 55 66 24smile 55 78 80 34 !~ ，第1列不包含字符jack 并且最后列的值大于等于24 算术运算符 运算符 含义 + 、 - 加、减 * 、/ 、 % 乘、除、求于 ++、– 增加或减少，作为前缀或后缀，如（++x、x–） 我们先来看一下简单的加法和除法运算 123456$ awk 'BEGIN&#123; num1=10; num2=20; printf \"%d %0.2f\\n\", num1+num2,num1/num2&#125;'30 0.50 awk 声明的变量可以在任何多个花括号脚本中使用 计算/etc/services中空白行的数量 12$ awk '/^$/ &#123;sum++&#125; END&#123;print sum&#125;' /etc/services17 字符串函数 函数名 含义 length(str) 计算字符串长度 index(str1,str2) 在str1中查找str2的位置 tolower(str) 转换为小写 toupper(str) 转换为大写 substr(str,m,n) 从str的第m个字符开始，截取m位 split(str,arr,fs) 按fs切割字符，结果保存arr中 match(str,RE) 在str中按照RE查找 由于字符串函数是我们工作中常用的函数，比较简单，下面我们使用split()函数来做演示 12345678910$ awk 'BEGIN&#123; str=\"java#python#go\"; split(str,arr,\"#\"); for(item in arr)&#123; print arr[item] &#125;&#125;'javapythongo 其中我们使用了for循环来遍历 arr 数组，下面我们会讲到 awk动作中使用条件及循环语句（可见awk是个脚本解释器）条件表达式 if语句 语法格式如下： 123if(条件)&#123; 动作&#125; 示例： 1$ awk -F: '&#123;if($3&gt;100 &amp;&amp; $3&lt;1000) print $0&#125;' /etc/passwd if - else 语句 语法格式如下： 12345if(条件)&#123; 动作&#125;else&#123; 动作&#125; 示例： 12345678$ awk 'BEGIN &#123; num = 11; if (num % 2 == 0) &#123; printf \"%d 是偶数\\n\", num &#125;else &#123; printf \"%d 是奇数\\n\", num &#125;&#125;' if - else - if 语句 语法格式如下： 1234567if(条件)&#123; 动作&#125;else if(条件)&#123; 动作&#125;else&#123; 动作&#125; 示例： 12345678910$ awk -F: '&#123; if($3&lt;100) &#123; print \"系统用户\", $1 &#125; else if($3&gt;100 &amp;&amp; $3 &lt;900) &#123; print \"普通用户\", $1 &#125; else &#123; print \"其它用户\", $1 &#125; &#125;' /etc/passwd 循环语句 while 语句 123while(条件)&#123; 循环体&#125; 示例： 1$ awk 'BEGIN &#123;i=1; while(i&lt;6)&#123; print i; ++i &#125; &#125;' do - while语句 语法格式： 123do&#123; 循环体&#125;while(条件) 示例： 1awk 'BEGIN&#123;i=1;do&#123;print i;i++&#125;while(i&lt;6)&#125;' for 语句 语法格式： 123for(变量;条件;表达式)&#123; 动作&#125; 示例： 1234567$ awk 'BEGIN&#123; sum=0; for(i=1;i&lt;=100;i++)&#123; sum+=i &#125; print sum&#125;' 常用选项 选项 含义 -v 参数传递 -V 查看awk的版本号 -f 指定脚本文件 -F 指定分隔符 使用-v引入外部变量 123$ a=1$ b=\"spring is framework\"$ awk -v c=\"$a\" -v d=\"$b\" 'BEGIN&#123;print c , d&#125;' 把awk的执行动作写在脚本中，使用-f指定脚本文件 12$ vim print.awk$ BEGIN&#123;print c , d&#125; 执行脚本文件：print.awk 1awk -v c=\"$a\" -v d=\"$b\" -f print.awk 使用-F指定分隔符 我们之前可以使用内置变量FS来指定分隔符，比如： 1$ awk 'BEGIN&#123;FS=\":\"&#125; &#123;print $1&#125;' /etc/passwd 现在等价于： 123$ awk -F \":\" '&#123;print $1&#125;' /etc/passwd# 或者$ awk -F: '&#123;print $1&#125;' /etc/passwd","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.gulj.cn/tags/linux/"}]},{"title":"sed命令","slug":"sed命令","date":"2019-02-20T03:37:10.000Z","updated":"2019-02-20T03:41:33.914Z","comments":true,"path":"2019/02/20/sed命令/","link":"","permalink":"http://www.gulj.cn/2019/02/20/sed命令/","excerpt":"介绍sed（Stream Editor） ， 流编辑器。对标准输出或文件逐行处理 语法格式 第一种形式 1$ stdout | sed [option] \"pattern command\" 第二种形式 1$ sed [option] \"pattern command\" file","text":"介绍sed（Stream Editor） ， 流编辑器。对标准输出或文件逐行处理 语法格式 第一种形式 1$ stdout | sed [option] \"pattern command\" 第二种形式 1$ sed [option] \"pattern command\" file sed中选项（option） 选项 含义 -n 取消默认输出 -e 多点编辑，可以执行多个子命令 -i 直接修改文件内容 -r 支持扩展正则表达式 正则的一些基本知识点（下文会用到） ^ 表示一行的开头 1/^#/ # 以#号开头的匹配 $表示一行的结尾 1/root$/ # 以root结尾的匹配 .表示任何单个字符 *表示某一个字符出现了0次或多次 []表示字符集合 1[ABC] # 表示匹配A或B或C sed中pattern详解（重要） LineNumber (直接指定行号) 打印file中17行 1$ sed -n '17p' file 其中的p表示打印，下面讲解编辑命令会提到 StartLine,EndLine (指定起始行到结束行号) 打印file中10到12行 1$ sed -n '10,12p' file StartLine,+N (指定起始行然后到后面N行) 打印file中从第10行开始，往后面加5行的内容 1$ sed -n '10,+5p' file /pattern1/ （正则表达式匹配） 打印file文件中以root开头的行 1$ sed -n '/^root/p' file 打印file文件中中包含字符为 /sbin/halt 的行 1$ sed -n '/\\/sbin\\/halt/p' /etc/passwd 匹配字符中 /sbin/halt 带有斜杠 / 在匹配时，需要用反斜杠 \\ 转义 /pattern1/,/pattern2/ (从匹配到pattern1的行，到匹配到pattern2的行) 打印file文件中第一个匹配到以ftp开头的行，到第二个匹配到以mail开头的行 1$ sed -n '/^ftp/,/^mail/p' file LineNumber,/pattern1/ (从指定行号开始匹配，直到匹配到pattern1的行) 打印file中从第4行开始匹配，直到匹配到以hdfs开头的行 1$ sed -n '4,/^hdfs/p' file 如果指定LineNumber的行 ​ 在匹配目标字符前面，则输出的是从LineNumber行到目标字符行的所有内容 ​ 在匹配目标字符后面，则输出的是从LineNumber行一直到文件末尾的所有内容 sed中编辑命令（command）详解 类别 含义 查询 p 打印 增加 a 行后增加 i 行前增加 r 外部文件读入，行后增加 w 匹配行，写入外部文件 删除 d 删除 修改 s/old/new 将行内第一个old替换为new s/old/new/g 将行内全部的old替换为new s/old/new/2g 将行内从第二2个开始到后面所有的old替换为new s/old/new/ig 将行内全部的old替换为new，忽略大小写 取代 c 替换匹配行 备注，下文提到的文件 file，读者可以使用 /etc/passwd 文件作为练习（记得拷贝一份） 案例中的示例都是基于下方的形式： 1'pattern command' 其中的 ​ pattern：是上文提到的几种形式 ​ command：是下文提到的 比如：p是打印，d是删除等 d （删除） 删除源文件中以ftp开头的行到mail结束的行 1$ sed -i '/^ftp/,/^mail/d' file 在讲解sed中pattern的时候，我们已经用过编辑命令 p 的功能，其它功能都可以使用 pattern讲解中的形式 a （增加，行后） 在file中匹配到root的行，在其行后增加字符 “123” 1$ sed -i '/root/a 123' file r （将后面指定文件的内容追加到匹配到行后面） 在file中匹配到root的行，将当前路劲下文件append.txt中的内容，添加到匹配行的后面 1$ sed -i '/root/r append.txt' file w （将匹配到行内容，另存到其它文件中） 在file中匹配到/bin/bash的行保存在/etc/result.log文件中 1$ sed -n '/\\/bin/\\bash/w /etc/result.log' file s/pattern/string/ig （将匹配到行内容，另存到其它文件中） 在file中匹配到不区分大小写的hadoop的字符替换为hive 1$ sed -i 's/hadoop/hive/ig' file = （将匹配到行，只显示行号，不显示内容） 在file中匹配到root的行，只显示行号，不输出内容 1$ sed -n '/root/=' file &amp; 和 \\1 （反向引用，引用模式匹配到的整个串） 在file文件中匹配到springcl..d的字符，在后面加上字符abc 1$ sed -i 's/springcl..d/&amp;abc/g' file sed 中引用变量时，则建议使用双引号，否则会将变量当做普通字符串来处理 123old_hadoop=hadoopnew_hadoop=HADOOP$ sed -i \"s/$old_hadoop/$new_hadoop/g\" file # 使用双引号引起来 c 匹配字符daemon的行，替换为字符 input repalce content 1$ sed '/daemon/c input repalce content' file 多行匹配 在file文件中匹配到以ssh字符开头的行，替换第一个字符sshd为hive和匹配以false结尾的字符的行，在行前面插入内容 ABC 1$ sed '/^ssh/s/sshd/hive/1g; /false$/i ABC' file 上面的命令等价于：（使用sed的-e命令行参数） 1$ sed -e '/^ssh/s/sshd/hive/1g' -e '/false$/i ABC' file","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.gulj.cn/tags/linux/"}]},{"title":"grep命令","slug":"grep命令","date":"2019-02-19T03:30:44.000Z","updated":"2019-02-19T03:36:13.784Z","comments":true,"path":"2019/02/19/grep命令/","link":"","permalink":"http://www.gulj.cn/2019/02/19/grep命令/","excerpt":"grep 命令介绍Linux grep命令用于查找文件里符合条件的字符串。 语法格式 第一种形式 1$ grep [option][pattern][file1,file2] 第二种形式 1$ command | grep [option][pattern]","text":"grep 命令介绍Linux grep命令用于查找文件里符合条件的字符串。 语法格式 第一种形式 1$ grep [option][pattern][file1,file2] 第二种形式 1$ command | grep [option][pattern] 参数（[option]） 选项 含义 -v 不显示匹配行信息 -i 搜索时忽略大小写 -e 指定字符串做为查找文件内容的样式 -E 支持扩展正则表达式 -f 指定规则文件，其内容含有一个或多个规则样式，按照规则文件查找 -F 不按正则表达式匹配，将样式视为固定字符串的列表 -n 显示行 -o 只显示匹配PATTERN 部分 -r 递归搜索 -c 只显示匹配行的总数 -w 匹配整词 -l 只显示文件名，不显示内容 -s 不显示错误信息 -A n 输出匹配行的后n行 -B n 输出匹配行的前n行 -C n 输出匹配行的前后n行 示例 准备文本文件app.txt 1234i love javai love JAVAI LOVE JAVAi lovelove java 查找字符 在app.txt文件中查找字符 “java” 123$ grep java app.txti love javai lovelove java -e 在不同文件中查找 “java” 和 “root” 字符，使用-e参数，我们可以查找多个模式。 12345$ grep -e \"java\" app.txt -e \"root\" /etc/passwdapp.txt:i love javaapp.txt:i lovelove java/etc/passwd:root:x:0:0:root:/root:/bin/bash/etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin 使用 $ 符号输出所有以指定模式结尾的行 匹配/etc/passwd文件中以nologin字符结尾的行 123456$ grep \"nologin$\" /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologin -f -e 选项中我们指定了两个-e选项，一个是 -e “java” 另外一个是 -e “root” 我们可以把这个两个搜索的词，写到一个文件中，按照文件中定义的模式进行搜索 定义文件 grep_file_pattern 12345# 匹配以root开头的行、以nologin结尾的行、包含vagrant字符的行$ cat grep_file_pattern^rootnologin$vagrant 使用 grep_file_pattern 文件进行搜索 12345678$ grep -f grep_file_pattern /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinvagrant:x:1000:1000:vagrant:/home/vagrant:/bin/bash -F 使用-F”选项，则查找的字符当做普通字符来处理，比如：”^i” 如果不加-F选项，则匹配到包含ja的字符行，加了-F选项，只匹配 “^i” 的字符 1234567# 不加-F选项,匹配以 i 开头的行$ grep \"^i\" app.txti love javai love JAVAi lovelove java# 加-F选项,匹配包含字符 \"^i\" 的行,输出结果为空$ grep -F \"^i\" app.txt -v 输出 app.txt 文件中不包含 “java” 字符的行 123$ grep -v java app.txti love JAVAI LOVE JAVA -i 使用-i选项，则忽略匹配字符的大小写，java或JAVA字符都能匹配到 12345$ grep -i java app.txti love javai love JAVAI LOVE JAVAi lovelove java -n 使用-n选项，则匹配到的行的内容，前面会加上对应的行号 123$ grep -n java app.txt1:i love java4:i lovelove java -E 使用-E选项，支持 | 等的扩展表达式，意思是匹配包含java或者JAVA字符的行，如果不加-E选项，则 “java|JAVA” 就看作一个整体的字符来处理 12345678# 加-E选项$ grep -E \"java|JAVA\" app.txti love javai love JAVAI LOVE JAVAi lovelove java# 不加-E选项，输出结果为空$ grep \"java|JAVA\" app.txt -r 使用-r参数，递归/etc/目录下包含 “vagrant”字符的行 123456$ grep -r vagrant /etc//etc/group:vagrant:x:1000:vagrant/etc/sudoers.d/vagrant:%vagrant ALL=(ALL) NOPASSWD: ALL/etc/passwd-:vagrant:x:1000:1000:vagrant:/home/vagrant:/bin/bash/etc/gshadow:vagrant:!!::vagrant/etc/gshadow:docker:!::vagrant -l 使用-l参数，输出包含”vagrant”字符的文件名 123$ grep -l vagrant /etc/passwd /etc/shadow app.txt/etc/passwd/etc/shadow -o 使用-o参数，只显示匹配 LOVE 字符 12$ grep -o -n LOVE app.txt3:LOVE -C 使用-C参数，输出匹字符”dbus”行的前后 2 行 123456$ grep -C 2 dbus /etc/passwdnobody:x:99:99:Nobody:/:/sbin/nologinsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinpolkitd:x:999:998:User for polkitd:/:/sbin/nologinrpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin 查找文件中所有的空行 1$ grep ^$ /data/log/nginx.log","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.gulj.cn/tags/linux/"}]},{"title":"find命令","slug":"find和grep命令-1","date":"2019-02-14T07:17:44.000Z","updated":"2019-02-14T10:04:19.833Z","comments":true,"path":"2019/02/14/find和grep命令-1/","link":"","permalink":"http://www.gulj.cn/2019/02/14/find和grep命令-1/","excerpt":"语法格式1find 【路径】【选项】【操作】","text":"语法格式1find 【路径】【选项】【操作】 选项参数 选项 含义 -name 根据文件名查找 -iname 根据文件名查找不区分大小写 -perm 根据文件权限查找 -prune 该选项可以排除某些目录 -user 根据文件属主查找 -group 根据文件属组查找 -mtime -n 或 +n 根据文件更改时间查找，以天为单位 -mmin -n 或 +n 根据文件更改时间查找，以分钟为单位 -nogroup 查找无有效属组的文件 -nouser 查找无有效属主的文件 -type 按文件类型查找 -size -n 或 +n 按文件大小查找 -mindepth n 从n级子目录开始查找 -maxdepth n 最多搜多到n级子目录 示例说明 -name 查找/etc目录下已conf结尾的文件 1find /etc -name \"*.conf\" -user 查找当前目录下属主食hadoop的文件 1find . -user hadoop -type f (文件) d (目录) c (字符设备文件) l (链接文件) p (管道文件) 查找当前路径下的文件 1find . -type f -size -n (大小小于n的文件) +n (大小大于n的文件) 查找/etc目录下小于1000的字节文件 1find /etc -size -1000c 查找/etc目录下大于1兆的文件 1find /etc -size +1M -mtime -n (n天以内修改的文件) +n (n天以外修改的文件) 查找/etc目录下3天以内修改的文件且以conf结尾的文件 1find /etc -mtime -3 -name \"*.conf\" 查找/etc目录下30分钟之前修改的目录 1find /etc -mmin +30 -type d mindepth 从/etc目录下3级子目录开始搜索文件 1find /etc -mindepth 3 -type f maxdepth 从/etc目录下查找文件权限为644，最多搜索到2级目录（当前位置表示一级目录） 1find /etc -maxdepth 2 -perm 644 -prune 通常和path一起使用，用于将特定的目录排除在搜索之外 查找当前目录下所有文件，但排除log目录 1find . -path ./log -prune -o -type f 查找当前目录下所有文件，但排除log目录和lib目录 1find . -path ./log -prune -o -path ./lib -prune -o -type f -exec 对搜索到文件执行特定的操作，格式为：-exec ‘command’ {} \\; {} 表示find查询到的结果集 搜索/etc下的文件，文件名以conf结尾，且大小大于2K，然后将其复制到/root/hadoop目录下 1find /etc -name \"*.conf\" -size +2K -type f -exec cp -r &#123;&#125; /root/hadoop \\; find、locate、whereis和which总结及使用场景分析find和locate的区别 find locate 在整块磁盘中搜索 在数据库文件中查找 默认是全部匹配 默认是模糊匹配 新创建的文件，使用locate命令暂时查找不到，因为后台cron任务还未执行，可以使用updatedb命令刷新locate查找的数据库，这样就能查找到刚才新建的文件了 whereis 选项 含义 -b 只返回二进制文件 -m 只返回帮助文档文件 -s 只返回源代码文件 which 选项 含义 -b 只返回二进制文件 各命令使用场景及优缺点 命令 适用场景 优缺点 find 查找某一类文件 功能强大，速度慢 locate 只能查找单个文件 功能单一，速度快 whereis 查找程序的可执行文件、帮助文档等 不常用 which 只查找程序的可执行文件 常用于查找程序的绝对路径","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.gulj.cn/tags/linux/"}]},{"title":"Btrace监控调试基本教程","slug":"Btrace监控调试基本教程","date":"2018-07-30T07:53:46.000Z","updated":"2019-02-14T07:07:12.859Z","comments":true,"path":"2018/07/30/Btrace监控调试基本教程/","link":"","permalink":"http://www.gulj.cn/2018/07/30/Btrace监控调试基本教程/","excerpt":"拦截方法 普通方法 1@OnMethod( clazz = \"\", method = \"\") 上一篇文章我们已经介绍，不清楚的小伙伴，可自行前往查看 构造函数 1@OnMethod( clazz = \"\", method = \"&lt;init&gt;\")","text":"拦截方法 普通方法 1@OnMethod( clazz = \"\", method = \"\") 上一篇文章我们已经介绍，不清楚的小伙伴，可自行前往查看 构造函数 1@OnMethod( clazz = \"\", method = \"&lt;init&gt;\") 代码示例 新建User类 1234567@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private String name; private int age;&#125; 编写待追踪代码 ConstructorController.java 1234567@RestControllerpublic class ConstructorController &#123; @GetMapping(\"/constructor\") public User constructor(User user) &#123; return user; &#125;&#125; 编写追踪代码脚本 BtracePrintConstructorArgSimple.java 123456789@BTracepublic class BtracePrintConstructorArgSimple &#123; @OnMethod(clazz = \"com.gulj.monitor.domain.User\", method = \"&lt;init&gt;\") public static void andyRead(@ProbeClassName String pcn, @ProbeMethodName String pmn, AnyType[] args) &#123; BTraceUtils.printArray(args); BTraceUtils.println(\"className=\" + pcn + \",\" + \"methodName=\" + pmn); &#125;&#125; 运行追踪代码脚本 1btrace pid BtracePrintConstructorArgSimple.java 发送请求 1curl http://localhost:8080/constructor?name=gulj&amp;age=27 执行命令 btrace pid BtracePrintConstructorArgSimple.java (一起处于监听状态，当我们发送请求，会有监听结果输出) 还有笔者在测试的过程中有的时候没有监测到输出，当遇到这种情况，有的时候是因为慢的缘故，有的时候还请小伙伴多执行几次请求 同名函数，用参数区分 代码示例 编写待追踪代码 SameMethodController.java 1234567891011121314@RestControllerpublic class SameMethodController &#123; @GetMapping(\"/method1\") public String method(@RequestParam(\"name\") String name) &#123; return name; &#125; @GetMapping(\"/method2\") public String method(@RequestParam(\"name\") String name, @RequestParam(\"age\") int age) &#123; return name + age; &#125;&#125; 编写追踪代码脚本 BtracePrintConstructorArgSimple.java 123456789101112131415161718192021222324@BTracepublic class BtracePrintSameMethodArgSimple &#123; /** * 注意，这个两个方法，除了最后的参数个数不同，其它都一样，读者在测试的时候可自行选择放开测试 */ // curl:http://localhost:8080/method2?name=xxx&amp;age=100 @OnMethod(clazz = \"com.gulj.monitor.controller.SameMethodController\", method = \"method\") public static void method(@ProbeClassName String pcn, @ProbeMethodName String pmn,String name,int age) &#123; BTraceUtils.println(\"className=\" + pcn + \",\" + \"methodName=\" + pmn + \",\" + \"name=\" + name +\",\" + \"age=\" + age); &#125; /* //访问：curl:http://localhost:8080/method1?name=xxx @OnMethod(clazz = \"com.gulj.monitor.controller.SameMethodController\", method = \"method\") public static void method(@ProbeClassName String pcn, @ProbeMethodName String pmn,String name) &#123; BTraceUtils.println(\"className=\" + pcn + \",\" + \"methodName=\" + pmn + \",\" + \"name=\" + name ); &#125; */&#125; 发送请求 1curl:http://localhost:8080/method1?name=gulj&amp;age=12 监控结果 通过笔者以上的介绍，小伙伴们想必已经知道btrace怎么玩了，下面为了避免篇幅过长，笔者只给出示例代码中的待追踪代码和追踪代码，小伙伴们自行运行查看效果。 拦截返回值、异常、行号拦截返回值拦截线上代码方法的返回值 编写待追踪代码 ReturnValueController.java12345678@RestControllerpublic class ReturnValueController &#123; @GetMapping(\"/returnValue\") public String returnValue(@RequestParam(\"name\") String name) &#123; return name; &#125;&#125; 编写追踪代码脚本 BtracePrintConstructorArgSimple.java 12345678910111213@BTracepublic class BtracePrintReturnValueSimple &#123; @OnMethod( clazz = \"com.gulj.monitor.controller.ReturnValueController\", method = \"returnValue\", location = @Location(Kind.RETURN) ) public static void anyRead(@ProbeClassName String pcn, @ProbeMethodName String pmn, @Return AnyType result) &#123; BTraceUtils.println(\"className=\" + pcn + \",\" + \"methodName=\" + pmn + \",\" + \"result=\" + result); &#125;&#125; 使用 @Location(Kind.RETURN) 指定监控返回值的地方，使用 @Return AnyType result 存放监控的返回值 拦截异常拦截线上代码指定方法即使吞并异常，仍能异常栈信息被监控输出 编写待追踪代码 OnThrowController.java 12345678910111213141516171819@RestControllerpublic class OnThrowController &#123; @GetMapping(\"/exception\") public String exception() &#123; try &#123; //TODO 业务代码 int i = 1 / 0; //TODO 业务代码 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"success\"; &#125;&#125; 编写追踪代码脚本 BtracePrintOnThrowSimple.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@BTracepublic class BtracePrintOnThrowSimple &#123; /** * 代码从 usersguide.html 中 copy btrace/samples/OnThrow.java */ // store current exception in a thread local // variable (@TLS annotation). Note that we can't // store it in a global variable! @TLS static Throwable currentException; // introduce probe into every constructor of java.lang.Throwable // class and store \"this\" in the thread local variable. @OnMethod( clazz = \"java.lang.Throwable\", method = \"&lt;init&gt;\" ) public static void onthrow(@Self Throwable self) &#123; currentException = self; &#125; @OnMethod( clazz = \"java.lang.Throwable\", method = \"&lt;init&gt;\" ) public static void onthrow1(@Self Throwable self, String s) &#123; currentException = self; &#125; @OnMethod( clazz = \"java.lang.Throwable\", method = \"&lt;init&gt;\" ) public static void onthrow1(@Self Throwable self, String s, Throwable cause) &#123; currentException = self; &#125; @OnMethod( clazz = \"java.lang.Throwable\", method = \"&lt;init&gt;\" ) public static void onthrow2(@Self Throwable self, Throwable cause) &#123; currentException = self; &#125; // when any constructor of java.lang.Throwable returns // print the currentException's stack trace. @OnMethod( clazz = \"java.lang.Throwable\", method = \"&lt;init&gt;\", location = @Location(Kind.RETURN) ) public static void onthrowreturn() &#123; if (currentException != null) &#123; BTraceUtils.Threads.jstack(currentException); println(\"=====================\"); currentException = null; &#125; &#125;&#125; 监控结果 虽然我们在程序中把异常吞闭了，但是通过btrace的异常监控脚本我们仍能输出异常栈信息，这无疑很好地帮助我们解决线上问题（btrace的异常监控脚本参考 usersguide.html 中的 btrace/samples/OnThrow.java文件） 拦截行号拦截线上代码指定行是否被执行到","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"btrace","slug":"btrace","permalink":"http://www.gulj.cn/tags/btrace/"}]},{"title":"Java 线上问题排查神器 BTrace 入门","slug":"Java-线上问题排查神器-BTrace-入门","date":"2018-07-30T03:27:13.000Z","updated":"2019-02-14T07:07:12.861Z","comments":true,"path":"2018/07/30/Java-线上问题排查神器-BTrace-入门/","link":"","permalink":"http://www.gulj.cn/2018/07/30/Java-线上问题排查神器-BTrace-入门/","excerpt":"介绍BTrace是Java平台的安全，动态跟踪工具。 BTrace可用于动态跟踪正在运行的Java程序（类似于OpenSolaris应用程序和操作系统的DTrace）。 BTrace动态检测目标应用程序的类以注入跟踪代码（“字节码跟踪”） BTrace是检查和解决线上的问题的利器，BTrace 可以通过编写脚本的方式，在服务不用重启的情况下，获取程序执行过程中相关信息。","text":"介绍BTrace是Java平台的安全，动态跟踪工具。 BTrace可用于动态跟踪正在运行的Java程序（类似于OpenSolaris应用程序和操作系统的DTrace）。 BTrace动态检测目标应用程序的类以注入跟踪代码（“字节码跟踪”） BTrace是检查和解决线上的问题的利器，BTrace 可以通过编写脚本的方式，在服务不用重启的情况下，获取程序执行过程中相关信息。 安装下载地址：Btrace-1.3.11 下载完成，进行解压，自行放入读者自己的安装目录 12# 解压$ tar -zxvf btrace-bin-1.3.11.tgz.tar.gz 配置环境变量 MaxOs用户 编辑 ~/.bash_profile 文件添加 123# btrace(BTRACE_HOME的路径记得替换成自己的btrace的目录)export BTRACE_HOME=/Users/gulj/Applications/developsoftware/btrace export PATH=$PATH:$BTRACE_HOME/bin 让.bash_profile生效 1$ source ~./bash_profile Window用户 编辑：右键—&gt;我的电脑—&gt;我的电脑—&gt;属性—&gt;高级系统设置—&gt;环境变量—&gt;系统变量 在系统变量中新建环境变量 BTRACE_HOME 1BTRACE_HOME=/Users/gulj/Applications/developsoftware/btrace 在系统变量中找到path，在后面添加 1%BTRACE_HOME%\\bin 验证安装是否正确 123$ btrace --versionBTrace v.1.3.11 (20180406) Btrace运行脚本方式 在JVisual中添加Btrace插件，添加classpath 使用命令行 btrace [-I include-path] [-p port] [-cp classpath] pid btrace-script [args] Btrace 注解在我们解压后的/Users/gulj/Applications/developsoftware/btrace/docs目录下，有个usersguide.html文件，里面详细介绍了各种注解的作用以及使用方法 Method Annotations @com.sun.btrace.annotations.OnMethod @com.sun.btrace.annotations.OnTimer @com.sun.btrace.annotations.OnError @com.sun.btrace.annotations.OnExit @com.sun.btrace.annotations.OnEvent @com.sun.btrace.annotations.OnLowMemory @com.sun.btrace.annotations.OnProbe Argument Annotations @com.sun.btrace.annotations.Self @com.sun.btrace.annotations.Return @com.sun.btrace.annotations.CalledInstance @com.sun.btrace.annotations.CalledMethod Field Annotations @com.sun.btrace.annotations.Export @com.sun.btrace.annotations.Property @com.sun.btrace.annotations.TLS Class Annotations @com.sun.btrace.annotations.DTrace @com.sun.btrace.annotations.DTraceRef @com.sun.btrace.annotations.BTrace 使用示例新建一个springboot的web工程引入btrace的maven相关依赖12345678910111213141516171819202122232425262728&lt;!-- btrace start --&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.btrace&lt;/groupId&gt; &lt;artifactId&gt;btrace-boot&lt;/artifactId&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;version&gt;1.3.11&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;systemPath&gt;/Users/gulj/Applications/developsoftware/btrace/build/btrace-boot.jar&lt;/systemPath&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.btrace&lt;/groupId&gt; &lt;artifactId&gt;btrace-client&lt;/artifactId&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;version&gt;1.3.11&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;systemPath&gt;/Users/gulj/Applications/developsoftware/btrace/build/btrace-client.jar&lt;/systemPath&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.btrace&lt;/groupId&gt; &lt;artifactId&gt;btrace-agent&lt;/artifactId&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;version&gt;1.3.11&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;systemPath&gt;/Users/gulj/Applications/developsoftware/btrace/build/btrace-agent.jar&lt;/systemPath&gt;&lt;/dependency&gt;&lt;!-- btrace end --&gt; 编写要追踪调试的代码1234567@RestControllerpublic class UserController &#123; @GetMapping(\"/hello\") public String helloBtrace(@RequestParam(\"name\") String name) &#123; return \"hello，\" + name; &#125;&#125; 编写追踪代码123456789101112@BTracepublic class BtracePrintArgSimple &#123; @OnMethod( clazz = \"com.gulj.monitor.controller.UserController\", method = \"helloBtrace\", location = @Location(Kind.ENTRY) ) public static void andyRead(@ProbeClassName String pcn, @ProbeMethodName String pmn, AnyType[] args) &#123; BTraceUtils.printArray(args); BTraceUtils.println(\"className=\" + pcn + \",\" + \"methodName\" + pmn); &#125;&#125; 运行先把我们的springboot工程启动，通过 jps -l 取得工程的pid ，然后在执行 12# 49165 就是笔者工程的pidbtrace 49165 BtracePrintArgSimple.java 这样我们的追踪代码就处于一直监控状态，此时，我们通过curl、postman等方式，请求我们写好的接口 1curl http://localhost:8080/hello?name=\"btrace\" 那么我们的btrace监控就会输出我们监控的结果 追踪的代码（BtracePrintArgSimple）可以单独存放，新建一个工程，不必和我们的业务工程放在一起","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"btrace","slug":"btrace","permalink":"http://www.gulj.cn/tags/btrace/"}]},{"title":"Spring集成ActiveMQ","slug":"Spring集成ActiveMQ","date":"2018-06-20T10:29:51.000Z","updated":"2019-02-14T07:07:12.863Z","comments":true,"path":"2018/06/20/Spring集成ActiveMQ/","link":"","permalink":"http://www.gulj.cn/2018/06/20/Spring集成ActiveMQ/","excerpt":"核心类介绍 ConnectionFactory 用于管理连接的连接工厂 一个Spring为我们提供的连接池 Spring 中提供了 SingleConnectionFactory 和 CachingConnectionFactory JmsTemplate 用于发送和接收消息的模板类 MessageListener 消息监听器","text":"核心类介绍 ConnectionFactory 用于管理连接的连接工厂 一个Spring为我们提供的连接池 Spring 中提供了 SingleConnectionFactory 和 CachingConnectionFactory JmsTemplate 用于发送和接收消息的模板类 MessageListener 消息监听器 在pom.xml中添加ActiveMQ依赖12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;properties&gt; &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-core&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 队列模式演示生产者发送消息生产者发送消息接口 ProducerService.java 12345678910public interface ProducerService &#123; /** * 发送消息 * * @param message */ void sendMessage(String message);&#125; 生产者发送消息接口实现类 ProducerServiceImpl.java 1234567891011121314151617181920public class ProducerServiceImpl implements ProducerService &#123; @Autowired private JmsTemplate jmsTemplate; @Resource(name = \"queueDestination\") private Destination destination; public void sendMessage(final String message) &#123; // 使用jmsTemplate发送消息 jmsTemplate.send(destination, new MessageCreator() &#123; // 创建一个消息 public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage(message); return textMessage; &#125; &#125;); System.out.println(\"发送消息：\" + message); &#125;&#125; 生产者公共配置文件 common.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 启用注解 --&gt; &lt;context:annotation-config/&gt; &lt;!-- active mq 为我们提供的 ConnectionFactory --&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://localhost:61616\"/&gt; &lt;/bean&gt; &lt;!-- spring jms 为我们提供的连接池--&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- 一个队列目的地，点对点的--&gt; &lt;bean id=\"queueDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"queue-spring\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; 生产者配置文件 producer.xml 导入公共 common.xml 文件 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 引入公共配置--&gt; &lt;import resource=\"common.xml\"/&gt; &lt;!-- 配置JmsTemplate，用于发送消息--&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- 配置自己定义的bean--&gt; &lt;bean class=\"com.gulj.spring.jms.producer.ProducerServiceImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 生产者启动类 AppProducer.java 运行main方法，启动生产者发送消息 12345678910public class AppProducer &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"producer.xml\"); ProducerService producerService = context.getBean(ProducerService.class); for (int i = 0; i &lt; 80; i++) &#123; producerService.sendMessage(\"test spring jms\" + i); &#125; context.close(); &#125;&#125; 生产者发送消息运行效果图 消费者消费消息消费者监听消息进行消费 ConsumerMessageListener.java123456789101112public class ConsumerMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"接收到的消息：\" + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 消费者配置文件 consumer.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 引入公共配置 --&gt; &lt;import resource=\"common.xml\"/&gt; &lt;!-- 配置自定义的消息监听器--&gt; &lt;bean id=\"consumerMessageListener\" class=\"com.gulj.spring.jms.consumer.ConsumerMessageListener\"&gt;&lt;/bean&gt; &lt;!-- 配置消息监听容器 --&gt; &lt;bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;!-- 连接工厂 --&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;!-- 队列名称 --&gt; &lt;property name=\"destination\" ref=\"queueDestination\"/&gt; &lt;!--消息监听器--&gt; &lt;property name=\"messageListener\" ref=\"consumerMessageListener\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 消费者启动类 AppConsumer.java 直接运行main方法，监听消息进行消费 123456public class AppConsumer &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"consumer.xml\"); &#125;&#125; 消费者消费消息运行效果图","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"activemq","slug":"activemq","permalink":"http://www.gulj.cn/tags/activemq/"}]},{"title":"ActiveMQ入门教程","slug":"ActiveMQ入门教程","date":"2018-06-12T07:10:18.000Z","updated":"2019-02-14T07:07:12.858Z","comments":true,"path":"2018/06/12/ActiveMQ入门教程/","link":"","permalink":"http://www.gulj.cn/2018/06/12/ActiveMQ入门教程/","excerpt":"介绍ActiveMQActiveMQ 是Apache出的，最流行的，功能强大的即时通讯和集成模式的开源服务器。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。提供客户端支持跨语言和协议，带有易于在充分支持JMS 1.1和1.4使用J2EE企业集成模式和许多先进的功能。 什么是JMS？Java消息服务(Java Message Service) 即JMS，是一个java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 什么是AMQP？AMQP(advanced message queuing protocol) 是一个提供统一消息服务的应用层标准层协议，基于此协议的客户端与消息中间件可传递性，并不受客户端/中间件不同产品，不同开发语言等条件的限制。","text":"介绍ActiveMQActiveMQ 是Apache出的，最流行的，功能强大的即时通讯和集成模式的开源服务器。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。提供客户端支持跨语言和协议，带有易于在充分支持JMS 1.1和1.4使用J2EE企业集成模式和许多先进的功能。 什么是JMS？Java消息服务(Java Message Service) 即JMS，是一个java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 什么是AMQP？AMQP(advanced message queuing protocol) 是一个提供统一消息服务的应用层标准层协议，基于此协议的客户端与消息中间件可传递性，并不受客户端/中间件不同产品，不同开发语言等条件的限制。 JMS 和 AMQP 对比 ActiveMQ、RabbitMQ 和 Kafka 简单对比 JMS规范JMS相关概念 消费者/订阅者 ： 接收并处理消息的客户端 消息 ： 应用程序之间传递的数据内容 消息模式 ： 在客户端之间传递消息的方式，JMS中定义了主题和队列两种模式 JMS消息模式—队列模型 客户端包括生产者和消费者 队列中的消息只能被一个消费者消费 消费者可以随时消费队列中的消息 队列模型示意图 JMS消息模式—主题模型 客户端包括生产者和消费者 主题中的消息被所有消费者消费 消费者必须先订阅，才能消费发送到主题中的消息 主题模型示意图 JMS编码接口 ConnectionFactory 用于创建连接到消息中间件的连接工厂 Connection 代表了应用程序和消息服务器之间的通信链路 Destination 指消息发布和接收的地点，包括队列或主题 Session 表示一个单线程的上下文，用于发送和接收消息 MessageConsumer 由会话创建，用于接收发送到目标的消息 MessageProducer 由会话创建，用于发送消息到目标 Message 是在消费者和生产者之间传送的对象，消息头，一组消息属性，一个消息体 JMS编码接口之间的关系 安装 查询Docker镜像 1$ docker search activemq 下载Docker镜像 1$ docker pull webcenter/activemq 创建&amp;运行ActiveMQ容器 1$ docker run -d --name myactivemq -p 61616:61616 -p 8161:8161 webcenter/activemq 查看WEB管理页面 浏览器输入http://127.0.0.1:8161/ 点击Manage ActiveMQ broker使用默认账号/密码：admin/admin进入查看 队列模式消息和主题模式消息代码演示队列模式消息演示 生产者 AppProducer.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class AppProducer &#123; // MQ服务器地址 private static final String BROKER_URL = \"tcp://127.0.0.1:61616\"; // 队列名称 private static final String QUEUE_NAME = \"queue-test\"; public static void main(String[] args) throws JMSException &#123; // 1.创建连接工厂 ConnectionFactory factory = new ActiveMQConnectionFactory(BROKER_URL); // 2.创建连接 Connection connection = factory.createConnection(); // 3.启动连接 connection.start(); // 4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5.创建一个目标 Destination destination = session.createQueue(QUEUE_NAME); // 6.创建一个生产者 MessageProducer producer = session.createProducer(destination); // 循环发送消息 for (int i = 0; i &lt; 100; i++) &#123; // 创建消息 TextMessage textMessage = session.createTextMessage(\"【test-activemq-producer】\" + i); // 发布消息 producer.send(textMessage); System.out.println(\"消息发送成功：\" + textMessage); &#125; // 关闭连接 connection.close(); &#125;&#125; 消费者 AppConsumer.java (由于消费者的创建流程和生产者非常类似，特意用 ActiveMqHelper 类进行简单封装一下) 1234567891011121314151617181920212223242526272829303132public class AppConsumer &#123; public static void main(String[] args) throws JMSException &#123; // 创建连接 Connection connection = ActiveMqHelper.createConnection(); // 创建会话 Session session = ActiveMqHelper.createSession(connection); // 创建一个目标 Destination destination = ActiveMqHelper.createQueue(session); // 创建一个消费者 MessageConsumer consumer = session.createConsumer(destination); // 消费者监听要消费的信息 consumer.setMessageListener(message -&gt; &#123; // 接收到的消息内容c TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"【消费者接收到的消息】\" + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;); // 关闭连接,因为监听是异步操作， // 如果事先关闭连接，监听操作还未处理完成，则会收不到消息， // 正常处理逻辑是在监听事件处理完成后，再释放连接 // connection.close(); &#125;&#125; MQ帮助类 ActiveMqHelper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class ActiveMqHelper &#123; // MQ服务器地址 private static final String BROKER_URL = \"tcp://127.0.0.1:61616\"; // 队列名称 private static final String QUEUE_NAME = \"queue-test\"; // 主题名称 private static final String TOPIC_NAME = \"topic-test\"; /** * 创建连接 * * @return * @throws JMSException */ public static Connection createConnection() throws JMSException &#123; // 1.创建连接工厂 ConnectionFactory factory = new ActiveMQConnectionFactory(BROKER_URL); // 2.创建连接 Connection connection = factory.createConnection(); // 3.启动连接 connection.start(); return connection; &#125; /** * 创建会话 * * @param connection * @return * @throws JMSException */ public static Session createSession(Connection connection) throws JMSException &#123; // 4.创建会话 return connection.createSession(false, Session.AUTO_ACKNOWLEDGE); &#125; /** * 创建队列目标 * * @param session * @return * @throws JMSException */ public static Destination createQueue(Session session) throws JMSException &#123; // 5.创建一个队列目标 return session.createQueue(QUEUE_NAME); &#125; /** * 创建主题目标 * * @param session * @return * @throws JMSException */ public static Destination createTopic(Session session) throws JMSException &#123; // 5.创建一个主题目标 return session.createTopic(TOPIC_NAME); &#125;&#125; 代码效果图展示 主题模式消息演示生产者 AppProducer.java (主题模式的代码示例和队列模式的代码示例基本相同，只有在创建主题目标的时候不同，还请老铁自行实现) 消费者同理参考队列模式代码实现 12345678910public class AppProducer &#123; public static void main(String[] args) throws JMSException &#123; // .... // 3.创建主题目标 (与队列模式唯一区别的代码，其它都一样) Destination destination = session.createTopic(TOPIC_NAME); // .... &#125;&#125; 主题模式注意点：1、先启动AppConsumer.java类（消费者先进行订阅），在启动 AppProvider.java 类（生产者进行生产）这样消费者才能监听到生产者生成的消息进行消费；队列模式没有此要求2、生产者生产100条消息，若有多个消费者，每个消费者均消费100条消息；而队列模式，则是每个消费者合计起来消费这 100 条消息 代码效果图展示","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"activemq","slug":"activemq","permalink":"http://www.gulj.cn/tags/activemq/"}]},{"title":"Mac OSX平台使用jenv管理多个Java版本","slug":"OSX平台使用jenv管理多个Java版本","date":"2018-06-08T08:45:28.000Z","updated":"2019-02-14T07:07:12.862Z","comments":true,"path":"2018/06/08/OSX平台使用jenv管理多个Java版本/","link":"","permalink":"http://www.gulj.cn/2018/06/08/OSX平台使用jenv管理多个Java版本/","excerpt":"JDK安装 JDK下载 jdk7下载链接 jdk8下载链接 下载自己需要的扩展名为dmg的Jdk版本，按照提示直接一步步安装即可 配置JDK环境变量 打开 vim ~/.bash_profile 文件 进行添加 1234export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Homeexport JAVA_7_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home# 默认激活 jdk8export JAVA_HOME=$JAVA_8_HOME","text":"JDK安装 JDK下载 jdk7下载链接 jdk8下载链接 下载自己需要的扩展名为dmg的Jdk版本，按照提示直接一步步安装即可 配置JDK环境变量 打开 vim ~/.bash_profile 文件 进行添加 1234export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Homeexport JAVA_7_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home# 默认激活 jdk8export JAVA_HOME=$JAVA_8_HOME 编辑完成，重新加载 .bash_profile 1$ source ~/.bash_profile jEnv安装 安装 1$ brew install jenv 配置 安装了zsh，配置如下12$ echo 'export PATH=\"$HOME/.jenv/bin:$PATH\"' &gt;&gt; ~/.zshrc$ echo 'eval \"$(jenv init -)\"' &gt;&gt; ~/.zshrc 如果是默认的bash 12$ echo 'export PATH=\"$HOME/.jenv/bin:$PATH\"' &gt;&gt; ~/.bash_profile$ echo 'eval \"$(jenv init -)\"' &gt;&gt; ~/.bash_profilec jEnv配置JDK查看安装的java版本，如果我们一开始未添加jdk，执行jenv versions 应该是空的，* 号位置表示当前的jdk版本 12345678$ jenv versions system 1.7* 1.7.0.80 (set by /Users/gulj/.java-version) 1.8 1.8.0.112 oracle64-1.7.0.80 oracle64-1.8.0.112 重启下terminal，为jEnv添加java版本 添加jdk7 1$ jenv add /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home 添加jdk8 1$ jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home 添加完jdk7和jdk8之后，再执行 jenv versions 命令就会看到我们添加的jdk jEnv常用命令 移除指定版本jdk 1$ jenv remove 1.8.0.111 选择一个jdk版本 1$ jenv local 1.8.0.111 设置默认的jdk版本 1$ jenv global 1.8.0.111 查看当前版本jdk的路径 1jenv which java","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.gulj.cn/tags/mac/"}]},{"title":"Mac OSX平台开发工具和常用软件推荐","slug":"OSX平台开发工具和常用软件推荐","date":"2018-06-07T01:30:46.000Z","updated":"2019-02-14T07:07:12.863Z","comments":true,"path":"2018/06/07/OSX平台开发工具和常用软件推荐/","link":"","permalink":"http://www.gulj.cn/2018/06/07/OSX平台开发工具和常用软件推荐/","excerpt":"开发工具 Beyond Compare 4 Beyond Compare 是一款强大专业的文件和文件夹对比工具。使用它可以很方便地比较出两个文件或文件夹的差异，相差的每一个字节用颜色加以标识，让您查看方便，支持众多种格式的对比。只需使用简单操作方式方可开启快捷省事的文件对比体验，找出您所需差异、合并变化，然后同步文件，并生成报告一气呵成。 因版本问题，不再提供下载，还请大家支持正版！","text":"开发工具 Beyond Compare 4 Beyond Compare 是一款强大专业的文件和文件夹对比工具。使用它可以很方便地比较出两个文件或文件夹的差异，相差的每一个字节用颜色加以标识，让您查看方便，支持众多种格式的对比。只需使用简单操作方式方可开启快捷省事的文件对比体验，找出您所需差异、合并变化，然后同步文件，并生成报告一气呵成。 因版本问题，不再提供下载，还请大家支持正版！ IntelliJ IDEA IntelliJ IDEA 主要用于支持 Java、Scala、Groovy 等语言的开发工具，同时具备支持目前主流的技术和框架，擅长于企业应用、移动应用和 Web 应用的开发 IntelliJ IDEA 下载 Navicat Premium 12 Navicat Premium是一套数据库管理工具，结合了其它Navicat成员的功能，支持单一程序同時连接到MySQL、MariaDB、SQL Server、SQLite、Oracle和PostgreSQL数据库。Navicat Premium可满足现今数据库管理系统的使用功能，包括存储过程、事件、触发器、函数、视图等。 Navicat Premium 12.0.26 Mac中文破解版下载 密码: x643 SwitchHosts 用于快速切换 hosts 文件的小程序，基于 Electron 开发，同时使用了 React、Ant Design 以及 CodeMirror 等框架/库。 SwitchHosts下载 Charles Charles是一款用于HTTP信息抓包工具，可以快速有效的获得HTTP信息，非常利于开发者的网页开发和调试修改等！Charles 有着可视化的操作界面，非常利用编辑者的使用和调试！ Charles 4.2.5 Mac破解版下载 密码: mpdd iTerm2 iTerm2是Mac下最好的终端工具 iTerm2下载 typora 一款无可挑剔的 Markdown 编辑器 typora下载 Redis Desktop Manager 一款基于Qt5的跨平台Redis桌面管理软件 Redis Desktop Manager下载 VirtualBox VirtualBox号称是最强的免费虚拟机软件，它不仅具有丰富的特色，而且性能也很优异！ VirtualBox 下载 Postman Postman是google开发的一款功能强大的网页调试与发送网页HTTP请求，并能运行测试用例的的Chrome插件 Postman 下载 Visual Studio Code Visual Studio Code（简称VS Code）是一个由微软开发的，同时支持Windows、Linux和macOS操作系统且开放源代码的文本编辑器。[4]它支持调试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段、代码重构等。该编辑器支持用户自定义配置，例如改变主题颜色、键盘快捷方式、编辑器属性和其他参数，还支持扩展程序并在编辑器中内置了扩展程序管理的功能 Visual Studio Code 下载 Go2Shell Go2Shell 可以在 Finder 中打开当前目录的终端窗口，是一个对开发者来说非常有用的App Go2Shell 下载 Axure RP Axure RP是美国Axure Software Solution公司旗舰产品，是一个专业的快速原型设计工具，让负责定义需求和规格、设计功能和界面的专家能够快速创建应用软件或Web网站的线框图、流程图、原型和规格说明文档。作为专业的原型设计工具，它能快速、高效的创建原型，同时支持多人协作设计和版本控制管理。 Axure RP 8.1.0.3372 Mac破解版下载 密码: ast9 常用软件 PDF Expert 快速、轻巧、易用的PDF编辑器，轻松在MAC上完成PDF编辑、阅读、批注、编辑文本、添加照片、填写表单、签署合同、合并PDF文档以及加密保护，只需轻轻点击几下即可，前所未有的体验 因版本问题，不再提供下载，还请大家支持正版！ Alfred 3 Alfred可以帮助你快速、方便的打开任意应用程序，配合快捷键你可以大大提高工作效率。 Alfred 3.6.1 Mac破解版下载 密码: kq9t BetterZip BetterZip是一款功能强大的压缩软件，不必解压就能快速地检查压缩文档。它能执行文件之间的合并并提供密码。使用它，用户可以更快捷的向压缩文件中添加和删除文件。 它支持包括zip、gz、bz、bz2、tar、tgz、tbz、rar、7-zip、cpio、 arj、lha、lhz、cab、iso、chm、rpm、deb、nsis、sit、dd、hqx和bin等多种格式的文件。 BetterZip 4.1.3 Mac中文破解版下载 密码: kndb Snagit Snagit可以使用此工具轻松抓取图像、文本和影音等多种内容形式，内置强大编辑器，捕捉、编辑一步到位。 Snagit 4.1.9 Mac破解版下载 密码: dga7 Office Office 2016是一款集成自动化办公软件，Office 2016由各种功能组件构成，包括Word 2016、Excel 2016、PowerPoint 2016、Access 2016、Outlook 2016和Publisher 2016等 Office 2016 16.13.1 Mac中文破解版下载 密码: 2qwt Office 2016 破解补丁下载 密码: 8y59","categories":[{"name":"工具","slug":"工具","permalink":"http://www.gulj.cn/categories/工具/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.gulj.cn/tags/mac/"}]},{"title":"IntelliJ IDEA 使用技巧","slug":"idea-使用技巧","date":"2018-05-23T09:37:25.000Z","updated":"2019-02-14T07:07:12.865Z","comments":true,"path":"2018/05/23/idea-使用技巧/","link":"","permalink":"http://www.gulj.cn/2018/05/23/idea-使用技巧/","excerpt":"无处不在的跳转 项目之间的跳转 下一个工程窗口 （Window -&gt; Next Project Window）alt + command + ] 上一个工程窗口 （Window -&gt; Previous Project Window）alt + command + [","text":"无处不在的跳转 项目之间的跳转 下一个工程窗口 （Window -&gt; Next Project Window）alt + command + ] 上一个工程窗口 （Window -&gt; Previous Project Window）alt + command + [ 文件之间的跳转 查看当前打开的文件command + e 只查看当前打开并且修改的文件shift + command + e 浏览修改位置跳转 最后一次修改的位置 （Navigate -&gt; Last Edit Location）shift + command + delete 浏览位置跳转 后一个浏览的位置 （Navigate -&gt; Back）alt + command + &lt;— 前一个浏览的位置 （Navigate -&gt; Forward）alt + command + —&gt; 收藏类或某一个方法使用 command + 2 调出 favorite 窗口使用快捷键 alt + shirt + f 可以将类添加到自定的favorite中，添加方法：首先要选中方法名，然后再按住快捷键( shift + command + f )进行添加 字符跳转插件emacsIdea置跳转 作用： 快速跳转到以某一个字符开头的位置 安装插件 eamcsIdea 的方法可以查看我上一篇博文 Intellij Idea 必备插件 插件安装完成，在keymap中找到 AceJumpWord 右键选择 Add Keyboard ShorCut 添加 crtl + k 快捷键 效果演示需求：跳转到以 a 字母开头 address 位置；（在效果图T1类中有三个地方是以字母a开头，“成员变量 address，成员变量 age，局部变量 a ”）；操作：首先我们先按 ctrl + k（就是我们之前定义插件eamcsIdea的快捷键） 然后按字母 a（想以什么字母开头就按什么字母，这里只演示以a字母开头） 这样在T1类中就会以字母标识选中所有以a开头的字符，我们要跳转到哪里就按选中标识的字符即可 ，现在我们要跳转到 address 位置，选中的字符是 d 在键盘上按字符 d 即可 精准搜索 类command + n 文件shift + command + n 方法或属性alt + shift + command + n 字符串ctrl + shift + f 代码小助手 列操作 选中一个冒号（ ：）字符，按 ctrl + command + g 则会选中所有冒号，按键盘左右方向键进行光标左右方向移动, 按 command + w 可选中一定区域的字符 Live Template 作用：定义诸多代码模板，利用快捷键快速生成自定义代码模板 演示： 笔者常用自定义的代码模板如下： 12345678910111213141516171819202122232425// int 常量public static final int $VAR1$ = $VAR2$;// String 常量 public static final int $VAR1$ = $VAR2$;// 带有注释的 private int 快捷键 （pic）************************************/** * $VAR1$ */private int $VAR2$;$END$************************************// 带有注释的 private String 快捷键 （psc）************************************/** * $VAR1$ */private String $VAR2$;$END$************************************ Postfix 介绍 for，nn，sout，return 的用法 神奇的 alter + enter 使用 alter + enter 快捷键能够帮助我们：实现接口、导包、创建函数、纠正单词拼写、生成函数返回变量、字符串format等等 演示： 编写高质量的代码 重构（重构变量，重构方法） 光标放到变量位置 按 shift + f6 会出现红框选中变量，进行变量重构；为方法添加参数，使用 alter + enter 提示进行方法重构 演示： 抽取 抽取变量alt + command + v 抽取静态变量alt + command + c 抽取成员变量alt + command + f 抽取方法参数alt + command + p 抽取方法alt + command + m","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://www.gulj.cn/tags/idea/"}]},{"title":"IntelliJ IDEA 必备插件","slug":"intellij-idea-必备插件","date":"2018-05-22T08:49:44.000Z","updated":"2019-02-14T07:07:12.866Z","comments":true,"path":"2018/05/22/intellij-idea-必备插件/","link":"","permalink":"http://www.gulj.cn/2018/05/22/intellij-idea-必备插件/","excerpt":"插件安装方式 下载插件到本地，从本地安装打开 idea -&gt; settings -&gt; plugins -&gt; Install plugin from disk -&gt; 选中本地下载好的插件jar包 -&gt; 重启","text":"插件安装方式 下载插件到本地，从本地安装打开 idea -&gt; settings -&gt; plugins -&gt; Install plugin from disk -&gt; 选中本地下载好的插件jar包 -&gt; 重启 直接在线安装打开 idea -&gt; settings -&gt; plugins -&gt; 输入插件名称 -&gt; 安装 -&gt; 重启idea 插件列表 lombok地址：https://plugins.jetbrains.com/plugin/6317-lombok-plugin 作用： ​ 免去IDE去生成其属性的构造器、getter、setter、equals、hashcode、toString等方法 截图： .ignore地址：https://plugins.jetbrains.com/plugin/7495--ignore 作用： ​ 生成各种ignore文件，一键创建git ignore文件模板，通过编辑器直接将文件加入到ignore文件中，免去手动添加操作 截图： FindBugs-IDEA地址：https://plugins.jetbrains.com/plugin/3847-findbugs-idea 作用： ​ 检测代码中可能隐藏的bug以及不规范位置 截图： GsonFormat地址：https://plugins.jetbrains.com/plugin/7654-gsonformat 作用： ​ 根据json文本，生成对应的java类 截图： VisualVM Launcher地址：https://plugins.jetbrains.com/plugin/7115-visualvm-launcher 作用： 查看java程序jvm的使用情况，例如内存分析，cpu分析，对象占用内存大小，方便jvm调优 截图： 使用 VisualVM Launcher 不像其它插件一样，直接安装插件就可以使用，它要配合 VisualVM 客户端一起使用 首次用 Intellij IDEA 执行VisualVM的时候，需要配置 VisualVM executable 笔者的路径是： /Applications/VisualVM.app/Contents/Resources/visualvm/bin/visualvm GenerateAllSetter地址：https://plugins.jetbrains.com/plugin/9360-generateallsetter 作用： ​ 一键生成对象的所有set方法 截图： Free Mybatis Plugin地址：https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin 作用： 根据定义mapper接口方法，生成对应的mapper.xml文件中的方法，快速在mapper.java文件和mapper.xml文件之间来回切换 截图： Background Image Plus地址：https://plugins.jetbrains.com/plugin/8502-background-image-plus 作用： ​ 为idea编辑器设置图片背景 截图：","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://www.gulj.cn/tags/idea/"}]},{"title":"Webpack 学习示例","slug":"webpack-教程","date":"2018-04-09T08:13:54.000Z","updated":"2019-02-14T07:07:13.521Z","comments":true,"path":"2018/04/09/webpack-教程/","link":"","permalink":"http://www.gulj.cn/2018/04/09/webpack-教程/","excerpt":"介绍Webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle 本章节主要介绍Webpack的核心概念的Demo使用示例，建议读者查看之前请阅读Webpack的官方文档也可以查看中文地址文档 Webpack版本： 3.9.0 代码GitHub地址： https://github.com/gulijian/webpack-learning-example","text":"介绍Webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle 本章节主要介绍Webpack的核心概念的Demo使用示例，建议读者查看之前请阅读Webpack的官方文档也可以查看中文地址文档 Webpack版本： 3.9.0 代码GitHub地址： https://github.com/gulijian/webpack-learning-example How to useInstall webpack 1$ npm i -g webpack Clone the repo. 1$ git clone https://github.com/gulijian/webpack-learning-example.git Install the dependencies 12# 进入每个章节根目录，执行 npm install $ npm install Open the each chapter index.html IndexStyle-loader Style-loader/url Css-loader And Css-Module Js Tree-shaking Url-loader ProvidePlugin Clean-webpack-plugin chapter4-1 (source)style-loader use 处理css，以 style 标签形式引入css app.js1import './css/app.css' app.css123html &#123; background: #00bcd4b5;&#125; index.html123456&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js12345678910111213141516171819202122232425262728var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader' &#125; ] &#125; ] &#125;&#125; chapter4-2 (source)style-loader/url use 处理css，以标签形式引入css app.js1import './css/app.css' app.css123456789html &#123; background: #00bcd4b5; &#125;#styleLoaderUrl &#123; font-size: 30px; color: white; text-align: center;&#125; index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;span id=\"styleLoaderUrl\"&gt; hello style-loader/url&lt;/span&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpak.config.js1234567891011121314151617181920212223242526272829var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#123; loader: 'style-loader/url' &#125;, &#123; loader: 'file-loader' &#125; ] &#125; ] &#125;&#125; chapter4-3 (source)css-loader and css-module use 处理css，支持 css-module 形式 app.js12345678import app1 from './css/app1.css'import app2 from './css/app2.css'var app = document.getElementById('app');// 使用样式app.innerHTML = '&lt;div class = \"'+app1.box+'\"&gt;&lt;/div&gt;' app1.css12345678.box &#123; composes: borderBox from './app2.css'; height: 200px; width: 200px; border-radius: 4px; background: #76d4e0ab; margin: 0 auto;&#125; app2.css123.borderBox &#123; border: 4px solid #e87ff5;&#125; index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js1234567891011121314151617181920212223242526272829303132var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; minimize: true, // 启用压缩 modules: true // 启用 css module &#125; &#125; ] &#125; ] &#125;&#125; chapter5-1 (source)UglifyJsPlugin use 使用 UglifyJsPlugin 插件； 不打包没有使用的 js util.js1234567891011export function a ()&#123; return 'this is a';&#125;export function b ()&#123; return 'this is b';&#125;export function c ()&#123; return 'this is c';&#125; app.js123import &#123; a &#125; from './common/util.js'console.log(a()) index.html123456&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js123456789101112131415161718var webpack = require('webpack')var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin() ]&#125; app.js 中只使用了 util.js 中的 a 函数 打包的时候只会打包 a 函数；因为 b 和 c 函数没有使用到，则不会被打包 chapter6-1 (source)url-loader use 图片文件处理 app.js12345var img1 = document.getElementById('img1')var img2 = document.getElementById('img2')img1.src = require('./assets/img1.jpg')img2.src = require('./assets/img2.png') index.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;!-- size &lt; 30kb --&gt; &lt;img id=\"img1\"/&gt; &lt;!-- size &gt; 30kb --&gt; &lt;img id=\"img2\"&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js1234567891011121314151617181920212223242526272829var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.(png|jpg|jpeg|gif)$/, use: [ &#123; loader:'url-loader', options: &#123; limit: 30000 &#125; &#125; ] &#125; ] &#125;&#125; 图片 小于 30kb 会变成base64编码，大于 30kb 会生成图片地址 12&lt;img id=\"img1\" src=\"6443347e97d394b23b05746b2fe41cd1.jpg\"&gt;&lt;img id=\"img2\" src=\"data:image/png;base64,iVBORw0KGgoAXBIWXMAAC4jAAAuIwF4pT92AAAKTWlD\"/&gt; chapter7-1 (source)ProvidePlugin use 处理第三方 JS 库，方式一：（ jquery 作为npm的一个module） app.js1$('#app').append('hello jquery') index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js12345678910111213141516171819var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery' &#125;) ]&#125; chapter7-2 (source) 处理第三方 JS 库，方式二：（引入本地的 jquery 库） app.js1$('#app').append('hello jquery') index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js1234567891011121314151617181920212223242526var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, // 注意 jquery$ 的名字 要和 ProvidePlugin 插件中配置的名称（jquery）保持一致 resolve: &#123; alias: &#123; jquery$: path.resolve(__dirname,'src/libs/jquery.min.js') &#125; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery' &#125;) ]&#125; 如果 jquery 在CDN上，直接引入即可 chapter8-1 (source)clean-webpack-plugin use 每次打包清除原先的打包目录 app.js123var app = document.getElementById('app')app.innerHTML = '&lt;h1&gt;使用 clean-webpack-plugin 插件，可以每次打包清除原先的打包目录&lt;/h1&gt;' index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;span id=\"app\"&gt;&lt;/span&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js12345678910111213141516171819var path = require('path')var CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, plugins: [ new CleanWebpackPlugin([ 'dist' ]) ]&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://www.gulj.cn/tags/webpack/"}]},{"title":"【Docker教程】Docker Linux网络命名空间","slug":"docker-linux命名空间","date":"2018-03-31T02:44:25.000Z","updated":"2019-02-14T07:07:12.863Z","comments":true,"path":"2018/03/31/docker-linux命名空间/","link":"","permalink":"http://www.gulj.cn/2018/03/31/docker-linux命名空间/","excerpt":"前言到现在我们已经了解到Docker的镜像、容器等概念，我们可以在一台宿主机上运行一个或者多个容器，也可以将不同的容器运行在不同的宿主机上，那么这些容器是怎样进行互相通信呢？本文将介绍Linux网络命名空间概念，来帮助读者更好地了解到Docker容器之间的通信。 容器之间的通信(同一台宿主机上)默认情况下，在同一台宿主机上的多个容器是可以互相访问的，容器的网络命名空间和宿主机的网络命名空间是相互独立隔离的 查看宿主机的网络命名空间","text":"前言到现在我们已经了解到Docker的镜像、容器等概念，我们可以在一台宿主机上运行一个或者多个容器，也可以将不同的容器运行在不同的宿主机上，那么这些容器是怎样进行互相通信呢？本文将介绍Linux网络命名空间概念，来帮助读者更好地了解到Docker容器之间的通信。 容器之间的通信(同一台宿主机上)默认情况下，在同一台宿主机上的多个容器是可以互相访问的，容器的网络命名空间和宿主机的网络命名空间是相互独立隔离的 查看宿主机的网络命名空间 1234567891011121314151617181920212223$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 52:54:00:ad:3b:43 brd ff:ff:ff:ff:ff:ff inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic eth0 valid_lft 85639sec preferred_lft 85639sec inet6 fe80::5054:ff:fead:3b43/64 scope link valid_lft forever preferred_lft forever3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 08:00:27:7e:86:8c brd ff:ff:ff:ff:ff:ff inet 192.168.215.20/24 brd 192.168.215.255 scope global eth1 valid_lft forever preferred_lft forever inet6 fe80::a00:27ff:fe7e:868c/64 scope link valid_lft forever preferred_lft forever4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN link/ether 02:42:79:71:de:73 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 新建两个容器放入后台运行 123$ docker run -d --name demo1 busybox /bin/sh -c \"while true;do sleep 3600;done\"$ docker run -d --name demo2 busybox /bin/sh -c \"while true;do sleep 3600;done\" 查看两个容器的网络命名空间 12345678910111213141516171819$ docker exec demo1 ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever5: eth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever $ docker exec demo2 ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever7: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 这里可以看到宿主机、demo1和demo2的网络命名空间都是独立的，测试容器demo1和容器demo2是否可以互通 12345678910111213# 在 demo1 内 ping demo2容器的ip地址$ docker exec test1 ping 172.17.0.3PING 172.17.0.3 (172.17.0.3): 56 data bytes64 bytes from 172.17.0.3: seq=0 ttl=64 time=0.086 ms64 bytes from 172.17.0.3: seq=1 ttl=64 time=0.104 ms64 bytes from 172.17.0.3: seq=2 ttl=64 time=0.081 ms# 在 demo2 内 ping demo1容器的ip地址$ docker exec test2 ping 172.17.0.2PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.079 ms64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.102 ms64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.101 ms 从上面看出容器demo1和容器demok2可以互相访问 为了更好地了解到在同一宿主机上容器间的通信，下面我们从Linux网络命名空间来为大家解释 在这之前我们先把我们刚才运行的demo1和demo2两个容器停止掉 1$ sudo docker stop demo1 demo2 Linux 的网络命名空间(namespace)下面我们将在宿主机上创建两个网络命名空间分别为test1和test2，然后再创建一对Veth 接口，分别分配给test1和test2，这样test1和test2就能够连接起来，能够互相访问 创建网络命名空间123$ sudo ip netns add test1$ sudo ip netns add test2 查看网络命名空间123$ sudo ip netns listtest2test1 在docker容器中，我们可以查看容器的网络命名空间，同理我们也可以查看我们创建的网络命名空间详细信息 1234567$ sudo ip netns exec test1 ip a1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 $ sudo ip netns exec test2 ip a 1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 现在可以看到我们创建的两个命名空间test1和tes2只有本地的回环端口，也没有本地 ip 127.0.0.1 之类并且状态是DOWN的状态 查看本地的 ip link 123456789$ sudo ip link 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 52:54:00:ad:3b:43 brd ff:ff:ff:ff:ff:ff3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 08:00:27:7e:86:8c brd ff:ff:ff:ff:ff:ff4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT link/ether 02:42:79:71:de:73 brd ff:ff:ff:ff:ff:ff 现在本地只有四个 ip link 下面在宿主机上添加一对 link (vethl-test1 和 veth-test2) 1$ sudo ip link add veth-test1 type veth peer name veth-test2 接下来我们再次查看本地的 ip link 12345678910111213$ sudo ip link 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 52:54:00:ad:3b:43 brd ff:ff:ff:ff:ff:ff3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 08:00:27:7e:86:8c brd ff:ff:ff:ff:ff:ff4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT link/ether 02:42:79:71:de:73 brd ff:ff:ff:ff:ff:ff9: veth-test2@veth-test1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 9e:44:34:0b:41:39 brd ff:ff:ff:ff:ff:ff10: veth-test1@veth-test2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 5a:ed:e6:53:00:fb brd ff:ff:ff:ff:ff:ff 序号：9.（veth-test2@veth-test1），10.（veth-test1@veth-test2）就是我们刚添加的一对 link 将 veth-test1 这个接口添加到网络命名空间test1上 1$ sudo ip link set veth-test1 netns test1 这时候我们会发现本地的 ip link 序号：10 消失了，而我们创建的test1网络命名空间多了 veth-test1,我们来查看test1的 ip link 12345$ sudo ip netns exec test1 ip link 1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:0010: veth-test1@if9: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 5a:ed:e6:53:00:fb brd ff:ff:ff:ff:ff:ff link-netnsid 0 同理将 veth-test2 这个接口添加到网络命名空间test2上 1$ sudo ip link set veth-test2 netns test2 现在我们把创建的veth-test1和veth-test2分别添加到了网络命名空间test1和test2上(此时他们都没有ip地址，状态也是DOWN的状态) 123456789101112# test1$ sudo ip netns exec test1 ip link 1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:0010: veth-test1@if9: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 5a:ed:e6:53:00:fb brd ff:ff:ff:ff:ff:ff link-netnsid 0# test21: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:009: veth-test2@if10: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 9e:44:34:0b:41:39 brd ff:ff:ff:ff:ff:ff link-netnsid 0 分别为两个接口 veth-test1 和 veth-test2 分配ip地址,然后让其状态由DOWN变为UP (同时也可以把各自的回环端口 lo 状态也设置为 UP，不然到时候ping自己的时候ping不通) 1234567891011# 为veth-test1和veth-test2分配IP地址$ sudo ip netns exec test1 ip addr add 192.168.1.1/24 dev veth-test1$ sudo ip netns exec test2 ip addr add 192.168.1.2/24 dev veth-test2# 设置veth-test1和veth-test2的状态由DOWN变为UP$ sudo ip netns exec test1 ip link set dev veth-test1 up$ sudo ip netns exec test2 ip link set dev veth-test2 up# 设置test1和test2的本地回环端口状态由DOWN变为UP$ sudo ip netns exec test1 ip link set dev lo up$ sudo ip netns exec test2 ip link set dev lo up 现在我们可以看到我们创建的test1和test2这两个网络命名空间上的veth-test1和veth-test2接口分配的IP地址，并且状态为UP 123456789101112131415161718192021# test1$ sudo ip netns exec test1 ip a1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:0010: veth-test1@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP qlen 1000 link/ether 5a:ed:e6:53:00:fb brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet 192.168.1.1/24 scope global veth-test1 valid_lft forever preferred_lft forever inet6 fe80::58ed:e6ff:fe53:fb/64 scope link valid_lft forever preferred_lft forever # test2 $ sudo ip netns exec test2 ip a1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:009: veth-test2@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP qlen 1000 link/ether 9e:44:34:0b:41:39 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.1.2/24 scope global veth-test2 valid_lft forever preferred_lft forever inet6 fe80::9c44:34ff:fe0b:4139/64 scope link valid_lft forever preferred_lft forever 到此我们已经成功地完成了通过我们自己创建的test1和test2这两个网络命名空间，他们之间可以通过veth-test1和veth-test2互相访问 12345678910111213# test1 上 ping test2的ipsudo ip netns exec test1 ping 192.168.1.2PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.048 ms64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.059 ms64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.067 ms# test2 上 ping test1的ip$ sudo ip netns exec test2 ping 192.168.1.1PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=0.048 ms64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=0.052 ms64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=0.079 ms 在同一台宿主机上的docker多容器他们分别有各自的网络命名空间，他们之间的通信原理，和我们自己创建的test1和test2这两个网络命名空间他们之间的通信原理类似","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 数据持久化","slug":"docker-数据持久化","date":"2018-03-30T03:47:38.000Z","updated":"2019-02-14T07:07:12.864Z","comments":true,"path":"2018/03/30/docker-数据持久化/","link":"","permalink":"http://www.gulj.cn/2018/03/30/docker-数据持久化/","excerpt":"介绍Docker 容器一旦删除，那么我们在容器内的一切操作将不复存在，比如我们在容器内存储的数据等；为了解决这个问题，Docker 提出了数据卷概念，就像我们运行一个mysql容器，我们需要存储我们的数据，日志之类，想要他们不会随着容器的删除而销毁，或者我们需要在各个容器间共享数据，那么这些数据卷或者数据卷容器都能做到。 数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 数据卷的生命周期一直持续到没有容器使用它为止 数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷","text":"介绍Docker 容器一旦删除，那么我们在容器内的一切操作将不复存在，比如我们在容器内存储的数据等；为了解决这个问题，Docker 提出了数据卷概念，就像我们运行一个mysql容器，我们需要存储我们的数据，日志之类，想要他们不会随着容器的删除而销毁，或者我们需要在各个容器间共享数据，那么这些数据卷或者数据卷容器都能做到。 数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 数据卷的生命周期一直持续到没有容器使用它为止 数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷 Docker提供了两种方式管理数据 数据卷 数据卷容器 数据卷添加数据卷在 docker run 命令中 使用 -v 标识给容器内添加一个或者多个数据卷 在容器内创建一个新的数据卷 /data/shop 1$ docker run -d -P --name my-shop-web -v /data/shop sqgulj/shop-web 这种方式我们也可以在Dockerfile中使用VOLUME指令来给创建的容器添加一个或者多个数据卷，比如官方的 mysql 的 Dockerfile 中用 VOLUME 指定了数据卷 123456789101112131415161718192021.........RUN &#123; apt-get update &amp;&amp; apt-get install -y mysql-server=\"$&#123;MYSQL_VERSION&#125;\" &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm -rf /var/lib/mysql &amp;&amp; mkdir -p /var/lib/mysql /var/run/mysqld \\ &amp;&amp; chown -R mysql:mysql /var/lib/mysql /var/run/mysqld \\# ensure that /var/run/mysqld (used for socket and lock files) is writable regardless of the UID our mysqld instance ends up having at runtime &amp;&amp; chmod 777 /var/run/mysqld \\# comment out a few problematic configuration values &amp;&amp; find /etc/mysql/ -name '*.cnf' -print0 \\ | xargs -0 grep -lZE '^(bind-address|log)' \\ | xargs -rt -0 sed -Ei 's/^(bind-address|log)/#&amp;/' \\# don't reverse lookup hostnames, they are usually another container &amp;&amp; echo '[mysqld]\\nskip-host-cache\\nskip-name-resolve' &gt; /etc/mysql/conf.d/docker.cnfVOLUME /var/lib/mysqlCOPY docker-entrypoint.sh /usr/local/bin/RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compatENTRYPOINT [\"docker-entrypoint.sh\"]............ 其中 VOLUME /var/lib/mysql 指定了mysql的数据卷 将宿主机的一个目录，挂在到容器里使用 -v，除了可以创建一个数据卷，还可以挂载本地主机目录到容器中 1$ docker run -d -P --name my-shop-web -v /local/data/shop:/data/shop sqgulj/shop-web 这将会把本地目录/local/data/shop挂载到容器的/data/shop目录，宿主机上的目录必须是绝对路径，如果目录不存在docker会自动创建它。 出于可移植和分享的考虑，在Dockerfile中这种方式不支持 docker默认情况下是对数据卷有读写权限，但是我们通过这样的方式让数据卷只读： 1$ docker run -d -P --name my-shop-web -v /local/data/shop:/data/shop:ro sqgulj/shop-web 这里我们同样挂载了/local/data/shop目录，只是添加了 ro 选项来限制它只读。 将宿主机上单个文件挂载到容器中除了能挂载目录外，-v 标识还可以将宿主机的一个特定文件挂载为数据卷 1$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash 这样就可以记录在容器输入过的命令了 如果直接挂载一个文件，很多文件编辑工具，包括 vi 或者 sed –in-place，可能会造成文件 inode 的改变，从 Docker 1.1.0起，这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。 查看数据卷 使用命令 docker volume 可以查看我们生成的数据卷 123$ docker volume ls DRIVER VOLUME NAMElocal b202765855d3b77e574284fde0079d31fb0258997a7b72eb6f7c8299053f216b 我们可以看到我们添加的数据卷 /data/shop ，当我们查看的时候并不是我们提供的名称，而是生成一系列的随机串，当我们为多个容器添加数据卷的时候，它也会为其生成一系列的随机串，这样不利于我们辨识哪些数据卷挂在哪个容器中，为了解决这个问题，我们可以在添加数据数据卷的时候，为数据卷起个辨识的名称，比如 1$ docker run -d -P --name my-shop-web -v shopwebdata:/data/shop sqgulj/shop-web 我们发现，这次我们为容器添加一个数据的时候我们在前面加了一个 shopwebdata ，注意shopwebdata前面没有斜杠( / )，如果有斜杠那是把本地的一个目录挂载到容器内的一个目录 123$ docker volume ls DRIVER VOLUME NAMElocal shopwebdata 这次我们就能看到我们添加的数据卷就是我们起的名称，而不是一些列的随机串 使用命令 docker inspect 查看数据卷 123456789101112131415161718# my-shop-web 为容器的名称$ docker inspect my-shop-web............\"Mounts\": [ &#123; \"Type\": \"volume\", \"Name\": \"b202765855d3b77e574284fde0079d31fb0258997a7b72eb6f7c8299053f216b\", \"Source\": \"/var/lib/docker/volumes/b202765855d3b77e574284fde0079d31fb0258997a7b72eb6f7c8299053f216b/_data\", \"Destination\": \"/data/shop\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" &#125; ], ............. 这里只列出了其中的 Mounts 属性，从中可以看到Source字段显示了数据卷存放的位置 删除数据卷数据卷是被设计来持久化数据的，因此，删除容器并不会删除数据卷。如果想要在删除容器时同时删除数据卷，可使用如下命令： 1$ docker rm -v 容器ID 这样既可在删除容器的同时也将数据卷删除。 我们还可以使用 docker volume rm 命令删除数据卷 12345# 查看数据卷$ docker volume ls# 指定数据卷名称删除$ docker volume rm volume_name volume_name 删除所有的数据卷 1docker volume rm $(docker volume ls -f dangling=true -q) 数据卷容器如果有些数据，需要在多个容器之间进行共享，这时候可以使用数据卷容器创建数据卷容器 1docker run --name mysql-volume -v /data mysql 其它容器可以使用–volumes-from标识，来使用通过刚刚创建的数据卷容器，来挂载对应的数据卷 123$ docker run -d --volumes-from mysql-volume --name db1 mysql$ docker run -d --volumes-from mysql-volume --name db2 mysql 这样 db1 和 db2 两个容器都共享 mysql-volume 这个容器中的文件 挂载相同数据卷的容器，容器的停止和删除，不会对数据卷产生影响 我们也还可以对一个容器使用多个 –volumes-from 标识，来将多个数据卷桥接到这个容器中","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 容器","slug":"docker-容器","date":"2018-03-29T06:17:03.000Z","updated":"2019-02-14T07:07:12.864Z","comments":true,"path":"2018/03/29/docker-容器/","link":"","permalink":"http://www.gulj.cn/2018/03/29/docker-容器/","excerpt":"介绍Docker 容器是用于运行镜像的沙箱环境，它是 Docker 镜像的运行实例；容器都是相互隔离、互不可见的，我们可以理解为：镜像是Docker生命周期的打包和构建阶段，而容器是Docker的启动和执行阶段。 容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。 镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。","text":"介绍Docker 容器是用于运行镜像的沙箱环境，它是 Docker 镜像的运行实例；容器都是相互隔离、互不可见的，我们可以理解为：镜像是Docker生命周期的打包和构建阶段，而容器是Docker的启动和执行阶段。 容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。 镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 运行容器使用 docker run 命令来运行一个容器格式： 1$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] [flags] OPTIONS说明： 由于 docker run 命令 OPTIONS 比较多，这里只选择大家常用的几个选项来说明 -i, --interactive=false 打开STDIN，用于控制台交互 -t, --tty 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上 -d, --detach=false 指定容器运行于前台还是后台，默认为false -p, --publish list 指定主机的端口和容器端口的映射 -P, --publish-all 使用容器内随机一个网络端口映射到我们使用的主机上 -v, --volume list 给容器挂载存储卷，挂载到容器的某个目录 -m, --memory 指定容器的内存上限 --link list 指定容器间的关联，使用其他容器的IP、env等信息 -e, --env list 设置环境变量 --restart string 指定容器的重启策略 示例： 后台运行一个nginx 1$ docker run --name mynginx -p 8088:80 -v $PWD/nginx/www:/www -v $PWD/nginx/logs:/wwwlogs -d nginx 查看运行的容器 查看正在运行的容器 123$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES76ea0a1383d4 nginx &quot;nginx -g &apos;daemon of…&quot; Less than a second ago Up 3 seconds 0.0.0.0:8088-&gt;80/tcp mynginx 查看所有容器（包含正在运行和退出的容器） 123$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES76ea0a1383d4 nginx \"nginx -g 'daemon of…\" 3 minutes ago Exited (0) 2 seconds ago mynginx 查看容器的详细信息 1$ dokcer inspect mygnix 进入容器使用 docker exec 命令进入容器格式： 1$ docker exec [OPTIONS] CONTAINER COMMAND [ARG...] OPTIONS说明： -d, --detach 分离模式: 在后台运行 -i, --interactive 即使没有附加也保持STDIN 打开 -t, --tty 分配一个伪终端 -e, --env list 设置环境变量 示例： 以交互模式进入容器 12$ docker exec -it mynginx /bin/bashroot@76ea0a1383d4:/# 停止和重启容器如果是交互式运行的一个容器，可以通过exit命令和Ctrl+d来退出终端，这样容器会立刻终止 123# exit 直接退出，容器终止；或者快捷键Ctrl+d $ docer run -it centos /bin/bash[root@f7b52eb5ab02 /]# exit 使用 docker stop 命令来停止正在运行的容器格式： 1$ docker stop [OPTIONS] CONTAINER [CONTAINER...] 示例： 指定容器名称停止正在运行的多个容器 1$ docker stop mynginx myredis 重新启动容器 12345# 启动终止的容器$ docker start mynginx# 将一个运行态的容器终止，然后再重新启动它$ docker restart myredis 删除容器使用 docker rm 命令删除一个或多个容器格式： 1$ docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明： -f, --force 强制删除 -l, --link 移除容器间的网络连接，而非容器本身 -v, --volumes 删除与容器关联的卷 示例： 强制删除容器mynginx 1$ docker rm -f mynginx 删除mygninx，并删除容器挂载的数据卷 1$ docker rm -v mynginx 强制删除所有的容器 1$ docker rm -f $(docker ps -aq) 删除容器使用 docker rm 命令 而 删除容器使用 docker rmi 命令，注意两者区别 导出容器使用命令 docker export 导出本地某个容器 123456789# 查看容器列表$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf7b52eb5ab02 centos \"/bin/bash\" 18 hours ago Exited (0) 18 hours ago heuristic_edison06a6eb00f8bc centos \"/bin/bash\" 18 hours ago Up 18 hours stupefied_euler76ea0a1383d4 nginx \"nginx -g 'daemon of…\" 19 hours ago Up 19 hours 0.0.0.0:8088-&gt;80/tcp mynginx# 导出容器快照,到本地文件$ docker export 76ea0a1383d4 &gt; mynginx.tar.gz 导入容器使用命令 docker import 从快照文件中导入为镜像 1cat mynginx.tar.gz | docker import - sqgulj/nginx:2.0","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 镜像发布","slug":"docker-镜像发布","date":"2018-03-28T05:37:58.000Z","updated":"2019-02-14T07:07:12.865Z","comments":true,"path":"2018/03/28/docker-镜像发布/","link":"","permalink":"http://www.gulj.cn/2018/03/28/docker-镜像发布/","excerpt":"介绍如果我们自己在本地制作一个镜像，想提供给他人使用或者作为自己的日常学习，那么我们可以把我们制作的镜像发布到DockerHub上，这样不管是其它人还是我们自己就可以直接使用 docker pull 命令获取到我们发布的镜像，这样我们再也不用担心一不小心把本地镜像删除了；当然发布到DockerHub上的镜像是公开的，每个人都能获取，如果我们希望我们发布的镜像是私有的只有我们自己可以看见，我们可以利用官方提供的registry镜像来搭建自己私有的镜像仓库,当然我们也还可以使用Harbor来搭建企业级私有仓库服务器","text":"介绍如果我们自己在本地制作一个镜像，想提供给他人使用或者作为自己的日常学习，那么我们可以把我们制作的镜像发布到DockerHub上，这样不管是其它人还是我们自己就可以直接使用 docker pull 命令获取到我们发布的镜像，这样我们再也不用担心一不小心把本地镜像删除了；当然发布到DockerHub上的镜像是公开的，每个人都能获取，如果我们希望我们发布的镜像是私有的只有我们自己可以看见，我们可以利用官方提供的registry镜像来搭建自己私有的镜像仓库,当然我们也还可以使用Harbor来搭建企业级私有仓库服务器 镜像发布到 DockerHub镜像发布到 DockerHub，首先我们需要注册 DockerHub 账号，假设现在大家都有了DokcerHub的账号，那么接下来我们在本地制作一个自己的镜像 创建一个getip目录，进入到getip目录，编写Dockerfile 12345$ mkdir getip$ cd getip $ vim Dockerfile Dokcerfile文件中内容 1234567FROM ubuntu:16.04RUN apt-get update \\ &amp;&amp; apt-get install -y curl \\ &amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [\"curl\",\"-s\",\"http://ip.cn\"] 在getip目录执行 docker build 命令构建镜像 12# 构建镜像(注意仓库名必须是你注册的 dockerhub 的用户名)docker build -t sqgulj/get-ip:1.0 . 查看构建的镜像 123$ docker images;REPOSITORY TAG IMAGE ID CREATED SIZEsqgulj/get-ip 1.0 e381e0c1b380 3 hours ago 129MB 在终端使用 docker login 命令，输入自己的DockerHub账号信息进行登录 123docker loginLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.Username (sqgulj): 使用 docker push 命令把我刚制作的镜像推送到DockerHub 123456789$ docker push sqgulj/get-ipThe push refers to repository [docker.io/sqgulj/get-ip]83dc3de4596c: Pusheddb584c622b50: Mounted from library/ubuntu52a7ea2bb533: Mounted from library/ubuntu52f389ea437e: Mounted from library/ubuntu88888b9b1b5b: Mounted from library/ubuntua94e0d5a7c40: Mounted from library/ubuntu1.0: digest: sha256:1a3fa4e93464054c2f8050d6f846cccbe943c5e9f6d67f98f2013a32652f3f0b size: 1568 浏览器登录到DockerHub查看我们推送的镜像","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 镜像加速器","slug":"docker-镜像加速器","date":"2018-03-27T14:29:18.000Z","updated":"2019-02-14T07:07:12.864Z","comments":true,"path":"2018/03/27/docker-镜像加速器/","link":"","permalink":"http://www.gulj.cn/2018/03/27/docker-镜像加速器/","excerpt":"介绍由于国内访问官方（DockerHub）的镜像比较慢，可以使用阿里云和DaoCloud为我们提供的镜像 阿里云镜像加速器地址 DaoCloud 镜像加速器地址 本文笔者会分别介绍MacOs平台和Centos7平台下配置这两种的镜像加速器地址","text":"介绍由于国内访问官方（DockerHub）的镜像比较慢，可以使用阿里云和DaoCloud为我们提供的镜像 阿里云镜像加速器地址 DaoCloud 镜像加速器地址 本文笔者会分别介绍MacOs平台和Centos7平台下配置这两种的镜像加速器地址 MacOS 平台配置阿里云Docker加速器 登录阿里云控制台（需要注册阿里云开发者平台账号），访问地址：https://cr.console.aliyun.com/#/accelerator 可查看自己专有的镜像库加速器地址 下图展示的是笔者的阿里云镜像加速器界面 右键点击桌面顶栏的 docker 图标 Perferences… -&gt; Daemon -&gt; Registry mirrors，添加代理地址，记得点击 Apply &amp; Restart 按钮使设置生效。 出现的 “registry-mirrors” : No certs for 6wnqhom.mirror.aliyuncs.com… 警告可以忽略。 配置DaoCloud的Docker加速器 打开地址：https://www.daocloud.io/mirror#accelerator-doc 可以使用github账号登录或者微信 添加DaoCloud的dokcer镜像代理地址和添加阿里云Docker代理地址方法一样，读者可以参考上面添加的阿里云docker加速器代理地址 Centos7 平台配置阿里云Docker加速器通过上面我们已经知道了如何获取自己的的阿里云docker镜像代理地址 修改daemon配置文件/etc/docker/daemon.json来使用加速器： 分别执行以下命令，记得把加速器的地址，改成自己的加速器地址。 123456789101112sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://XXXXX.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 针对Docker客户端版本大于1.10.0的用户 检查加速器是否生效 Linux系统下配置完加速器需要检查是否生效，在命令行执行 ps -ef | grep dockerd，如果从结果中看到了配置的 –registry-mirror 参数说明配置成功 如果Docker版本大于1.13或17.05.0-ce 123$ sudo docker info|grep \"Registry Mirrors\" -A 1Registry Mirrors: https://16wnqhom.mirror.aliyuncs.com/","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 镜像","slug":"docker-镜像","date":"2018-03-27T11:03:41.000Z","updated":"2019-02-14T07:07:12.864Z","comments":true,"path":"2018/03/27/docker-镜像/","link":"","permalink":"http://www.gulj.cn/2018/03/27/docker-镜像/","excerpt":"获取镜像官方的 DockerHub 上有很多开源的高质量镜像，可以直接供我们使用 使用docker pull 命令直接从 DockerHub 上获取 格式： 1docker pull [选项] [docker registry 地址]:&lt;仓库名&gt;:&lt;标签&gt; 示例： 123456789# 获取nginx镜像$ docker pull nginxUsing default tag: latestlatest: Pulling from library/nginx2a72cbf407d6: Pull completefefa2faca81f: Pull complete080aeede8114: Pull completeDigest: sha256:c4ee0ecb376636258447e1d8effb56c09c75fe7acf756bf7c13efadf38aa0acaStatus: Downloaded newer image for nginx:latest","text":"获取镜像官方的 DockerHub 上有很多开源的高质量镜像，可以直接供我们使用 使用docker pull 命令直接从 DockerHub 上获取 格式： 1docker pull [选项] [docker registry 地址]:&lt;仓库名&gt;:&lt;标签&gt; 示例： 123456789# 获取nginx镜像$ docker pull nginxUsing default tag: latestlatest: Pulling from library/nginx2a72cbf407d6: Pull completefefa2faca81f: Pull complete080aeede8114: Pull completeDigest: sha256:c4ee0ecb376636258447e1d8effb56c09c75fe7acf756bf7c13efadf38aa0acaStatus: Downloaded newer image for nginx:latest 使用Dockerfile构建Docker镜像 （建议使用Dockerfile构建自己的Docker镜像） 格式： docker image build [OPTIONS] PATH | URL | - [flags] 简写： docker build [OPTIONS] PATH | URL | - [flags] 创建一个nginx目录，编写dockerfile文件 123456789# 创建一个nginx目录$ mkdir nginx# 编写Dockerfile文件 (注意名称必须为:Dockerfile)$ vim Dockerfile# Dockerfile 文件中内容FROM nginxRUN echo '&lt;h1&gt;Hello, nginx!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html 在 Dockerfile 文件所在目录执行下面命令，构建名为 gulj/nginx:v1 的docker镜像 12# 构建名为 mynginx:v1 的镜像$ docker build -t gulj/nginx:v1 . 使用docker commit 命令通过已有的 容器 创建镜像（不建议使用） 格式：docker container commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 简写：docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 既然通过容器创建镜像，那么首先需要运行一个容器，而运行一个容器需要一个基础镜像，下面将使用官方的centos镜像，通过加工来构建自己的镜像 大致流程如下： ① 获取官方的centos镜像 ② 对获取的centos镜像执行docker run 命令获取一个容器 ③ 对获取的容器进行安装vim操作，安装结束，退出容器（默认官方的centos镜像没有vim命令） ④ 通过docker commit 命令构建镜像，这样我们就能得到了一个带有vim命令的centos镜像 按照流程操作演示 1234567891011121314151617181920212223242526272829# 获取centos镜像$ docker pull centosUsing default tag: latestlatest: Pulling from library/centos5e35d10a3eba: Pull completeDigest: sha256:dcbc4e5e7052ea2306eed59563da1fec09196f2ecacbe042acbdcd2b44b05270Status: Downloaded newer image for centos:latest# 以交互式方式获取一个容器,这样我们就会进入容器内，安装vim，安装完之后退出容器$ docker run -it centos# 在容器内安装vim[root@34046cf71732 /] yum install vim -y # 退出容器[root@34046cf71732 /] exit # 查看我们刚才运行的容器$ dokcer ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES34046cf71732 centos \"/bin/bash\" 10 minutes ago Exited (0) 15 seconds ago cocky_euler# 构建安装vim的centos镜像, --author 是指定修改的作者，而 --message 则是记录本次修改的内容，可省略$ docker commit --author \"gulj &lt;sqgulj@gmail.com&gt;\" --message \"安装了vim\" cocky_euler gulj/centos-vim:1.0sha256:1109b8f3ea7826225d1dc1ee2693507fe8402eaeeafc57d24b907018a5cc0951# 查看我们构建的镜像$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgulj/centos-vim 1.0 1109b8f3ea78 15 seconds ago 354MBcentos latest 2d194b392dd1 3 weeks ago 195MB 下面我们通过docker history 命令查看镜像内的历史记录，与 centos:latest 的镜像历史记录比较，我们会很明显地发现，gulj/centos-vim:1.0 的镜像历史记录比 centos:latest 的镜像历史记录多了一层，也就是我们提交的一层（sha256:1109b8f3ea7826225d1…） 1234567891011121314# centos:latest 镜像$ docker history centosIMAGE CREATED CREATED BY SIZE COMMENT2d194b392dd1 3 weeks ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0B&lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) LABEL name=CentOS Base Im… 0B&lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) ADD file:8d83f3e2c14f39e7f… 195MB# 我们自己构建的gulj/centos-vim:1.0镜像$ docker history gulj/centos-vim:1.0IMAGE CREATED CREATED BY SIZE COMMENT1109b8f3ea78 9 minutes ago /bin/bash 158MB2d194b392dd1 3 weeks ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0B&lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) LABEL name=CentOS Base Im… 0B&lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) ADD file:8d83f3e2c14f39e7f… 195MB docker commit 操作只专注于可读可写层（Read-Write Layer），数据卷 VOLUME 挂载的目录内容，还有类似于 hosts、hostsname 和resolv.conf 等挂载文件，当然还有一些如 /proc 和 /sys 等虚拟文件系统的内容都将不会出现在打包后的镜像中 镜像常用命令搜索镜像使用 docker search 命令从DockerHub中搜索格式： 1docker search [OPTIONS] TERM OPTIONS说明： -f, --filter filter 根据指定条件过滤结果 --format string 通过Go语言模板文件展示镜像 --limit int 限制显示的个数 --no-trunc 显示完整的镜像描述 示例： 从Docker Hub查找所有镜像名包含nginx，并且收藏数大于500的镜像 12345docker search -f=stars=500 nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 8227 [OK]jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1300 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 538 [OK] 列出镜像使用 docker images 命令列出本地镜像格式： 1docker images [OPTIONS] [REPOSITORY[:TAG]] OPTIONS说明： -a, --all 显示所有的镜像 (默认隐藏中间层镜像) --digests 显示摘要 -f, --filter filter 显示满足条件的镜像 --format string 通过Go语言模板文件展示镜像 --no-trunc 显示完整的镜像信息 -q, --quiet 只显示镜像ID 示例： 查看本地镜像列表 123456docker images 或者 docker images lsgulj/centos-vim 1.0 1109b8f3ea78 4 hours ago 354MBnginx latest 7f70b30f2cc6 6 days ago 109MBcentos latest 2d194b392dd1 3 weeks ago 195MBpostgres latest 6152297591eb 3 weeks ago 289MBbusybox latest f6e427c148a7 3 weeks ago 1.15MB 其它使用方式： 123456789101112131415docker image lsdocker images -q # 只展示镜像的IDdocker images mysqldocker images mysql:5.7docker images --digests mysql:5.7 docker images -f since=mysql:5.7 # 展示 mysql:5.7 之后建立的镜像docker images --format \"&#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\" # 只展示镜像ID和仓库docker images -f \"dangling=true\" # 展示虚悬镜像 删除镜像使用 docker rmi 命令删除本地一个或多个镜像格式： 1docker rmi [OPTIONS] IMAGE [IMAGE...] [flags] OPTIONS说明： -f, --force 强制删除 --no-prune 不移除该镜像的过程镜像，默认移除 示例： 强制删除本地指定名称的镜像 1docker images rmi -f gitlab/gitlab-ce 其它使用方式： 123456789docker rmi -f 2aa1fe2f052b # 根据镜像ID删除指定镜像docker rmi gulj/centos-vim nginx busybox # 删除多个镜像docker rmi $(docker images -q redis) # 删除所有仓库名为reids的镜像docker rmi $(docker images -q -f dangling=true) # 删除所有的虚悬镜像docker rmi $(docker images -aq) # 删除所有的镜像","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 初识","slug":"docker-初识","date":"2018-03-27T01:44:09.000Z","updated":"2019-02-14T07:07:12.863Z","comments":true,"path":"2018/03/27/docker-初识/","link":"","permalink":"http://www.gulj.cn/2018/03/27/docker-初识/","excerpt":"介绍Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。 系统架构","text":"介绍Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。 系统架构 核心技术 Namespaces (namespace) Namespace是Linux提供的一种内核级别环境隔离的方法,提供了对UTS、IPC、mount、PID、network、User等的隔离机制。 Control groups (CGroup) 用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等） 可​​以让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU 时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合。 主要提供了一下功能 Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。 Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。 Accounting: 一些审计或一些统计，主要目的是为了计费。 Control: 挂起进程，恢复执行进程 Union file systems (AUFS) AUFS是一个能透明覆盖一或多个现有文件系统的层状文件系统。 支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。这种是一种虚拟的文件系统，文件系统不用格式化，直接挂载即可 当一个进程需要修改一个文件时，AuFS创建该文件的一个副本。AuFS可以把多层合并成文件系统的单层表示。这个过程称为写入复制copy on write ….等 核心组件 客户端 Client Docker client 是给用户和 Docker daemon 建立通信的客户端，安装了 docker 之后，二进制文件 docker 就是 Docker client，与 Docker daemon 交互， 通过客户端 docker 命令，我们可以方便地实现对 Docker image 和 container 的管理请求。 Docker client 与 docker daemon 建立请求的方式有三种，分别是： tcp://host:port unix://path/to/socket fd://socketfd 常驻后台的系统进程 Docker daemon Docker daemon 是一个常驻后台的系统进程，所谓“运行 docker”，指的就是运行 Docker daemon，其作用主要有以下两点： 接受并处理 Docker Client 发送的请求 管理所有的 Docker containers 和 Docker images Docker daemon 的架构大致可以分为三部分：Docker Server、Engine 和 Job。 docker daemon 监听来自 remote api 的请求的方式有三种：unix、tcp 和 fd 默认配置下，Docker daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，可以使用dockerd命令： 1dockerd -H 0.0.0.0 镜像 &nbsp;Image 镜像是一个只读的层（layer），由文件系统叠加构成，就相当于是一个 root 文件系统，通过它可以创建 Docker 容器（Container）。 分层存储，每一层都可以添加改变和删除文件，形成一个新的镜像 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层 不同的镜像可以共享相同的层 容器 &nbsp;Container Docker 容器是用于运行镜像的沙箱环境，它是 Docker 镜像的运行实例；容器都是相互隔离、互不可见的，我们可以理解为：镜像是Docker生命周期的打包和构建阶段，而容器是Docker的启动和执行阶段。 镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 在Image Layer之上建立一个 Container Layer（读写层），镜像（image）负责app的存储和分发，容器（Container）负责运行app 仓库 &nbsp;Registry Registry 是集中的存储、分发镜像的文件仓库 仓库分为公有仓库和私有仓库，常用的公有仓库是官方的 Docker Hub，默认的 docker pull 命令就是从官方的公有仓库中拉取镜像；个人可以根据Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 安装","slug":"Docker-安装","date":"2018-03-26T09:23:17.000Z","updated":"2019-02-14T07:07:12.859Z","comments":true,"path":"2018/03/26/Docker-安装/","link":"","permalink":"http://www.gulj.cn/2018/03/26/Docker-安装/","excerpt":"导读本系列的docker学习笔者均采用Vagrant和VirtualBox进行，下面我会给出这两款工具的简单介绍。 Vagrant介绍Vagrant是hashicorp这家公司的产品，是一个让你可以方便设置你想要的虚拟机的便携式工具，它底层支持VirtualBox、VMware甚至AWS作为虚拟机系统。 我们可以通过Vagrant提供的命令行工具vagrant，可以快速启动根据我们事先定义好的Vagrantfile文件，来创建一个或者多个虚拟机。 Vagrantfile是用来定义vagrant project的，使用ruby语法。","text":"导读本系列的docker学习笔者均采用Vagrant和VirtualBox进行，下面我会给出这两款工具的简单介绍。 Vagrant介绍Vagrant是hashicorp这家公司的产品，是一个让你可以方便设置你想要的虚拟机的便携式工具，它底层支持VirtualBox、VMware甚至AWS作为虚拟机系统。 我们可以通过Vagrant提供的命令行工具vagrant，可以快速启动根据我们事先定义好的Vagrantfile文件，来创建一个或者多个虚拟机。 Vagrantfile是用来定义vagrant project的，使用ruby语法。 安装Vagrant支持Mac、Window,Centos 等各种平台，下图展示支持的各种平台列表 下载地址：https://www.vagrantup.com/downloads.html 查看是否安装成功 12# 查看vagrant版本信息$ vagrant version 使用 添加一个box 格式：vagrant box add 远端的box地址或者本地的box文件名 12# 添加 centos/7 的box$ vagrant box add centos/7 通过这个步骤，vagrant会去box列表中找centos/7这个镜像，如果没有就去官方下载 box的名称我们通过官方提供的地址:https://app.vagrantup.com/boxes/search?page=1 去search 初始化 格式： vagrant init box列表中box的名称 12345# 新建一个目录，为centos7$ mkdir centos7# 进入centos7目录，初始化box,这里的（centos/7）就是我们第一步添加的box名称$ vagrant init centos/7 这样就会在当前目录(centos7)生成一个Vagrantfile的文件,注意每个目录只能存放一个Vagrantfile文件，所以我们要事先定义好我们需要创建系统的目录 启动虚拟机 我们已经通过vagrant init centos/7 命令，得到了vagrantfile文件，下面我们可以通过vagrant up 命令来启动vagrantfile中定义的虚拟机 1$ vagrant up 这样我们就在在Virtualbox中创建了一个虚拟机 连接虚拟机 1$ vagrant ssh Vagrant 的其它基本命令 查看命令帮助 1$ vagrant --help 查看虚拟机的状态 1$ vagrant status 查看box列表 1$ vagrant box list 停止虚拟机 1$ vagrant halt 销毁虚拟机 1$ vagrant destory 通过自定义Vagrantfile来创建虚拟机 编写Vagrantfile,灵活的设置虚拟机的参数 1234567891011121314151617181920212223242526272829303132333435363738# -*- mode: ruby -*-# vi: set ft=ruby : Vagrant.require_version \"&gt;= 1.6.0\" boxes = [ &#123; :name =&gt; \"docker-node-test1\", :eth1 =&gt; \"192.168.215.10\", :mem =&gt; \"2048\", :cpu =&gt; \"2\" &#125;] Vagrant.configure(2) do |config| config.vm.box = \"centos/7\" boxes.each do |opts| config.vm.define opts[:name] do |config| config.vm.hostname = opts[:name] config.vm.provider \"vmware_fusion\" do |v| v.vmx[\"memsize\"] = opts[:mem] v.vmx[\"numvcpus\"] = opts[:cpu] end config.vm.provider \"virtualbox\" do |v| v.customize [\"modifyvm\", :id, \"--memory\", opts[:mem]] v.customize [\"modifyvm\", :id, \"--cpus\", opts[:cpu]] end config.vm.network :private_network, ip: opts[:eth1] end end #config.vm.synced_folder \"./labs\", \"/home/vagrant/labs\" #config.vm.provision \"bash\", privileged: true, path: \"./setup.sh\"end Vagrantfile下载地址： xxxx 创建虚拟机 1vagrant up Docker 安装 在 Mac 平台上安装 下载地址：https://www.docker.com/community-edition 在 centos7 平台上安装步骤 官网地址：https://docs.docker.com/install/linux/docker-ce/centos/#install-from-a-package 卸载老的版本 12345678910$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装docker ce (注意docker 有docker ce 和 docker ee 两个版本，我们学习使用docker ce版本) ①、安装依赖包 123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 ②、设置稳定仓库地址 123$ sudo yum-config-manager \\--add-repo \\https://download.docker.com/linux/centos/docker-ce.repo ③、【可选】启用 edge 和 test 仓库 1234567# 启用 --enable$ sudo yum-config-manager --enable docker-ce-edge$ sudo yum-config-manager --enable docker-ce-test# 禁用 --disable$ sudo yum-config-manager --disable docker-ce-edge ④、安装稳定版本的docker ce 1$ sudo yum install docker-ce ⑤、【可选】查看具体的docker ce 版本，这样我们可以在生产环境安装具体的docker ce 版本 1234567# 查看docker ce 版本列表$ yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 18.03.ce-1.el7.centos docker-ce-stable# 使用命令安装具体的docker ce 版本$ sudo yum install &lt;FULLY-QUALIFIED-PACKAGE-NAME&gt; ⑥、启动docker 1$ sudo systemctl start docker ⑦、验证docker是否正确安装，可以通过运行 helloworld 镜像 1$ sudo docker run hello-world docker-machine 创建docker主机如果我们已经在mac平台安装过docker，默认会自带docker-machine；到现在我们已经知道了，可以通过virtualbox这个虚拟机软件直接创建虚拟机，安装docker，得到一台docker主机、也可以通过编写vagrantfile创建虚拟机，安装docker，也能得到一台docker主机、现在我们还可以通过docker-machine命令，来创建一台带有docker的主机 查看版本信息 12345$ docker-machine -v # 或者 $ docker-machine create -d virtualbox demo 创建docker虚拟机 (使用 virtualbox 类型的驱动) 1$ docker-machine create demo 你也可以在创建时加上如下参数，来配置主机或者主机上的 Docker。 –engine-opt dns=114.114.114.114 配置 Docker 的默认 DNS –engine-registry-mirror https://registry.docker-cn.com 配置 Docker 的仓库镜像 –virtualbox-memory 2048 配置主机内存 –virtualbox-cpu-count 2 配置主机 CPU 查看虚拟机列表 1$ docker-machine ls 进入虚拟机 1$ docker-machine ssh demo 停止虚拟机 1$ docker-machine stop demo 现在我们已经在mac(宿主机)上安装了docker，又通过 docker-machine 方式创建，得到了一台docker主机；那么现在我们有这样一种需求，如何让宿主机上的docker client端连接，通过docker-machine创建的docker server端。 步骤 查看docker-machine创建虚拟机的环境变量 123456789# 在 mac（宿主机上） 执行 查看docker-machine$ docker-machine env demoexport DOCKER_TLS_VERIFY=\"1\"export DOCKER_HOST=\"tcp://192.168.99.100:2376\"export DOCKER_CERT_PATH=\"/Users/gulj/.docker/machine/machines/demo\"export DOCKER_MACHINE_NAME=\"demo\"# Run this command to configure your shell:# eval $(docker-machine env demo) 设置宿主机的docker环境变量为docker-machine创建的docker主机环境变量 1$ eval $(docker-machine env demo) 查看是否修改成功 123456789101112131415161718$ docker versionClient: Version: 17.12.0-ce API version: 1.35 Go version: go1.9.2 Git commit: c97c6d6 Built: Wed Dec 27 20:03:51 2017 OS/Arch: darwin/amd64Server: Engine: Version: 18.03.0-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.4 Git commit: 0520e24 Built: Wed Mar 21 23:14:54 2018 OS/Arch: linux/amd64 Experimental: false 这样宿主机的docker client端就已经连接到通过docker-machine创建的docker主机server端，那么我们在本地操作的docker任何命令，直接作用于 docker-machine 创建的docker主机 Docker 在线实验室 ，无需安装，直接使用地址 https://labs.play-with-docker.com/ 介绍Play With Docker ( Docker 在线实验室) 是一个运行在浏览器中的 Docker Playground，无需安装任何环境，就可以在线体验 Docker 使用","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"Charles进行HTTPS抓包","slug":"Charles进行HTTPS抓包","date":"2017-12-27T07:28:29.000Z","updated":"2019-02-14T07:07:12.859Z","comments":true,"path":"2017/12/27/Charles进行HTTPS抓包/","link":"","permalink":"http://www.gulj.cn/2017/12/27/Charles进行HTTPS抓包/","excerpt":"介绍Charles其实是一款代理服务器，通过成为电脑或者浏览器的代理，然后截取请求和请求结果达到分析抓包的目的。charles有Window版本和Mac OS版本，也同时支持ios和Android手机系统 下载百度云：Charles 4.2.1 Mac破解版 环境 Charles 4.2.1 Iphone 7P ios 11.0.1","text":"介绍Charles其实是一款代理服务器，通过成为电脑或者浏览器的代理，然后截取请求和请求结果达到分析抓包的目的。charles有Window版本和Mac OS版本，也同时支持ios和Android手机系统 下载百度云：Charles 4.2.1 Mac破解版 环境 Charles 4.2.1 Iphone 7P ios 11.0.1 使用前提 保证iOS设备iphone或ipad与运行Charles的mac电脑处于同一个wifi环境下 基本配置 ①、配置HTTP代理，这步与抓取HTTP请求是一样的 打开: charles 的 Proxy 选项选择 Proxy Settings 按照下图配置: x备注：选择在8888端口上监听，然后确定。够选了SOCKS proxy，还能截获到浏览器的http访问请求。 ②、配置SSL代理 打开： charles 的 Proxy 选项选择 SSL Proxy Settings在 SSL Proxying 的Tab项中 点击 Add 按钮，按下图填写 添加好之后，如下图展示： 手机端设置代理和安装Charles根证书1、手机端安装Charles根证书在Safri上地址栏粘贴 chls.pro/ss 点击立即前往，自动下载根证书 而在ios10.3之后，安装新的自定义证书默认是不受信任的，如果要信任已安装的自定义证书,需要手动打开开关以信任证书。 开始信任证书步骤：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可. 2、手机端手机设置代理打开： charles 的 Help 选项选择 Install Charles Root Certificate On a Mobile Device Or a Remote Browser 点击 ok 按钮 首先在Mac上，查看IP地址：方法一：系统偏好设置-&gt;网络-&gt;wifi-&gt;高级-&gt;TCP/IP方法二：ifcofnig 命令 （在终端或者Iterm上）本机Ip：192.168.6.174 打开手机： 设置界面，选择无线局域网 进入无线局域网界面，点击所连的无线网旁边的 i 图标 进入配置代理界面，点击底部的配置代理，改为手动模式 配置代理服务器地址：填写本机Mac的Ip地址，端口：填写 charles 的 代理端口，默认是：8888；也可以自定义修改 配置好之后，Mac上会弹出以下提示框，表示Charles软件检测到可供检测的设备。两个按钮选项：Allow 允许 ， Deny拒绝。我们要选择允许 电脑端(Mac)安装Charles根证书直接在Charles的Help菜单中安装；安装完成后去系统的钥匙串访问中信任它 在本机的系统的钥匙串访问中，找到Charles证书，默认是不被信任的，双击，该证书，修改为始终信任 效果展示 __","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"charles","slug":"charles","permalink":"http://www.gulj.cn/tags/charles/"}]},{"title":"ELK(5.6.3)技术栈集群搭建","slug":"ELK5-X技术栈集群搭建","date":"2017-11-24T14:28:29.000Z","updated":"2019-02-14T07:07:12.859Z","comments":true,"path":"2017/11/24/ELK5-X技术栈集群搭建/","link":"","permalink":"http://www.gulj.cn/2017/11/24/ELK5-X技术栈集群搭建/","excerpt":"1、ElasticSearch单节点和集群搭建 系统环境 系统/软件 版本 centos 7 jdk # es 依赖jdk 8 node # es 安装head插件需要 8.2.1 elasticsearch 5.6.3 logstash 5.6.3 kibana 5.6.3","text":"1、ElasticSearch单节点和集群搭建 系统环境 系统/软件 版本 centos 7 jdk # es 依赖jdk 8 node # es 安装head插件需要 8.2.1 elasticsearch 5.6.3 logstash 5.6.3 kibana 5.6.3 机器规划及节点分布 主机 节点 节点 节点 192.168.1.110 elasticsearch-master logstash kibana 192.168.1.111 Elasticsearch-slave1 logstash 192.168.1.112 Elasticsearch-slave2 logstash 目录分配 下载软件源码包存放的位置: 1/usr/local/src/ 安装位置: 1/usr/local/ 相关软件包官方下载地址 https://www.elastic.co/downloads ①、elasticsearch 单节点安装（192.168.1.110）下载： 1wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.3.tar.gz 解压缩 1tar -zxvf elasticsearch-5.6.3.tar.gz 创建软链接 1ln -s /usr/local/elasticsearch-5.6.3/ /usr/local/elasticsearch-master 创建elasticsearch用户，把elasticsearch-master的所有者和所有组设置为用户elasticsearch（ES不能以root用户启动） 123456# 添加 elasticsearch 用户useradd elasticsearch# 为 elasticsearch 用户设置密码passwd elasticsearch# 将 elasticsearch-master 的目录的所有者和所属组设置为用户 elasticsearchchown -R elasticsearch:elasticsearch /usr/local/elasticsearch-master 启动 123456# 进入es的根目录cd elasticsearch-master# 启动(放入后台启动，注意不能以root用户启动,以elasticsearch用户启动)./bin/elasticsearch -d# 访问eshttp://localhost:9200 elastisearch 安装常见错误日志和解决方案参考地址： 报错”max virtual memory areas vm.maxmapcount [65530] is too low”，要运行下面的命令。 1sudo sysctl -w vm.max_map_count=262144 其它报错信息解决方案参考地址 1http://www.jianshu.com/p/4c6f9361565b 测试ES服务是否启动正常（默认监听9200端口） 12345678910111213141516# 访问地址http://192.168.1.110:9200# 返回数据&#123;name: \"aRvmIj4\",cluster_name: \"elasticsearch\",cluster_uuid: \"tXoxyBvmSFGNkiJfAOJWXw\",version: &#123; number: \"5.6.3\", build_hash: \"1a2f265\", build_date: \"2017-11-24T20:33:39.012Z\", build_snapshot: false, lucene_version: \"6.6.1\"&#125;,tagline: \"You Know, for Search\"&#125; ES的Head插件安装（提供友好的web界面，es一些基本信息的查询） 下载 1wget https://github.com/mobz/elasticsearch-head/archive/master.zip 解压缩 1unzip master.zip 安装 123456# 进入 elasticsearch-head-master 目录cd elasticsearch-head-master# 执行 npm install npm install# 运行 npm run startnpm run start 访问ESHead插件（默认监听9100端口） http://localhost:9100 ES和Head插件关联配置(ES和Head插件属于两个不同的进程，解决跨域问题) 修改:elasticsearch-5.6.3/config/elasticsearch.yml配置文件 12345# 编辑ES配置文件vim elasticsearch.yml# 在配置文件最后添加两行配置http.cors.enabled: true # 注意yml文件的格式，true 前面有空格http.cors.allow-origin: \"*\" 最后重启ES服务和ES的Head插件，配置完成 ②、elasticsearch 集群（1 master，2个slave）-&gt; (192.168.1.110(master),192.168.1.111,192.168.1.112)基于第一步单节点(192.168.1.110)安装集群（我们把它设置为Master节点） 修改:elasticsearch-master/config/elasticsearch.yml配置文件 123456789101112131415161718192021# 解决跨域问题http.cors.enabled: truehttp.cors.allow-origin: \"*\"# 集群名称cluster.name: gulj-es# 节点名称node.name: es-master# 告知节点为master节点node.master: true# 设置是否为数据节点node.data: true# Ip地址network.host: 192.168.1.110# 端口http.port: 9200# 日志存放位置path.logs: /data/elasticsearch/logs# 数据存放位置path.data: /data/elasticsearch/data# 单播，配置集群中的所有节点discovery.zen.ping.unicast.hosts: [\"192.168.1.110\",\"192.168.1.111\"] 重新解压缩elasticsearch-5.6.3.tar.gz包复制两份， 分别命名为 elasticsearch_slave1（节点：192.168.1.111）和elasticsearch_slave2（节点：192.168.1.112） 12345# 解压缩 es 包tar -zxvf elasticsearch-5.6.3.tar.gz# 复制两份 es 并重命名cp -r elasticsearch-5.6.3 elasticsearch_slave1cp -r elasticsearch-5.6.3 elasticsearch_slave2 分别修改 elasticsearch_slave1、elasticsearch_slave2 的 elasticsearch.yml 配置文件 123456789101112131415161718192021# 集群名称cluster.name: gulj-es# 节点名称,注意salve2节点,需要命名为对应的es-slave02node.name: es-slave01# 不是masternode.master: false# 数据节点node.data: true# 绑定的Ipnetwork.host: 0.0.0.0# 绑定端口http.port: 9200# 日志位置path.logs: /data/elasticsearch/logs# 数据位置path.data: /data/elasticsearch/data# 单播发现discovery.zen.ping.unicast.hosts: [\"192.168.1.110\"]# 解决跨域http.cors.enabled: truehttp.cors.allow-origin: \"*\" elasticsearch_slave2的配置文件和elasticsearch_slave1的配置文件大致相同，只需要修改node.name（节点名称）这里不再演示(注意防火墙的设置，建议关闭) Elasticsearch Head 插件页面展示 2、logStash安装下载1wget https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.tar.gz 解压缩 1tar -zxvf logstash-5.6.3.tar.gz 创建软链接 12# 创建软连接ln -s /usr/local/logstash-5.6.3 /usr/local/logstash 创建logstash配置文件 12# 创建logstash配置文件vim logstash.conf logstash.conf 文件内容（根据各自的业务需求，收集相应的日志，具体语法，参考官方文档） 12345678910111213141516171819input &#123; file &#123; # 收集ES的Log日志 path =&gt; \"/data/elasticsearch/logs/gulj-es.log\" # 自定义类型 type =&gt; \"es-master\" # 从开始位置进行收集 start_position =&gt; \"beginning\" &#125;&#125;output&#123; elasticsearch&#123; # ES节点主机地址 hosts =&gt; [\"192.168.1.110:9200\"] # 设置索引名称 index =&gt; \"es-master-log\" &#125;&#125; 启动 12# 启动logstash./bin/logstash -f logstash.conf 3、Kibana安装下载 1wget https://artifacts.elastic.co/downloads/kibana/kibana-5.6.3-linux-x86_64.tar.gz 解压缩 1tar -zxvf kibana-5.6.3-linux-x86_64.tar.gz 创建软连接 1ln -s /usr/local/kibana-5.6.3-linux-x86_64 /usr/local/kibana 修改配置文件 1234567891011# 打开kibana配置文件vim kibana/conf/kibana.yml# 打开或修改以下配置参数# 监听端口server.port: 5601# 监听主机server.host: \"192.168.1.110\"# ES服务地址elasticsearch.url: \"http://192.168.1.110:9200\"# kibana的索引kibana.index: \".kibana\" 启动 12# 启动kibana./bin/kibana Kibana页面展示","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://www.gulj.cn/tags/elk/"}]},{"title":"ElasticSearch常用API使用教程","slug":"ElasticSearch常用API使用教程","date":"2017-11-10T02:44:00.000Z","updated":"2019-02-14T07:07:12.860Z","comments":true,"path":"2017/11/10/ElasticSearch常用API使用教程/","link":"","permalink":"http://www.gulj.cn/2017/11/10/ElasticSearch常用API使用教程/","excerpt":"ElasticSearch 常用API使用教程1、基本概念介绍 索引：含有相同属性的集合 类型：索引可以定义一个或者多个类型，文档必须属于一个类型 文档：文档是可以被索引的基本数据单位 分片：每个索引都有多个分片，每个分片都是Lucene索引 备份：拷贝一份分片就完成了分片的备份","text":"ElasticSearch 常用API使用教程1、基本概念介绍 索引：含有相同属性的集合 类型：索引可以定义一个或者多个类型，文档必须属于一个类型 文档：文档是可以被索引的基本数据单位 分片：每个索引都有多个分片，每个分片都是Lucene索引 备份：拷贝一份分片就完成了分片的备份 2、API使用 API基本格式：http://:/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt; 常用的HTTP动词：GET/PUT/POST/DELETE 索引操作新建索引 直接新建一个book索引 1$ curl -X PUT 'localhost:9200/book' 通过新建类型为program_book来新建book索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ curl -X PUT 'localhost:9200/book' -d '&#123; \"mappings\": &#123; \"program_book\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"author\": &#123; \"type\": \"keyword\" &#125;, \"number\": &#123; \"type\": \"integer\" &#125;, \"create_time\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125; &#125;&#125;'# 或者curl -X POST 'localhost:9200/book/program_book/_mapping?pretty' -d'&#123; \"program_book\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"author\": &#123; \"type\": \"keyword\" &#125;, \"number\": &#123; \"type\": \"integer\" &#125;, \"create_time\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125;&#125;' 通过插入一个或者多个文档来新建book索引 1234567$ curl -X PUT 'localhost:9200/book/program_book/1' -d ' &#123; \"title\": \"Java并发编程实战\", \"author\": \"Doug\", \"number\": 100, \"create_time\":\"2017-08-01\" &#125;' 查看新建的所有索引 1$ curl -X GET 'localhost:9200/_cat/indices?v' 删除索引 删除 book 索引 1$ curl -X DELETE 'localhost:9200/book' 类型操作 新建类型 新建 program_book 类型 123456789101112131415161718192021222324$ curl -X PUT 'localhost:9200/book' -d '&#123; \"mappings\": &#123; \"program_book\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"author\": &#123; \"type\": \"keyword\" &#125;, \"number\": &#123; \"type\": \"integer\" &#125;, \"create_time\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125; &#125;&#125;' 修改类型 索引book，给类型program_book 新增一个update_time字段 12345678910$ curl-XPOST'localhost: 9200/book/program_book/_mapping?pretty'-d'&#123; \"program_books\": &#123; \"properties\": &#123; \"update_time\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125;&#125;' 文档操作 新增文档 新增单条文档，指定Id 123456$ curl-XPUT'localhost: 9200/book/program_book/1'-d'&#123; \"title\": \"重构\", \"author\": \"佚名\", \"number\": 50, \"create_time\": \"2017-01-11\"&#125;' 新增单条文档，不指定id 123456$ curl-XPUT'localhost: 9200/book/program_book'-d'&#123; \"title\": \"重构\", \"author\": \"佚名\", \"number\": 50, \"create_time\": \"2017-01-11\"&#125;' 查看文档 查看/book/program_book/1这条记录，URL 的参数pretty=true表示以易读的格式返回。 1$ curl 'localhost:9200/book/program_book/1?pretty=true' 修改文档 修改就是使用 PUT 请求，重新发送一次新增文档的数据。 123456$ curl-XPUT'localhost: 9200/book/program_book/1'-d'&#123; \"title\": \"修改操作-重构\", \"author\": \"佚名\", \"number\": 50, \"create_time\": \"2017-01-11\"&#125;' 删除文档 1$ curl -X DELETE 'localhost:9200/book/program_book/1' 复杂查询 查询指定索引，指定类型的的所有文档(/Index/Type/_search) 1$ curl 'localhost:9200/book/program_book/_search?pretty' 使用 Match 查询,指定的匹配条件查询 12345678910111213141516171819curl'localhost: 9200/book/program_book/_search?pretty'-d'&#123; \"query\": &#123; \"match\": &#123; \"title\": \"重构\" &#125; &#125;, \"from\": 1, \"size\": 1, \"sort\": &#123; \"create_time\": &#123; \"order\": \"desc\" &#125; &#125;&#125;'# 参数解释# from 偏移量，指定查询从位置1开始（默认是从位置0开始）# size 指定返回数据的个数为1条# 根据 create_time 进行排序 使用 Match 查询,指定的匹配条件查询 （查询多个搜索关键字， Elastic 认为它们是or关系） 1234567curl'localhost: 9200/book/program_book/_search?pretty'-d'&#123; \"query\": &#123; \"match\": &#123; \"title\": \"重构 修改\" &#125; &#125;,&#125;' 使用 Must 查询,指定的匹配条件查询 （查询多个搜索关键字， Elastic 认为它们是and关系） 1234567891011$ curl 'localhost:9200/book/program_book/_search?pretty' -d ' &#123; \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"match\": &#123; \"desc\": \"重构\" &#125; &#125;, &#123; \"match\": &#123; \"desc\": \"修改\" &#125; &#125; ] &#125; &#125; &#125;'","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://www.gulj.cn/tags/elasticsearch/"}]},{"title":"Linux服务管理","slug":"Linux服务管理","date":"2017-10-11T09:36:27.000Z","updated":"2019-02-14T07:07:12.862Z","comments":true,"path":"2017/10/11/Linux服务管理/","link":"","permalink":"http://www.gulj.cn/2017/10/11/Linux服务管理/","excerpt":"运行级别 运行级别 含义 0 关机 1 单用户模式，只要用于系统修复 2 不完全的命令行模式，不含NFS模式 3 完整的命令行模式，就是标准字符页面 4 系统保留 5 图形模式 6 重启","text":"运行级别 运行级别 含义 0 关机 1 单用户模式，只要用于系统修复 2 不完全的命令行模式，不含NFS模式 3 完整的命令行模式，就是标准字符页面 4 系统保留 5 图形模式 6 重启 查看及修改系统运行级别12345678910// 查看系统运行级别// N：NULL。当前级别为3即字符界面，其上一个级别为N即为空，表示系统开机直接进入字符界面# runlevelN 3 // 修改系统运行级别// 进入图形级别，前提是安装图形界面# init 5 // 若未安装图形界面则会报错# runlevel3 5 // 仍然进入了5级别 查看及修改系统默认的运行级别12# vim /etc/inittabid:3:initdefault: 注：不要把开机启动级别设置为0或6级别。 服务启动和自启动启动：就是在当前系统中让服务启动，并提供功能。 自启动：指让服务在系统开机或重启动之后，随着系统的启动而自动启动服务。 注：在chkconfig –list 查看到服务在不同运行级别时，服务自启动是否开启，不能确定现在服务是否已经开启。 查询已安装的服务①、RPM包安装的服务chkconfig –list命令查看服务自启动状态，可以看到所有RPM包安装的服务 ②、源码包安装的服务查看服务安装位置，一般是/usr/local/目录下service、chkconfig、ntsysv都不能找到源码包安装的服务。 两者区别：主要是安装位置的不同 源码包：一般安装在/usr/local/目录下RPM包：默认安装位置 RMP包服务管理常规的rpm包文件安装位置： 路径 作用 /etc/init.d/ 启动脚本位置 /etc/sysconfig/ 初始化环境配置文件位置 /etc/ 配置文件位置 /etc/xinetd.conf xinetd配置文件 /etc/xinetd.d 基于xinetd服务的启动脚本 /var/lib/ 服务产生的数据放在这里 /var/log/ 日志 RMP包服务管理——独立服务的管理①、独立服务的启动 法一：/etc/init.d/ 独立服务名 或者 /etc/rc.d/init.d/ 独立服务名 start|stop|status|restart| 1234567// 查看apache http服务的状态，其中httpd为一个shell脚本文件# /etc/init.d/httpd status// 启动apache服务# /etc/init.d/httpd start// 早期Linux版本服务管理脚本放在/etc/rc.d/init.d/目录# /etc/rc.d/init.d/httpd status 法二：service 独立服务名 start|stop|restart|status| 123# service httpd status// centos 7# systemctl [start/stop/status/restart] 独立服务名 备注：上面两种方法一般无法管理源码包启动脚本，但可以把源码包启动脚本放置在/etc/init.d/目录下统一管理 ②、独立服务的自启动 法一：chkconfig [ - - level 运行级别 ] 服务名 1234# chkconfig [--level 运行级别] [独立服务名] [on/off]例如：# chkconfig --level 2345 httpd on # chkconfig httpd off # --level 2345 可以省略，默认就是2345级别 法二：修改文件：/etc/rc.d/rc.local 或者 /etc/rc.local 文件 123# vi /etc/rc.local 或者 vi /etc/rc.d/rc.local// 然后在尾部添加一行，例如# /etc/init.d/httpd start # 开机apache服务就会自启动 法三：ntsysv 命令管理自启动（可管理独立服务，和基于xinetd服务） 备注 ①、/etc/rc.d/rc.local文件是在系统启动时，把所有的服务启动完，用户登录到系统前最后执行的文件，因此系统会执行这个文件中的命令 ②、/etc/rc.local文件是/etc/rc.d/rc.local文件的软连接 RMP包服务管理——基于xinetd服务的管理安装xinetd服务 1# yum -y install xinetd 基于xinetd服务的启动 1234567891011121314151617181920// 显示rsync服务的端口# grep rsync /etc/services# vim /etc/xinetd.d/rsyncservice rsync&#123; flags = REUSE // 设置TCP/IP socket可重用 socket_type = stream wait = no // 允许多个连接同时连接 user = root // 启动服务的用户为root server = /usr/bin/rsync server_args = --daemon log_on_failure += USERID // 登录失败后，记录用户的ID disable = no // 开启rsync服务，开启：no 关闭：yes&#125;// 重启动xinetd服务# service xinetd restart 或者# systemctl restart xinetd (centos 7) 基于xinetd服务的自启动 123# checkconfig time-stream on// ntsysv命令# ntsysv 备注 xinetd的服务：实际上自启动与启动完全同步，自启动关闭/开启，启动同时关闭/开启,启动关闭/开启，自启动同时关闭/开启 源码包服务管理①、源码包安装服务的启动使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不通，可以查看源码包的安装说明，查看启动脚本的方法 1# /usr/local/apache2/bin/apachectl start|stop ②、源码包安装服务的自启动通过修改/etc/rc.d/rc.local文件加入启动命令 1# vim /etc/rc.d/rc.local // 加入/usr/local/apache2/bin/apachectl start ③、让源码包服务被服务管理命令识别（chkconfig，ntsysv，service） 让源码包的apache服务能被service命令管理启动 12# ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache # 软链接# service apache start 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动 1234567891011vim /etc/init.d/apache // 在apache启动脚本中添加# chkconfig: 35 86 76 # 格式：chkconfig : 运行级别 启动顺序 关闭顺序# description: source package apache # description的内容随意// 把源码包apache加入chkconfig 命令# chkconfig --add apache# chkconfig --list |grep apache# apache 0:关闭 1:关闭 2:关闭 3:开启 4:关闭 5:开启 6:关闭// 这时，ntsysv命令也可以管理apache# ntsysv systemctlsystemctl命令将service和chkconfig命令结合在了一起。这样通过一个命令就可以实现两个命令的功能。(CentOS 7 和 Ubuntu可用) 格式： 12systemctl 动作 服务名.servicesystemctl start|stop|restart|status 服务名.service 设置开机启动： 1systemctl enable httpd.service 取消开机启动： 1systemctl disable httpd.service 系统操作 1234systemctl reboot 重启systemctl poweroff 关机systemctl suspend 睡眠systemctl hibernate 休眠 分析启动进程 1systemd-analyze 分析各进程启动的时间 1systemd-analyze blame 服务管理总结","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.gulj.cn/tags/linux/"}]},{"title":"Java设计模式—适配器模式","slug":"Java设计模式—适配器模式","date":"2017-09-28T03:31:50.000Z","updated":"2019-02-14T07:07:12.862Z","comments":true,"path":"2017/09/28/Java设计模式—适配器模式/","link":"","permalink":"http://www.gulj.cn/2017/09/28/Java设计模式—适配器模式/","excerpt":"介绍适配器模式将一个类的接口适配成用户所期待的。一个适配器通常允许因为接口不兼容而不能一起工作的类能够在一起工作，做法是将类自己的接口包裹在一个已存在的类中 结构 目标(Target)角色：这就是所期待得到的接口 源(Adapee)角色：现在需要适配的接口。 适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。","text":"介绍适配器模式将一个类的接口适配成用户所期待的。一个适配器通常允许因为接口不兼容而不能一起工作的类能够在一起工作，做法是将类自己的接口包裹在一个已存在的类中 结构 目标(Target)角色：这就是所期待得到的接口 源(Adapee)角色：现在需要适配的接口。 适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。 类适配器 采用继承的方式 12345678910111213141516// 适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。public class Adapter extends Adaptee implements Target &#123; /** * 1.目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request() * * 2.但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容 * * 3.所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已 */ @Override public void Request() &#123; this.SpecificRequest(); &#125;&#125; 对象适配器 采用对象组合方式 代码示例假设在我们的系统中有一个已经存在的方法（Adaptee可以实现一个接口，也可以是一个对象类） Adaptee 12345678910111213/** * 需要被适配的对象 */public class Adaptee &#123; /** * 已经存在的方法 */ public void specificRequest() &#123; // TODO 具体业务方法 &#125;&#125; 由于已经存在的接口不能满足我们的需求，现在我们定义一个我们期望的目标接口 Target 123456789/** * 目标接口 */public interface Target &#123; /** * 目标方法 */ void request();&#125; 定义适配器 Adapter ，进行适配 Adaptee 123456789101112131415161718192021222324/** * 适配器类 */public class Adapter implements Target &#123; /** * 持有需要被适配的接口对象 */ private Adaptee adaptee; /** * 传入需要被适配的对象 * @param adaptee */ public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void request() &#123; // 新接口中，调用的是已经存在的方法 adaptee.specificRequest(); &#125;&#125; 测试代码 1234567891011121314public class Client &#123; public static void main(String[] args) &#123; // 创建需要被适配的对象 Adaptee adaptee = new Adaptee(); // 创建客户端需要调用的接口对象 Target target = new Adapter(adaptee); // 表面上调用的是自己的新定义的接口，其内部实现还是原有的方法 target.request(); &#125;&#125; 缺省适配器 在任何时候，如果不准备实现一个接口的所有方法时，就可以使用“缺省适配模式”制造一个抽象类，给出所有方法的默认空实现。这样，从这个抽象类再继承下去的子类就不必实现所有的方法了 代码示例定义一个动物 Animal 行为的接口 1234567891011121314151617public interface Animal &#123; /** * 游泳 */ void swim(); /** * 睡觉 */ void sleep(); /** * 飞翔 */ void fly();&#125; 我们知道麻雀只能飞翔，睡觉，但是不能在水里游泳；如我我们直接定义一个麻雀（Bird）类直接去实现动物（Animal）这个接口，那么 Animal 中游泳的方法我们也必须去实现 (这是接口的特性所导致)，为了解决这个问题，我们定义一个抽象类作为适配器的角色来解决这个问题 适配器类 Adapter 12345678910111213141516public abstract class Adapter implements Animal &#123; @Override public void swim() &#123; // 空实现 &#125; @Override public void sleep() &#123; // 空实现 &#125; @Override public void fly() &#123; // 空实现 &#125;&#125; 接下来我们定义麻雀类（Bird） 我们不直接实现接口（Animal），而是继承我们定义的适配器类 Adapter 1234567891011public class Bird extends Adapter &#123; @Override public void sleep() &#123; // TODO 业务实现 &#125; @Override public void fly() &#123; // TODO 业务实现 &#125;&#125; 适配器模式使用注意事项 适配器模式中被适配的接口 Adaptee 和适配成为的接口 Target 是没有关联的，Adaptee 和 Target 中的方法既可以是相同的，也可以是不同的","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java设计模式—装饰器模式","slug":"Java设计模式-装饰器模式","date":"2017-09-27T01:42:22.000Z","updated":"2019-02-14T07:07:12.862Z","comments":true,"path":"2017/09/27/Java设计模式-装饰器模式/","link":"","permalink":"http://www.gulj.cn/2017/09/27/Java设计模式-装饰器模式/","excerpt":"1、介绍装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能 ①、要点： 不改变原类文件 不使用继承 动态扩展","text":"1、介绍装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能 ①、要点： 不改变原类文件 不使用继承 动态扩展 ②、使用场景： 扩展一个类的功能 动态增加功能，动态撤销 在不想增加很多子类的情况下扩展类。 ③、优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 2、类图（经典） 在装饰模式中的角色有： 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 类图的结构可以变化的地方： Component接口可以是接口也可以是抽象类，甚至是一个普通的父类（这个强烈不推荐，普通的类作为继承体系的超级父类不易于维护） 装饰器的抽象父类Decorator并不是必须的。 3、代码示例抽象构件角色 12345public interface Component &#123; void operation();&#125; 具体的接口实现类，也就是俗称的原始对象，或者说待装饰对象 12345678public class ConcreteComponent implements Component &#123; @Override public void operation() &#123; //TODO 相关的业务代码 &#125;&#125; 抽象装饰器父类，它主要是为装饰器定义了我们需要装饰的目标是什么，并对Component进行了基础的装饰 12345678910111213public class Decorator implements Component &#123; private Component component; public Decorator(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; component.operation(); &#125;&#125; 具体装饰角色 12345678910111213public class ConcreteDecoratorA extends Decorator &#123; public ConcreteDecoratorA(Component component) &#123; super(component); &#125; @Override public void operation() &#123; super.operation(); // TODO 相关的修饰业务代码 A &#125;&#125; 12345678910111213public class ConcreteDecoratorB extends Decorator &#123; public ConcreteDecoratorA(Component component) &#123; super(component); &#125; @Override public void operation() &#123; super.operation(); // TODO 相关的修饰业务代码 B &#125;&#125; 测试类 1234567891011121314151617181920public class TestDecoratorPattern &#123; public static void main(String[] args) &#123; //原来的对象 Component component = new ConcreteComponent(); //装饰成A Decorator concreteDecoratorA = new ConcreteDecoratorA(component); //装饰成A以后再装饰成B Decorator concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA); concreteDecoratorB.operation(); //简写方式 Decorator decorator = new ConcreteDecoratorA(new ConcreteDecoratorB(component)); decorator.operation(); &#125;&#125; 4、装饰模式的简化类图如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如下图所示: 如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。如下图所示：","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java设计模式—策略模式","slug":"Java设计模式-策略模式","date":"2017-09-26T05:45:07.000Z","updated":"2019-02-14T07:07:12.861Z","comments":true,"path":"2017/09/26/Java设计模式-策略模式/","link":"","permalink":"http://www.gulj.cn/2017/09/26/Java设计模式-策略模式/","excerpt":"1、介绍 策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 2、 类图","text":"1、介绍 策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 2、 类图 3、角色划分● 环境(Context)角色：持有一个Strategy的引用。 ● 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 ● 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 4、代码示例抽象策略类 Strategy.java 123456789public interface Strategy &#123; /** * 策略方法 * * @param os */ void strategy(String os);&#125; 具体策略类(实现策略接口，提供具体算法) ConcreteStrategyA.java 123456789101112131415public class ConcreteStrategyA implements Strategy &#123; /** * 策略方法实现 A * * @param os */ @Override public void strategy(String os) &#123; // 具体的业务方法 &#125;&#125; ConcreteStrategyB.java 1234567891011121314public class ConcreteStrategyB implements Strategy &#123; /** * 策略方法实现 B * * @param os */ @Override public void strategy(String os) &#123; // 具体的业务方法 &#125;&#125; Context.java 持有具体策略类的实例，负责调用具体算法 123456789101112131415161718public class Context &#123; // 策略的引用 private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 策略方法 */ public void action(String os) &#123; strategy.strategy(os); &#125;&#125; 测试类 123456789101112public class TestStrategyPattern &#123; public static void main(String[] args) &#123; Context context = new Context(new ConcreteStrategyA()); context.action(\"A\"); context = new Context(new ConcreteStrategyB()); context.action(\"B\"); &#125;&#125; 5、策略模式优缺点①、 优点 算法可以自由切换 避免使用多重条件判断 扩展性良好 ②、缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java设计模式—代理模式","slug":"Java设计模式—代理模式","date":"2017-09-20T07:54:23.000Z","updated":"2019-02-14T07:07:12.862Z","comments":true,"path":"2017/09/20/Java设计模式—代理模式/","link":"","permalink":"http://www.gulj.cn/2017/09/20/Java设计模式—代理模式/","excerpt":"为什么使用代理我们在写一个功能函数时，经常需要在其中写入与功能不是直接相关但很有必要的代 码，如日志记录，信息发送，安全和事务支持等，这些枝节性代码虽然是必要的，但它会带来以下麻烦： 枝节性代码游离在功能性代码之外，它不是函数的目的，这是对OO是一种破坏 枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合，可重用性降低 从法理上说，枝节性代码应该监视着功能性代码，然后采取行动，而不是功能性代码通知枝节性代码采取行动，这好比吟游诗人应该是主动记录骑士的功绩而不是骑士主动要求诗人记录自己的功绩","text":"为什么使用代理我们在写一个功能函数时，经常需要在其中写入与功能不是直接相关但很有必要的代 码，如日志记录，信息发送，安全和事务支持等，这些枝节性代码虽然是必要的，但它会带来以下麻烦： 枝节性代码游离在功能性代码之外，它不是函数的目的，这是对OO是一种破坏 枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合，可重用性降低 从法理上说，枝节性代码应该监视着功能性代码，然后采取行动，而不是功能性代码通知枝节性代码采取行动，这好比吟游诗人应该是主动记录骑士的功绩而不是骑士主动要求诗人记录自己的功绩 定义代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能. 代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象 1、静态代理静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类. 下面举个案例来解释:模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.需要注意的是,代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法 代码示例 接口:IUserDao.java 123public interface IUserDao &#123; void save();&#125; 目标对象类:UserDao.java 12345public class UserDao implements IUserDao &#123; public void save() &#123; System.out.println(\"----已经保存数据!----\"); &#125;&#125; 代理对象:UserDaoProxy.java 12345678910111213public class UserDaoProxy implements IUserDao&#123; //接收保存目标对象 private IUserDao target; public UserDaoProxy(IUserDao target)&#123; this.target=target; &#125; public void save() &#123; System.out.println(\"开始事务...\"); target.save();//执行目标对象的方法 System.out.println(\"提交事务...\"); &#125;&#125; 测试类:App.java 1234567891011public class App &#123; public static void main(String[] args) &#123; //目标对象 UserDao target = new UserDao(); //代理对象,把目标对象传给代理对象,建立代理关系 UserDaoProxy proxy = new UserDaoProxy(target); proxy.save();//执行的是代理的方法 &#125;&#125; 静态代理总结 可以做到在不修改目标对象的功能前提下,对目标功能扩展. 缺点: 代理类和委托类实现相同的接口，同时要实现相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 2、动态代理动态代理有以下特点:​ ①、代理对象,不需要实现接口​ ②、代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)​ ③、动态代理也叫做:JDK代理,接口代理 JDK中生成代理对象的API： 代理类所在包:java.lang.reflect.Proxy JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是: 1static Object newProxyInstance(ClassLoader loader, Class [] interfaces, InvocationHandler handler) 注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为: ClassLoader loader:指定当前目标对象使用类加载器,用null表示默认类加载器 Class [] interfaces:需要实现的接口数组 InvocationHandler handler:调用处理器,执行目标对象的方法时,会触发调用处理器的方法,从而把当前执行目标对象的方法作为参数传入 代码示例: 接口类IUserDao.java以及接口实现类UserDao是一样的.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类中先建立目标对象和代理对象的联系,然后使用代理对象中的同名方法 1）、JDK动态代理 代理工厂类:ProxyFactory.java 1234567891011121314151617181920public class ProxyFactory &#123; //维护目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象生成代理对象 public Object getProxyInstance1() &#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), (Object proxy, Method method, Object[] args) -&gt; &#123; System.out.println(\"开始事务2\"); //执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(\"提交事务2\"); return returnValue; &#125;); &#125; &#125; 测试类:App.java 123456789101112131415161718/** * 测试类*/public class App &#123;public static void main(String[] args) &#123; // 目标对象 IUserDao target = new UserDao(); // 【原始的类型】 System.out.println(target.getClass()); // 给目标对象，创建代理对象 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); // com.sun.proxy.$Proxy0 内存中动态生成的代理对象 System.out.println(proxy.getClass()); // 执行方法 【代理对象】 proxy.save(); &#125;&#125; JDK动态代理总结: 代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理 Cglib代理 上面的静态代理和动态代理模式都是要求目标对象实现一个接口或者多个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用构建目标对象子类的方式实现代理,这种方法就叫做:Cglib代理 Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展. Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截) Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的子类. 代理的类不能为final,否则报错；目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法 代码示例:目标对象类:UserDao.java 123456789/** * 目标对象,没有实现任何接口 */public class UserDao &#123; public void save() &#123; System.out.println(\"----已经保存数据!----\"); &#125;&#125; Cglib代理工厂:ProxyFactory.java 123456789101112131415161718192021222324252627282930313233/** * Cglib子类代理工厂 * 对UserDao在内存中动态构建一个子类对象*/public class ProxyFactory implements MethodInterceptor&#123; //维护目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(target.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(\"开始事务...\"); //执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(\"提交事务...\"); return returnValue; &#125;&#125; 测试类: 12345678910111213141516/** * 测试类 */public class App &#123; @Test public void test()&#123; //目标对象 UserDao target = new UserDao(); //代理对象 UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance(); //执行代理对象的方法 proxy.save(); &#125;&#125; 在Spring的AOP编程中:如果加入容器的目标对象有实现接口,用JDK代理如果目标对象没有实现接口,用Cglib代理","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java设计模式—模板方法模式","slug":"JAVA设计模式—模板方法模式","date":"2017-09-19T05:27:12.000Z","updated":"2019-02-14T07:07:12.860Z","comments":true,"path":"2017/09/19/JAVA设计模式—模板方法模式/","link":"","permalink":"http://www.gulj.cn/2017/09/19/JAVA设计模式—模板方法模式/","excerpt":"1、介绍模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。","text":"1、介绍模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。 2、结构①、模板方法模式结构可以分为两个角色：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;抽象模板(Abstract Template)角色&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;具体模板(Concrete Template)角色②、模板方法模式的静态结构图如下所示： 这里涉及到两个角色：抽象模板(Abstract Template)角色职责： 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色职责： 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 3、代码示例抽象模板角色类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 抽象模板类 * * @author gulj * @create 2017-09-08 下午2:48 **/public abstract class AbstractTemplate &#123; /** * 模板方法（定义模板的算法，整体骨架，业务方法由具体子类实现） * * @param params * @return */ public final String templateMethod(String params) &#123;//核心的模板方法，不允许子类覆盖 long startTime = System.currentTimeMillis();//模板方法，统一的模板 /** * 具体的业务方法，可以有以下三种方式 */ System.out.println(\"---------------------------\"); // ①、需要所有子类实现各自的业务逻辑 String result = abstractMethod(params); // ②、本类已经实现的方法 concreteMethod(); // ③、需要的子类可以重写 hookMethod(); System.out.println(\"---------------------------\"); long endTime = System.currentTimeMillis();//模板方法，统一的模板 System.out.println(\"耗时时间：\" + (endTime - startTime)); return result; &#125; /** * 抽象方法，供子类具体实现，定义为protected，可以只保证子类来实现，外界不允许调用 * * @param params * @return */ protected abstract String abstractMethod(String... params); /** * 基本方法（已经实现） */ private final String concreteMethod() &#123; System.out.println(\"concreteMethod : 模板类实现已经实现的放方法\"); return null; &#125; /** * 基本方法(空方法) */ protected void hookMethod() &#123; /** * 我们可以定义一个空方法，这样可以保证不是所有子类都需要重写该方法 */ System.out.println(\"hookMethod : 模板类的空方法，可供某些子类进行重写\"); &#125;&#125; 具体模板角色类 123456789101112131415161718192021/** * 具体模板角色类 * * @author gulj * @create 2017-09-08 下午3:25 **/public class ConcreteTemplate extends AbstractTemplate &#123; /** * 重写父类的抽象方法 * * @param params * @return */ @Override protected String abstractMethod(String... params) &#123; System.out.println(\"abstractMethod : 子类实现模板类中的抽象方法\"); return null; &#125;&#125; 测试代码 12345678910111213141516171819202122232425262728/** * @author gulj * @create 2017-09-08 下午3:29 **/public class TestTemplateDesignMain &#123; public static void main(String[] args) &#123; //子类实例 ConcreteTemplate concreteTemplate = new ConcreteTemplate(); //调用弗父类的模板方法 concreteTemplate.templateMethod(\"\"); /** * 测试结果 * --------------------------- abstractMethod : 子类实现模板类中的抽象方法 concreteMethod : 模板类实现已经实现的放方法 hookMethod : 模板类的空方法，可供某些子类进行重写 --------------------------- 耗时时间：1 */ &#125;&#125; 4、说明模板方法中的方法可以分为两大类：模板方法和基本方法。 ①、模板方法 一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。 一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 ②、基本方法 基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。 抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换，如代码示例中的：concreteMethod()方法。 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现，如代码示例中的：hookMethod()方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"java设计模式-单例模式","slug":"java设计模式-单例模式","date":"2017-09-18T09:43:24.000Z","updated":"2019-02-14T07:07:12.866Z","comments":true,"path":"2017/09/18/java设计模式-单例模式/","link":"","permalink":"http://www.gulj.cn/2017/09/18/java设计模式-单例模式/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"java设计模式-建造者模式","slug":"java设计模式-建造者模式","date":"2017-09-17T10:43:13.000Z","updated":"2019-02-14T07:07:12.866Z","comments":true,"path":"2017/09/17/java设计模式-建造者模式/","link":"","permalink":"http://www.gulj.cn/2017/09/17/java设计模式-建造者模式/","excerpt":"介绍建造者模式（英：Builder Pattern）是一种创建型设计模式，又名：生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)。 结构","text":"介绍建造者模式（英：Builder Pattern）是一种创建型设计模式，又名：生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)。 结构 抽象建造者（Builder）角色: 可以是一个接口或者抽象类，主要用于规范产品对象的各个组成成分的建造 具体建造者（ConcreteBuilder）角色: 实现抽象建造者Builder所声明的接口 提供产品实例，用户构建产品 导演者（Director）角色: 调用具体建造者角色以创建产品对象 产品（Product）角色: 最终构建成具体产品 导演者角色是与客户端打交道的角色。导演者将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体建造者角色。具体建造者角色是做具体建造工作的，但是却不为客户端所知 代码示例产品 Product 123456789101112public class Product &#123; private String partA; private String partB; private String partC; // .......省去 get set 方法 ......&#125; 抽象建造者 Builder 123456789101112131415161718public interface Builder &#123; /** * 定义构造产品 A 部件 */ void buildPartA(); /** * 定义构造产品 B 部件 */ void buildPartB(); /** * 定义构造产品 C 部件 */ void buildPartC();&#125; 具体建造者 ConcreteBuilder 12345678910111213141516171819202122232425262728293031323334353637public class ConcreteBuilder implements Builder &#123; // 创建一个产品的实例 Product product = new Product(); /** * 具体实现构建产品的 A 部件 */ @Override public void buildPartA() &#123; product.setPartA(); &#125; /** * 具体实现构建产品的 B 部件 */ @Override public void buildPartB() &#123; product.setPartB(); &#125; /** * 具体实现构建产品的 C 部件 */ @Override public void buildPartC() &#123; product.setPartC(); &#125; /** * 返回构建的产品 * @return */ public Product getProduct() &#123; return product; &#125;&#125; 导演者 Director 1234567891011121314151617181920212223public class Director &#123; // 建造器对象 private Builder builder; // 通过构造函数传入 public Director(Builder builder) &#123; this.builder = builder; &#125; /** * 负责调用构建产品的各个方法 */ public void construct() &#123; builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); &#125;&#125; 测试代码 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); // 构造产品 director.construct(); // 获取构造后的产品 Product product = builder.getProduct(); &#125;&#125; 使用Builder模式来构建复杂对象 遇到多个构造器参数时要考虑用构建器 若User类，只有姓名(name) 和 手机号(phone) 是必选参数，其它都是可选参数，如果此刻我们不同的业务需要构建不同参数的User对象，我们可以使用不同参数的构造函数，那么我们的类中是这样 使用构造函数方式构造对象的User类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class User &#123; /** * 姓名 */ private String name; /** * 手机号 */ private String phone; /** * 邮件 */ private String email; /** * 年龄 */ private int age; /** * 出生日期 */ private Date birthDay; public User() &#123; &#125; /** * 必选参数的构造器 * * @param name * @param phone */ public User(String name, String phone) &#123; this.name = name; this.phone = phone; &#125; /** * 含有可选参数的构造器 * * @param name * @param phone * @param email */ public User(String name, String phone, String email) &#123; this.name = name; this.phone = phone; this.email = email; &#125; /** * 含有可选参数的构造器 * * @param name * @param phone * @param email */ public User(String name, String phone, String email, int age) &#123; this.name = name; this.phone = phone; this.email = email; this.age = age; &#125; /** * 含有可选参数的构造器 * * @param name * @param phone * @param email */ public User(String name, String phone, String email, int age, Date birthDay) &#123; this.name = name; this.phone = phone; this.email = email; this.age = age; this.birthDay = birthDay; &#125;&#125; 测试代码1234567891011121314public class Cient &#123; public static void main(String[] args) &#123; User user1 = new User(\"admin\",\"110\"); User user2 = new User(\"admin\",\"110\",\"110@gmail.com\"); User user3 = new User(\"admin\",\"110\",\"110@gmail.com\",110); &#125; &#125; 使用建造者模式来构建对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class User &#123; /** * 姓名 */ private String name; /** * 手机号 */ private String phone; /** * 邮件 */ private String email; /** * 年龄 */ private int age; /** * 出生日期 */ private Date birthDay; // 私有构造方法 private User(UserBuilder builder) &#123; this.name = builder.name; this.phone = builder.phone; this.email = builder.email; this.age = builder.age; this.birthDay = builder.birthDay; &#125; public static class UserBuilder &#123; // required (必须) private String name; private String phone; // optional (可选) private String email; private int age; private Date birthDay; /** * 构造方法，传入必须的参数 * * @param name * @param phone */ public UserBuilder(String name, String phone) &#123; this.name = name; this.phone = phone; &#125; /** * 构造可选参数 email * * @param email * @return */ public UserBuilder setEmail(String email) &#123; this.email = email; return this; &#125; /** * 构建可选参数 age * * @param age * @return */ public UserBuilder setAge(int age) &#123; this.age = age; return this; &#125; /** * 构建可选参数 birthDay * * @param birthDay * @return */ public UserBuilder setBirthDay(Date birthDay) &#123; this.birthDay = birthDay; return this; &#125; /** * 构建 User 对象并返回 * * @return */ public User build() &#123; return new User(this); &#125; &#125;&#125; 测试代码123456789101112public class Cient &#123; public static void main(String[] args) &#123; User user = new User.UserBuilder(\"admin\",\"110\") .setAge(100) .setEmail(\"110@gmail.com\") .build(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java静态代码块，构造代码块，构造函数","slug":"Java-静态代码块，构造块，构造函数","date":"2017-09-12T06:17:00.000Z","updated":"2019-02-14T07:07:12.861Z","comments":true,"path":"2017/09/12/Java-静态代码块，构造块，构造函数/","link":"","permalink":"http://www.gulj.cn/2017/09/12/Java-静态代码块，构造块，构造函数/","excerpt":"1、介绍①、构造函数 123pubic HelloWorld()&#123; &#125; 说明 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的。 构造函数的作用是用于给对象进行初始化。 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。","text":"1、介绍①、构造函数 123pubic HelloWorld()&#123; &#125; 说明 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的。 构造函数的作用是用于给对象进行初始化。 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。 ②、构造代码块 123&#123; // 构造代码块&#125; 说明 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的 构造函数的作用是用于给对象进行初始化 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次 ③、静态代码块 123static &#123; // 静态代码块&#125; 说明 它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的 静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。 静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。 一个类中可以有多个静态代码块 2、三者执行顺序1、静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。 三者的执行顺序应该为：静态代码块 &gt; main() &gt; 构造代码块 &gt; 构造函数。 3、代码示例①、普通类初始化 123456789101112131415161718192021public class HelloWorld &#123; public HelloWorld() &#123; System.out.println(\"helloWorld 构造函数.....\"); &#125; &#123; System.out.println(\"普通代码块......\"); &#125; static &#123; System.out.println(\"静态代码块\"); System.out.println(\"--------------------\"); &#125; public static void main(String[] args) &#123; HelloWorld A = new HelloWorld(); System.out.println(\"*******************\"); HelloWorld B = new HelloWorld(); &#125;&#125; 执行结果 1234567静态代码块--------------------普通代码块......helloWorld 构造函数.....*******************普通代码块......helloWorld 构造函数..... ②、继承体系初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class HelloWorld &#123; public static String name = \"父类:HelloWorld——&gt;静态变量\"; public HelloWorld() &#123; System.out.println(\"父类:HelloWorld——&gt;构造函数.....\"); &#125; &#123; System.out.println(\"父类:HelloWorld——&gt;普通代码块......\"); &#125; static &#123; System.out.println(name); System.out.println(\"父类:HelloWorld——&gt;静态代码块\"); &#125;&#125;public class ChildHelloWorld extends HelloWorld &#123; private static String childName = \"子类:ChildHelloWord——&gt;静态变量\"; public ChildHelloWorld() &#123; System.out.println(\"子类:ChildHelloWorld——&gt;构造函数.....\"); &#125; &#123; System.out.println(\"子类:ChildHelloWorld——&gt;普通代码块......\"); &#125; static &#123; System.out.println(childName); System.out.println(\"子类:ChildHelloWorld——&gt;静态代码块......\"); &#125; public static void main(String[] args) &#123; System.out.println(\"子类:main()方法.....\"); new ChildHelloWorld(); &#125;&#125; 执行结果 123456789父类:HelloWorld——&gt;静态变量父类:HelloWorld——&gt;静态代码块子类:ChildHelloWord——&gt;静态变量子类:ChildHelloWorld——&gt;静态代码块......子类:main()方法.....父类:HelloWorld——&gt;普通代码块......父类:HelloWorld——&gt;构造函数.....子类:ChildHelloWorld——&gt;普通代码块......子类:ChildHelloWorld——&gt;构造函数..... Java 初始化顺序图","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.gulj.cn/tags/java/"}]},{"title":"JAVA三大特性—多态","slug":"JAVA三大特性—多态","date":"2017-09-12T03:13:27.000Z","updated":"2019-02-14T07:07:12.860Z","comments":true,"path":"2017/09/12/JAVA三大特性—多态/","link":"","permalink":"http://www.gulj.cn/2017/09/12/JAVA三大特性—多态/","excerpt":"1、介绍 多态是同一个行为具有多个不同表现形式或形态的能力 多态就是同一个接口，使用不同的实例而执行不同操作 多态性是对象多种表现形式的体现。 2、多态存在的必要条件","text":"1、介绍 多态是同一个行为具有多个不同表现形式或形态的能力 多态就是同一个接口，使用不同的实例而执行不同操作 多态性是对象多种表现形式的体现。 2、多态存在的必要条件 继承 子类重写父类方法 父类引用指向子类对象 比如： 1Parent parent = new Child(); // 使用父类类型的引用指向子类的对象 3、代码示例①、基于继承实现的多态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Animal &#123; public String name = \"animal\"; public void eat(Animal animal)&#123; System.out.println(\"animal say ......\"); &#125; public void sleep()&#123; System.out.println(\"animal sleep......\"); &#125; public static void speak()&#123; System.out.println(\"animal speak .......\"); &#125;&#125;public class Cat extends Animal &#123; /** * 重写父类的eat()方法 * * @param animal */ @Override public void eat(Animal animal) &#123; System.out.println(\"****************************************\"); if (animal instanceof Animal) &#123; System.out.println(\"animal is instanceof Animal.....\"); &#125; if (animal instanceof Cat) &#123; System.out.println(\"animal is instanceof Cat.....\"); &#125; if (animal instanceof Dog) &#123; System.out.println(\"animal is instanceof Dog.....\"); &#125; if (animal instanceof Object) &#123; System.out.println(\"animal is instanceof Object.....\"); &#125; System.out.println(animal + \" say .......\"); System.out.println(\"****************************************\"); &#125;&#125;public class Dog extends Animal &#123; public String name = \"dog\"; /** * 重写父类的sleep()方法 */ @Override public void sleep() &#123; System.out.println(\"dog sleep......\"); &#125; public static void speak() &#123; System.out.println(\"dog speak .......\"); &#125;&#125;//测试案例public class TestMain &#123; public static void main(String[] args) &#123; Animal animal1 = new Cat(); //父类的引用，根据传入不同的子类实例，在运行期间会表现出具体子类的特征 animal1.eat(new Cat()); animal1.eat(new Dog()); Animal animal2 = new Dog(); animal2.sleep(); // 非静态方法，JVM调用的是具体子类的sleep(Dog)的方法 animal2.speak(); // 静态方法不能被重写，仍然调用的是父类的speak方法 System.out.println(animal2.name); //字段不具有多态性，仍然是父类的属性值 &#125;&#125; 测试结果 1234567891011121314151617// animal 对象体现的多态性，是 Animal,Dog,Object的实例****************************************animal is instanceof Animal.....animal is instanceof Cat.....animal is instanceof Object.....com.gulj.springbootvalidator.duotai.Cat@378bf509 say .......********************************************************************************animal is instanceof Animal.....animal is instanceof Dog.....animal is instanceof Object..... com.gulj.springbootvalidator.duotai.Dog@5fd0d5ae say .......****************************************dog sleep......animal speak ....... 总结说明 对象具有两种类型： 编译类型（编译类型必须是运行类型的父类或相同） 运行类型 在形式上，类定义的对象只能看到自己所属类中的成员。父类对象无法看到子类的新扩充方法。 父类被关键词static修饰的静态方法是不能被子类覆盖的，可以利用这一特性达到隐藏的效果 使用父类类型的引用指向子类的对象 当子类和父类存在相同的字段时候，无论修饰符是什么，都会在各自的内存空间中存储数据，则字段不具有多态性 如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法 12// final修饰的对象不能改变其值；只能指向animal这个地址（引用关系不能变）但是对象里面的值可以改变。final Animal animal = new Cat(); ②、基于接口实现的多态（不在举例，读者可以自行实现） 在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.gulj.cn/tags/java/"}]},{"title":"Java内部类—匿名内部类","slug":"Java-内部类之匿名内部类","date":"2017-09-11T06:19:43.000Z","updated":"2019-02-14T07:07:12.861Z","comments":true,"path":"2017/09/11/Java-内部类之匿名内部类/","link":"","permalink":"http://www.gulj.cn/2017/09/11/Java-内部类之匿名内部类/","excerpt":"1、介绍①、匿名内部类是没有名字的内部类，因为没有名字所以没办法引用。必须在创建时，作为 new 语句的一部分来声明，只能使用一次 ②、使用前提：必须继承一个父类或实现一个接口 2、结构","text":"1、介绍①、匿名内部类是没有名字的内部类，因为没有名字所以没办法引用。必须在创建时，作为 new 语句的一部分来声明，只能使用一次 ②、使用前提：必须继承一个父类或实现一个接口 2、结构 ①、匿名内部类形式如下： new 类或接口{ ​ //方法主体 } 3、代码示例①、原始抽象类的基本实现 123456789101112131415161718192021222324public abstract class Animal &#123; /** * 动物有吃的行为 */ public abstract void eat();&#125;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼。。。。\"); &#125;&#125;public class TestCatMain &#123; public static void main(String[] args) &#123; Animal animal = new Cat(); animal.eat(); &#125;&#125; 备注： ​ 如果此处的Cat类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？这个时候就引入了匿名内部类 ②、在抽象类中使用内部类 1234567891011121314151617181920212223public abstract class Animal &#123; /** * 动物有吃的行为 */ public abstract void eat();&#125;public class TestAnonymousInnerClassCatMain &#123; public static void main(String[] args) &#123; Animal animal = new Animal() &#123;//直接将抽象类Animal中的方法在大括号中实现了 @Override public void eat() &#123; System.out.println(\"在chou。。。。\"); &#125; &#125;; animal.eat(); &#125;&#125; ③、在接口上使用匿名内部类 12345678910111213141516171819202122//接口定义public interface IAnimal &#123; /** * 动物有吃的行为 */ void eat();&#125;//测试匿名内部类public class TestAnonymousInnerClassCatMain &#123; public static void main(String[] args) &#123; IAnimal iAnimal = new IAnimal() &#123; @Override public void eat() &#123; System.out.println(\"在接口中使用的匿名内部类。。。。\"); &#125; &#125;; iAnimal.eat(); &#125;&#125; 总结 匿名内部类不能有构造方法，但可以调用父类的构造方法。 匿名内部类不能定义任何静态成员，方法和类。 一般使用代码块为匿名内部类提供初始化工作","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.gulj.cn/tags/java/"}]},{"title":"shell编程—条件表达式","slug":"shell编程之条件表达式","date":"2017-09-01T01:32:39.000Z","updated":"2019-02-14T07:07:13.521Z","comments":true,"path":"2017/09/01/shell编程之条件表达式/","link":"","permalink":"http://www.gulj.cn/2017/09/01/shell编程之条件表达式/","excerpt":"1、字符串操作符比较 常用字符串测试操作符 说明 -z “字符串” 若串长度为0则真，-z可以理解为zero -n “字符串” 若串长度不为0则真，-n可以理解成no zero “串 1” = “串2” 若串1等于串2则真，可使用“==” 代替“=“ “串 1” != “串2” 若串1不等于串2则真，可使用“!==” 代替“!=“","text":"1、字符串操作符比较 常用字符串测试操作符 说明 -z “字符串” 若串长度为0则真，-z可以理解为zero -n “字符串” 若串长度不为0则真，-n可以理解成no zero “串 1” = “串2” 若串1等于串2则真，可使用“==” 代替“=“ “串 1” != “串2” 若串1不等于串2则真，可使用“!==” 代替“!=“ 注意： ①、以上表格中的字符串测试操作符好务必使用”“引起来（字符串或字符串变量比较都要加双引号之后再比较） ②、比较符号两端有空格（字符串或字符串变量比较，比较符号两端最好有空格） 代码示例： 123# 字符串比较[root@docker-02 ~]# [ -z \"abc\" ] &amp;&amp; echo 1 || echo 00 2、整数二元比较操作符 在[]以及test中使用的比较符 在(())和[[]]中使用的比较符 说明 -eq == 或 = equal 的缩写，相等 -ne != not equal 的缩写，不相等 -gt &gt; 大于 greater than -ge &gt;= 大于等于 greater equal -lt &lt; 小于 类似 less than -le &lt;= 小于等于 less equal 代码示例： 123456789#[root@docker-02 ~]# [ 2 -eq 1 ] &amp;&amp; echo 1 || echo 00#[root@docker-02 ~]# [ 2 -eq 2 ] &amp;&amp; echo 1 || echo 01#[root@docker-02 ~]# ((2&gt;3)) &amp;&amp; echo 1 || echo 00 小结：整数比较笔者推荐下面用法 ①、[ $num1 -eq $num2 ] # 注意空格，和比较符号 ②、(($num1&gt;$num2)) # 无需空格，常规数学比较符号 3、逻辑连接符 在[]和test中使用的逻辑操作符 在[[]]中使用的逻辑操作符 说明 -a &amp;&amp; and与，两端都为真，则真 -o or或，两端有一个为真则真 ! ! not非，相反则为真 代码示例： 12345#a=1b=2[root@docker-02 ~]# [ $a -eq 1 -a $b -eq 2 ] &amp;&amp; echo 1 || echo 01 小结：①、-a 和 &amp;&amp; 的运算规则：只有两端都是1才是真 ②、[] 中用-a、-o、！ ③、[[]] 中用&amp;&amp;、||、！","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://www.gulj.cn/tags/shell/"}]},{"title":"Adobe Photoshop CC 2017 Mac中文破解版","slug":"Adobe-Photoshop-CC-2017-Mac中文破解版","date":"2017-08-22T09:26:06.000Z","updated":"2019-02-14T07:07:12.858Z","comments":true,"path":"2017/08/22/Adobe-Photoshop-CC-2017-Mac中文破解版/","link":"","permalink":"http://www.gulj.cn/2017/08/22/Adobe-Photoshop-CC-2017-Mac中文破解版/","excerpt":"Photoshop CC 2017是一个全新的版本，拥有很多新的特性，比如：应用程式内搜寻、加快上手速度、增强属性面板、Creative Cloud Assets改良功能等等，总之功能更加的强大。","text":"Photoshop CC 2017是一个全新的版本，拥有很多新的特性，比如：应用程式内搜寻、加快上手速度、增强属性面板、Creative Cloud Assets改良功能等等，总之功能更加的强大。 1、破解安装方法①、打开dmg镜像，双击“Install”进行安装，登陆Adobe ID（没有注册一个）完成安装； ②、解压缩“Adobe Zii cc2017.zip”，双击“Adobe Zii.app”，点击“PATCH OR DRAG”后提示“COMPLETED”完成破解；（如果之前安装了其他旧版本的Adobe软件，这里建议拖拽“PS CC 2017.app”到破解补丁中的“PATCH OR DRAG”上，否则会导致旧版本崩溃！) 2、下载地址 ①、Adobe Photoshop CC 2017 Mac中文版下载 密码：cthe ②、Adobe Zii 2.2 破解补丁下载 备注: 1、安装Adobe系列的软件时显示文件破坏或者文件不全的解决方案：大家到Adobe文件中右键程序显示包内容—Contents—MacOS里直接双击“Install”即可 2、如果大家需要切换中、英文语言，可以到“首选项”—“界面…”—“文本”—“用户界面语言”中选择，重启生效！ 3、系统版本要求：OS X 10.10 或更高。","categories":[{"name":"工具","slug":"工具","permalink":"http://www.gulj.cn/categories/工具/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.gulj.cn/tags/mac/"}]},{"title":"Frp 的介绍使用与安装","slug":"Frp-的介绍使用与安装","date":"2017-08-20T10:53:05.000Z","updated":"2019-02-14T07:07:12.860Z","comments":true,"path":"2017/08/20/Frp-的介绍使用与安装/","link":"","permalink":"http://www.gulj.cn/2017/08/20/Frp-的介绍使用与安装/","excerpt":"1、frp 介绍 frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 2、frp 作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。","text":"1、frp 介绍 frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 2、frp 作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。 3、frp 安装( server 端 ) frp : 分为Server端和Client端 请根据自己的机器系统分别下载最新稳定的Frp版本 例如： 服务端是Linux系统， 则下载Linx系统对应的版本：frp_0.13.0_linux_amd64.tar.gz 客户端是Osx系统，则下载Osx系统对应的版本：frp_0.13.0_darwin_amd64.tar.gz Frp下载地址：frp release 各种版本下载 Server 端 ①、安装与配置修改 frps.ini 文件，这里使用了最简化的配置： [common] bind_port = 7000 # 与客户端通信接口 建议保持不变 dashboard_port = 7001 # dashboard 端口 控制台界面端口 自定义 dashboard_user = test # dashboard 控制台界面 用户名 自定义 dashboard_pwd = test # dashboard 控制台界面 密码 自定义 privilege_token = token # 权限token 自定义 ②、启动nohup ./frps -c ./frps.ini &amp; Client 端 ①、安装与配置修改 frpc.ini 文件，假设 frps 所在服务器的公网 IP 为 x.x.x.x [common] server_addr = x.x.x.x # 服务器的公网Ip server_port = 7000 # 与服务端的 bind_port 值 保持一致 dashboard_user = test # 与服务端的 dashboard_user 值 保持一致 dashboard_pwd = test # 与服务端的 dashboard_pwd 值 保持一致 privilege_token = token # 与服务端的 privilege_token 值 保持一致 [ssh] type = tcp # 采取Tcp协议 local_ip = 127.0.0.1 # 本地地址 local_port = 8083 # 映射的本地端口 remote_port = 6000 # 与服务端连接端口 备注： 12345678nginx 配置server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://服务器IP:6000; &#125; &#125; 简易流程图如下： ②、启动nohup ./frpc -c ./frpc.ini &amp;","categories":[{"name":"工具","slug":"工具","permalink":"http://www.gulj.cn/categories/工具/"}],"tags":[{"name":"frp","slug":"frp","permalink":"http://www.gulj.cn/tags/frp/"}]},{"title":"使用 ShadowSocks 在 VPS 上搭建 VPN","slug":"使用-ShadowSocks-在-VPS-上搭建-VPN","date":"2017-08-16T08:45:56.000Z","updated":"2019-02-14T07:07:13.522Z","comments":true,"path":"2017/08/16/使用-ShadowSocks-在-VPS-上搭建-VPN/","link":"","permalink":"http://www.gulj.cn/2017/08/16/使用-ShadowSocks-在-VPS-上搭建-VPN/","excerpt":"&nbsp;&nbsp;&nbsp;我们都使用过很多免费的VPN工具，比如蓝灯，但是使用效果并不是很理想，而且有流量限制。有的人也使用过一些收费的VPN，比如：Astrill，鱼摆摆等等。虽然价格并不是很高，但是还是有一定的费用，而且有的还有多用户限制。总之不管收费的，免费的，或多或少我们在使用的过程中有些不爽，今天笔者为大家带来在自己的VPS上搭建一套VPN，想怎么用就怎么用，话不多说，直奔主题。","text":"&nbsp;&nbsp;&nbsp;我们都使用过很多免费的VPN工具，比如蓝灯，但是使用效果并不是很理想，而且有流量限制。有的人也使用过一些收费的VPN，比如：Astrill，鱼摆摆等等。虽然价格并不是很高，但是还是有一定的费用，而且有的还有多用户限制。总之不管收费的，免费的，或多或少我们在使用的过程中有些不爽，今天笔者为大家带来在自己的VPS上搭建一套VPN，想怎么用就怎么用，话不多说，直奔主题。 本文以VPS（Centos7）为例子假设你已经有一台VPS，公网IP为：46.18.171.153 如果没有笔者可以推荐购买Linode，vultr，阿里云（国内版，国际版【阿里云国际版有点小麻烦哦，改天笔者可以写一篇，分享给大家】） 1、在VPS上安装 shadowsocks-libev（ Server 端 ）①、获取 shadowsocks-libev 源代码123git clone https://github.com/shadowsocks/shadowsocks-libev.gitcd shadowsocks-libevgit submodule update --init --recursive ②、对源码进行构建12yum install epel-release -yyum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto udns-devel libev-devel libsodium-devel mbedtls-devel -y ③、下载yum源，并配置放入在 /etc/yum.repos.d/ 目录下 下载地址： shadowsocks repo ④、安装 shadowsocks-libev12su -c 'yum update'su -c 'yum install shadowsocks-libev' ④、测试 shadowsocks-libev 是否正确安装在终端输入：ss 命令，按Tab键看到以下，说明安装成功 123[root@izt4nax70m2dsl3yoh6uxlz ~]# ssss ssh ssh-agent sshd ssh-keygen ss-local ss-manager ss-redir ss-tunnelsserver ssh-add ssh-copy-id sshd-keygen ssh-keyscan ssltap ss-nat ss-server ⑤、配置 shadowsocks-libev，编辑 /etc/shadowsocks-libev/config.json 文件12345678&#123; \"server\":\"0.0.0.0\", # 监听所有的端口 \"server_port\":2020, # 指定server端口，自定义 \"local_port\":1080, # 指定本地端口，默认 \"password\":\"xxx\", # 配置密码 \"timeout\":60, \"method\":\"rc4-md5\" # 加密方式 &#125; ⑥、启动 shadowsocks-libev启动: 1nuhup ss-server &amp; # 后台启动 查看是否成功启动:123[root@izt4nax70m2dsl3yoh6uxlz ~]# ps -ef | grep ss-serverroot 14046 1 0 Aug10 ? 00:00:12 ss-serverroot 32356 32306 0 17:46 pts/0 00:00:00 grep --color=auto ss-server 备注: 其它VPS系统 shadowsocks-libev 安装以及详细配置请参考地址： shadowsocks-libev 其它系统安装以及详细配置 2、shadowsocks 客户端安装与使用（ Client 端 ）①、下载 ShadowsocksX-NG ，并安装，解压直接打开 下载地址： ShadowsocksX-NG.1.5.1.zip ②、客户端，服务器配置点击客户端图标——&gt;服务器——&gt;服务器设置 选择 + 号添加一台服务器，配置参数如下： 备注： 1、地址: 填写你VPS公网的IP 2、端口: 是你在 /etc/shadowsocks-libev/config.json 中配置的 server_port 中的端口 3、密码: 是你在 /etc/shadowsocks-libev/config.json 中配置的 password 中的密码 4、加密方式: 是你在 /etc/shadowsocks-libev/config.json 中配置的 method 中的加密方式 ③、客户端设置开启全局模式 备注： &nbsp;PAC自动模式、全局模式、手动模式三种模式主要区别，供大家参考选择 1、PAC自动模式: 可保证所有浏览器都能够使用代理，和访问你们公司内网 2、全局模式: 可保证所有浏览器能够使用代理，但不能访问公司内网 3、手动模式: 仅仅适用于指定浏览器（配套的插件：如 Chrome 浏览器的：SwitchyOmega 插件） 能够使用代理和访问公司内网，下文将会介绍。 ④、测试VPN搭建是否成功1、 Google 一下 备注：如果Google不了，可能原因如下 1、首先确保客户端和服务端的配置参数一致 2、购买时候的VPS安全组规则，没有开启相应的端口 3、VPS上防火墙以及相关端口没有开启问题 3、shadowsocks 客户端管理工具Google插件SwitchyOmega安装与使用（ 可选择 ①、安装大家在goole商店里自行Google检索词 SwitchyOmega 添加到扩展程序里 ①、情景模式： proxy 选项配置点击 SwitchyOmega 选项 按钮 打开 SwitchyOmega 的配置界面，找到情景模式模块下的 proxy 选项如图： 说明： 1、代理协议: SOCKET5 2、代理服务器: 写本机（127.0.0.1） 3、代理端口: 和服务端 /etc/shadowsocks-libev/config.json 文件中的 local_port 值保持一致 ②、情景模式： auto switch 说明： 在切换规则栏目下，你可以添加正则匹配哪些域名走直连，和代理;如果觉得这样麻烦，我们可以在规则列表设置里面， 通过添加规则网址(https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt)， 为我们生成一些常用的规律列表，（请注意规则列表规则要选择Proxy模式，否则不起作用）","categories":[{"name":"工具","slug":"工具","permalink":"http://www.gulj.cn/categories/工具/"}],"tags":[{"name":"vpn","slug":"vpn","permalink":"http://www.gulj.cn/tags/vpn/"}]},{"title":"Mac用户使用 Aria2GUI 绕过百度网盘满速下载","slug":"Aria2GUI-绕过百度网盘满速下载","date":"2017-08-15T18:15:07.000Z","updated":"2019-02-14T07:07:12.858Z","comments":true,"path":"2017/08/16/Aria2GUI-绕过百度网盘满速下载/","link":"","permalink":"http://www.gulj.cn/2017/08/16/Aria2GUI-绕过百度网盘满速下载/","excerpt":"分享一下Mac用户使用最新的 Aria2GUI 绕过百度网盘下载的方法一、操作流程 1.下载Aria2GUI主程序，解压缩拖拽“Aria2GUI.app”到应用程序完成安装","text":"分享一下Mac用户使用最新的 Aria2GUI 绕过百度网盘下载的方法一、操作流程 1.下载Aria2GUI主程序，解压缩拖拽“Aria2GUI.app”到应用程序完成安装 2.下载并解压缩Chrome文件夹放置任意位置（以后勿删）； 3.打开Chrome浏览器，点击偏好设置—扩展程序—勾上“开发者模式”—点击“加载已解压的扩展程序”选择第二步下载的Chrome文件夹； 4.打开需要下载的百度云盘链接，Chrome浏览器提示“初始化完成”并出现“导出选项”—“ARIA2 RPC”，同时打开应用程序中的“Aria2GUI.app”即可自动实现绕过百度盘慢速下载，默认下载路径在下载目录中； 5.完成 二、下载地址 1、Aria2GUI 1.2.8 for Mac下载 2、Chrome最新插件下载 备注：该工具只适合Chrome浏览器","categories":[{"name":"工具","slug":"工具","permalink":"http://www.gulj.cn/categories/工具/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.gulj.cn/tags/mac/"}]},{"title":"Hexo 博客配置","slug":"hexo-博客配置","date":"2017-08-15T07:34:40.000Z","updated":"2019-02-14T07:07:12.865Z","comments":true,"path":"2017/08/15/hexo-博客配置/","link":"","permalink":"http://www.gulj.cn/2017/08/15/hexo-博客配置/","excerpt":"添加RSS和Sitemapnpm安装插件1$ npm install hexo-generator-feed --save","text":"添加RSS和Sitemapnpm安装插件1$ npm install hexo-generator-feed --save 配置根目录_config.yml12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 添加Git部署插件，部署到GitHub的仓库1$ npm install hexo-deployer-git --save 添加不蒜子统计（统计文章阅读数，站点访客数，访问量） http://ibruce.info/2015/04/04/busuanzi/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.gulj.cn/tags/hexo/"}]}]}