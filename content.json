{"meta":{"title":"顾大仙MQ | 博客","subtitle":null,"description":"本站是顾大仙MQ（顾立剑）的技术分享博客。内容涵盖Java后端技术、大数据、优秀开发工具、Mac推荐工具、视屏书籍分享、运维开发、系统监控等相关的研究与知识分享","author":"顾立剑","url":"http://www.gulj.cn"},"pages":[],"posts":[{"title":"Webpack 学习示例","slug":"webpack-教程","date":"2018-04-09T08:13:54.000Z","updated":"2018-05-02T08:45:56.357Z","comments":true,"path":"2018/04/09/webpack-教程/","link":"","permalink":"http://www.gulj.cn/2018/04/09/webpack-教程/","excerpt":"介绍Webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle 本章节主要介绍Webpack的核心概念的Demo使用示例，建议读者查看之前请阅读Webpack的官方文档也可以查看中文地址文档 Webpack版本： 3.9.0 代码GitHub地址： https://github.com/gulijian/webpack-learning-example","text":"介绍Webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle 本章节主要介绍Webpack的核心概念的Demo使用示例，建议读者查看之前请阅读Webpack的官方文档也可以查看中文地址文档 Webpack版本： 3.9.0 代码GitHub地址： https://github.com/gulijian/webpack-learning-example How to useInstall webpack 1$ npm i -g webpack Clone the repo. 1$ git clone https://github.com/gulijian/webpack-learning-example.git Install the dependencies 12# 进入每个章节根目录，执行 npm install $ npm install Open the each chapter index.html IndexStyle-loader Style-loader/url Css-loader And Css-Module Js Tree-shaking Url-loader ProvidePlugin Clean-webpack-plugin chapter4-1 (source)style-loader use 处理css，以 style 标签形式引入css app.js1import './css/app.css' app.css123html &#123; background: #00bcd4b5;&#125; index.html123456&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js12345678910111213141516171819202122232425262728var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader' &#125; ] &#125; ] &#125;&#125; chapter4-2 (source)style-loader/url use 处理css，以标签形式引入css app.js1import './css/app.css' app.css123456789html &#123; background: #00bcd4b5; &#125;#styleLoaderUrl &#123; font-size: 30px; color: white; text-align: center;&#125; index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;span id=\"styleLoaderUrl\"&gt; hello style-loader/url&lt;/span&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpak.config.js1234567891011121314151617181920212223242526272829var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#123; loader: 'style-loader/url' &#125;, &#123; loader: 'file-loader' &#125; ] &#125; ] &#125;&#125; chapter4-3 (source)css-loader and css-module use 处理css，支持 css-module 形式 app.js12345678import app1 from './css/app1.css'import app2 from './css/app2.css'var app = document.getElementById('app');// 使用样式app.innerHTML = '&lt;div class = \"'+app1.box+'\"&gt;&lt;/div&gt;' app1.css12345678.box &#123; composes: borderBox from './app2.css'; height: 200px; width: 200px; border-radius: 4px; background: #76d4e0ab; margin: 0 auto;&#125; app2.css123.borderBox &#123; border: 4px solid #e87ff5;&#125; index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js1234567891011121314151617181920212223242526272829303132var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; minimize: true, // 启用压缩 modules: true // 启用 css module &#125; &#125; ] &#125; ] &#125;&#125; chapter5-1 (source)UglifyJsPlugin use 使用 UglifyJsPlugin 插件； 不打包没有使用的 js util.js1234567891011export function a ()&#123; return 'this is a';&#125;export function b ()&#123; return 'this is b';&#125;export function c ()&#123; return 'this is c';&#125; app.js123import &#123; a &#125; from './common/util.js'console.log(a()) index.html123456&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js123456789101112131415161718var webpack = require('webpack')var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin() ]&#125; app.js 中只使用了 util.js 中的 a 函数 打包的时候只会打包 a 函数；因为 b 和 c 函数没有使用到，则不会被打包 chapter6-1 (source)url-loader use 图片文件处理 app.js12345var img1 = document.getElementById('img1')var img2 = document.getElementById('img2')img1.src = require('./assets/img1.jpg')img2.src = require('./assets/img2.png') index.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;!-- size &lt; 30kb --&gt; &lt;img id=\"img1\"/&gt; &lt;!-- size &gt; 30kb --&gt; &lt;img id=\"img2\"&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js1234567891011121314151617181920212223242526272829var path = require('path')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.(png|jpg|jpeg|gif)$/, use: [ &#123; loader:'url-loader', options: &#123; limit: 30000 &#125; &#125; ] &#125; ] &#125;&#125; 图片 小于 30kb 会变成base64编码，大于 30kb 会生成图片地址 12&lt;img id=\"img1\" src=\"6443347e97d394b23b05746b2fe41cd1.jpg\"&gt;&lt;img id=\"img2\" src=\"data:image/png;base64,iVBORw0KGgoAXBIWXMAAC4jAAAuIwF4pT92AAAKTWlD\"/&gt; chapter7-1 (source)ProvidePlugin use 处理第三方 JS 库，方式一：（ jquery 作为npm的一个module） app.js1$('#app').append('hello jquery') index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js12345678910111213141516171819var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery' &#125;) ]&#125; chapter7-2 (source) 处理第三方 JS 库，方式二：（引入本地的 jquery 库） app.js1$('#app').append('hello jquery') index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js1234567891011121314151617181920212223242526var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, // 注意 jquery$ 的名字 要和 ProvidePlugin 插件中配置的名称（jquery）保持一致 resolve: &#123; alias: &#123; jquery$: path.resolve(__dirname,'src/libs/jquery.min.js') &#125; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery' &#125;) ]&#125; 如果 jquery 在CDN上，直接引入即可 chapter8-1 (source)clean-webpack-plugin use 每次打包清除原先的打包目录 app.js123var app = document.getElementById('app')app.innerHTML = '&lt;h1&gt;使用 clean-webpack-plugin 插件，可以每次打包清除原先的打包目录&lt;/h1&gt;' index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;span id=\"app\"&gt;&lt;/span&gt; &lt;script src=\"./dist/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js12345678910111213141516171819var path = require('path')var CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; entry: &#123; 'app': './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname,'./dist/'), filename: '[name].bundle.js' &#125;, plugins: [ new CleanWebpackPlugin([ 'dist' ]) ]&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://www.gulj.cn/tags/webpack/"}]},{"title":"【Docker教程】Docker Linux网络命名空间","slug":"docker-linux命名空间","date":"2018-03-31T02:44:25.000Z","updated":"2018-05-02T08:45:56.367Z","comments":true,"path":"2018/03/31/docker-linux命名空间/","link":"","permalink":"http://www.gulj.cn/2018/03/31/docker-linux命名空间/","excerpt":"前言到现在我们已经了解到Docker的镜像、容器等概念，我们可以在一台宿主机上运行一个或者多个容器，也可以将不同的容器运行在不同的宿主机上，那么这些容器是怎样进行互相通信呢？本文将介绍Linux网络命名空间概念，来帮助读者更好地了解到Docker容器之间的通信。 容器之间的通信(同一台宿主机上)默认情况下，在同一台宿主机上的多个容器是可以互相访问的，容器的网络命名空间和宿主机的网络命名空间是相互独立隔离的 查看宿主机的网络命名空间","text":"前言到现在我们已经了解到Docker的镜像、容器等概念，我们可以在一台宿主机上运行一个或者多个容器，也可以将不同的容器运行在不同的宿主机上，那么这些容器是怎样进行互相通信呢？本文将介绍Linux网络命名空间概念，来帮助读者更好地了解到Docker容器之间的通信。 容器之间的通信(同一台宿主机上)默认情况下，在同一台宿主机上的多个容器是可以互相访问的，容器的网络命名空间和宿主机的网络命名空间是相互独立隔离的 查看宿主机的网络命名空间 1234567891011121314151617181920212223$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 52:54:00:ad:3b:43 brd ff:ff:ff:ff:ff:ff inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic eth0 valid_lft 85639sec preferred_lft 85639sec inet6 fe80::5054:ff:fead:3b43/64 scope link valid_lft forever preferred_lft forever3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 08:00:27:7e:86:8c brd ff:ff:ff:ff:ff:ff inet 192.168.215.20/24 brd 192.168.215.255 scope global eth1 valid_lft forever preferred_lft forever inet6 fe80::a00:27ff:fe7e:868c/64 scope link valid_lft forever preferred_lft forever4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN link/ether 02:42:79:71:de:73 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 新建两个容器放入后台运行 123$ docker run -d --name demo1 busybox /bin/sh -c \"while true;do sleep 3600;done\"$ docker run -d --name demo2 busybox /bin/sh -c \"while true;do sleep 3600;done\" 查看两个容器的网络命名空间 12345678910111213141516171819$ docker exec demo1 ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever5: eth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever $ docker exec demo2 ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever7: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 这里可以看到宿主机、demo1和demo2的网络命名空间都是独立的，测试容器demo1和容器demo2是否可以互通 12345678910111213# 在 demo1 内 ping demo2容器的ip地址$ docker exec test1 ping 172.17.0.3PING 172.17.0.3 (172.17.0.3): 56 data bytes64 bytes from 172.17.0.3: seq=0 ttl=64 time=0.086 ms64 bytes from 172.17.0.3: seq=1 ttl=64 time=0.104 ms64 bytes from 172.17.0.3: seq=2 ttl=64 time=0.081 ms# 在 demo2 内 ping demo1容器的ip地址$ docker exec test2 ping 172.17.0.2PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.079 ms64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.102 ms64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.101 ms 从上面看出容器demo1和容器demok2可以互相访问 为了更好地了解到在同一宿主机上容器间的通信，下面我们从Linux网络命名空间来为大家解释 在这之前我们先把我们刚才运行的demo1和demo2两个容器停止掉 1$ sudo docker stop demo1 demo2 Linux 的网络命名空间(namespace)下面我们将在宿主机上创建两个网络命名空间分别为test1和test2，然后再创建一对Veth 接口，分别分配给test1和test2，这样test1和test2就能够连接起来，能够互相访问 创建网络命名空间123$ sudo ip netns add test1$ sudo ip netns add test2 查看网络命名空间123$ sudo ip netns listtest2test1 在docker容器中，我们可以查看容器的网络命名空间，同理我们也可以查看我们创建的网络命名空间详细信息 1234567$ sudo ip netns exec test1 ip a1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 $ sudo ip netns exec test2 ip a 1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 现在可以看到我们创建的两个命名空间test1和tes2只有本地的回环端口，也没有本地 ip 127.0.0.1 之类并且状态是DOWN的状态 查看本地的 ip link 123456789$ sudo ip link 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 52:54:00:ad:3b:43 brd ff:ff:ff:ff:ff:ff3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 08:00:27:7e:86:8c brd ff:ff:ff:ff:ff:ff4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT link/ether 02:42:79:71:de:73 brd ff:ff:ff:ff:ff:ff 现在本地只有四个 ip link 下面在宿主机上添加一对 link (vethl-test1 和 veth-test2) 1$ sudo ip link add veth-test1 type veth peer name veth-test2 接下来我们再次查看本地的 ip link 12345678910111213$ sudo ip link 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 52:54:00:ad:3b:43 brd ff:ff:ff:ff:ff:ff3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 08:00:27:7e:86:8c brd ff:ff:ff:ff:ff:ff4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT link/ether 02:42:79:71:de:73 brd ff:ff:ff:ff:ff:ff9: veth-test2@veth-test1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 9e:44:34:0b:41:39 brd ff:ff:ff:ff:ff:ff10: veth-test1@veth-test2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 5a:ed:e6:53:00:fb brd ff:ff:ff:ff:ff:ff 序号：9.（veth-test2@veth-test1），10.（veth-test1@veth-test2）就是我们刚添加的一对 link 将 veth-test1 这个接口添加到网络命名空间test1上 1$ sudo ip link set veth-test1 netns test1 这时候我们会发现本地的 ip link 序号：10 消失了，而我们创建的test1网络命名空间多了 veth-test1,我们来查看test1的 ip link 12345$ sudo ip netns exec test1 ip link 1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:0010: veth-test1@if9: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 5a:ed:e6:53:00:fb brd ff:ff:ff:ff:ff:ff link-netnsid 0 同理将 veth-test2 这个接口添加到网络命名空间test2上 1$ sudo ip link set veth-test2 netns test2 现在我们把创建的veth-test1和veth-test2分别添加到了网络命名空间test1和test2上(此时他们都没有ip地址，状态也是DOWN的状态) 123456789101112# test1$ sudo ip netns exec test1 ip link 1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:0010: veth-test1@if9: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 5a:ed:e6:53:00:fb brd ff:ff:ff:ff:ff:ff link-netnsid 0# test21: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:009: veth-test2@if10: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000 link/ether 9e:44:34:0b:41:39 brd ff:ff:ff:ff:ff:ff link-netnsid 0 分别为两个接口 veth-test1 和 veth-test2 分配ip地址,然后让其状态由DOWN变为UP (同时也可以把各自的回环端口 lo 状态也设置为 UP，不然到时候ping自己的时候ping不通) 1234567891011# 为veth-test1和veth-test2分配IP地址$ sudo ip netns exec test1 ip addr add 192.168.1.1/24 dev veth-test1$ sudo ip netns exec test2 ip addr add 192.168.1.2/24 dev veth-test2# 设置veth-test1和veth-test2的状态由DOWN变为UP$ sudo ip netns exec test1 ip link set dev veth-test1 up$ sudo ip netns exec test2 ip link set dev veth-test2 up# 设置test1和test2的本地回环端口状态由DOWN变为UP$ sudo ip netns exec test1 ip link set dev lo up$ sudo ip netns exec test2 ip link set dev lo up 现在我们可以看到我们创建的test1和test2这两个网络命名空间上的veth-test1和veth-test2接口分配的IP地址，并且状态为UP 123456789101112131415161718192021# test1$ sudo ip netns exec test1 ip a1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:0010: veth-test1@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP qlen 1000 link/ether 5a:ed:e6:53:00:fb brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet 192.168.1.1/24 scope global veth-test1 valid_lft forever preferred_lft forever inet6 fe80::58ed:e6ff:fe53:fb/64 scope link valid_lft forever preferred_lft forever # test2 $ sudo ip netns exec test2 ip a1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:009: veth-test2@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP qlen 1000 link/ether 9e:44:34:0b:41:39 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.1.2/24 scope global veth-test2 valid_lft forever preferred_lft forever inet6 fe80::9c44:34ff:fe0b:4139/64 scope link valid_lft forever preferred_lft forever 到此我们已经成功地完成了通过我们自己创建的test1和test2这两个网络命名空间，他们之间可以通过veth-test1和veth-test2互相访问 12345678910111213# test1 上 ping test2的ipsudo ip netns exec test1 ping 192.168.1.2PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.048 ms64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.059 ms64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.067 ms# test2 上 ping test1的ip$ sudo ip netns exec test2 ping 192.168.1.1PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=0.048 ms64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=0.052 ms64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=0.079 ms 在同一台宿主机上的docker多容器他们分别有各自的网络命名空间，他们之间的通信原理，和我们自己创建的test1和test2这两个网络命名空间他们之间的通信原理类似","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 数据持久化","slug":"docker-数据持久化","date":"2018-03-30T03:47:38.000Z","updated":"2018-05-02T08:45:56.357Z","comments":true,"path":"2018/03/30/docker-数据持久化/","link":"","permalink":"http://www.gulj.cn/2018/03/30/docker-数据持久化/","excerpt":"介绍Docker 容器一旦删除，那么我们在容器内的一切操作将不复存在，比如我们在容器内存储的数据等；为了解决这个问题，Docker 提出了数据卷概念，就像我们运行一个mysql容器，我们需要存储我们的数据，日志之类，想要他们不会随着容器的删除而销毁，或者我们需要在各个容器间共享数据，那么这些数据卷或者数据卷容器都能做到。 数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 数据卷的生命周期一直持续到没有容器使用它为止 数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷","text":"介绍Docker 容器一旦删除，那么我们在容器内的一切操作将不复存在，比如我们在容器内存储的数据等；为了解决这个问题，Docker 提出了数据卷概念，就像我们运行一个mysql容器，我们需要存储我们的数据，日志之类，想要他们不会随着容器的删除而销毁，或者我们需要在各个容器间共享数据，那么这些数据卷或者数据卷容器都能做到。 数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 数据卷的生命周期一直持续到没有容器使用它为止 数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷 Docker提供了两种方式管理数据 数据卷 数据卷容器 数据卷添加数据卷在 docker run 命令中 使用 -v 标识给容器内添加一个或者多个数据卷 在容器内创建一个新的数据卷 /data/shop 1$ docker run -d -P --name my-shop-web -v /data/shop sqgulj/shop-web 这种方式我们也可以在Dockerfile中使用VOLUME指令来给创建的容器添加一个或者多个数据卷，比如官方的 mysql 的 Dockerfile 中用 VOLUME 指定了数据卷 123456789101112131415161718192021.........RUN &#123; apt-get update &amp;&amp; apt-get install -y mysql-server=\"$&#123;MYSQL_VERSION&#125;\" &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm -rf /var/lib/mysql &amp;&amp; mkdir -p /var/lib/mysql /var/run/mysqld \\ &amp;&amp; chown -R mysql:mysql /var/lib/mysql /var/run/mysqld \\# ensure that /var/run/mysqld (used for socket and lock files) is writable regardless of the UID our mysqld instance ends up having at runtime &amp;&amp; chmod 777 /var/run/mysqld \\# comment out a few problematic configuration values &amp;&amp; find /etc/mysql/ -name '*.cnf' -print0 \\ | xargs -0 grep -lZE '^(bind-address|log)' \\ | xargs -rt -0 sed -Ei 's/^(bind-address|log)/#&amp;/' \\# don't reverse lookup hostnames, they are usually another container &amp;&amp; echo '[mysqld]\\nskip-host-cache\\nskip-name-resolve' &gt; /etc/mysql/conf.d/docker.cnfVOLUME /var/lib/mysqlCOPY docker-entrypoint.sh /usr/local/bin/RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compatENTRYPOINT [\"docker-entrypoint.sh\"]............ 其中 VOLUME /var/lib/mysql 指定了mysql的数据卷 将宿主机的一个目录，挂在到容器里使用 -v，除了可以创建一个数据卷，还可以挂载本地主机目录到容器中 1$ docker run -d -P --name my-shop-web -v /local/data/shop:/data/shop sqgulj/shop-web 这将会把本地目录/local/data/shop挂载到容器的/data/shop目录，宿主机上的目录必须是绝对路径，如果目录不存在docker会自动创建它。 出于可移植和分享的考虑，在Dockerfile中这种方式不支持 docker默认情况下是对数据卷有读写权限，但是我们通过这样的方式让数据卷只读： 1$ docker run -d -P --name my-shop-web -v /local/data/shop:/data/shop:ro sqgulj/shop-web 这里我们同样挂载了/local/data/shop目录，只是添加了 ro 选项来限制它只读。 将宿主机上单个文件挂载到容器中除了能挂载目录外，-v 标识还可以将宿主机的一个特定文件挂载为数据卷 1$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash 这样就可以记录在容器输入过的命令了 如果直接挂载一个文件，很多文件编辑工具，包括 vi 或者 sed –in-place，可能会造成文件 inode 的改变，从 Docker 1.1.0起，这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。 查看数据卷 使用命令 docker volume 可以查看我们生成的数据卷 123$ docker volume ls DRIVER VOLUME NAMElocal b202765855d3b77e574284fde0079d31fb0258997a7b72eb6f7c8299053f216b 我们可以看到我们添加的数据卷 /data/shop ，当我们查看的时候并不是我们提供的名称，而是生成一系列的随机串，当我们为多个容器添加数据卷的时候，它也会为其生成一系列的随机串，这样不利于我们辨识哪些数据卷挂在哪个容器中，为了解决这个问题，我们可以在添加数据数据卷的时候，为数据卷起个辨识的名称，比如 1$ docker run -d -P --name my-shop-web -v shopwebdata:/data/shop sqgulj/shop-web 我们发现，这次我们为容器添加一个数据的时候我们在前面加了一个 shopwebdata ，注意shopwebdata前面没有斜杠( / )，如果有斜杠那是把本地的一个目录挂载到容器内的一个目录 123$ docker volume ls DRIVER VOLUME NAMElocal shopwebdata 这次我们就能看到我们添加的数据卷就是我们起的名称，而不是一些列的随机串 使用命令 docker inspect 查看数据卷 123456789101112131415161718# my-shop-web 为容器的名称$ docker inspect my-shop-web............\"Mounts\": [ &#123; \"Type\": \"volume\", \"Name\": \"b202765855d3b77e574284fde0079d31fb0258997a7b72eb6f7c8299053f216b\", \"Source\": \"/var/lib/docker/volumes/b202765855d3b77e574284fde0079d31fb0258997a7b72eb6f7c8299053f216b/_data\", \"Destination\": \"/data/shop\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" &#125; ], ............. 这里只列出了其中的 Mounts 属性，从中可以看到Source字段显示了数据卷存放的位置 删除数据卷数据卷是被设计来持久化数据的，因此，删除容器并不会删除数据卷。如果想要在删除容器时同时删除数据卷，可使用如下命令： 1$ docker rm -v 容器ID 这样既可在删除容器的同时也将数据卷删除。 我们还可以使用 docker volume rm 命令删除数据卷 12345# 查看数据卷$ docker volume ls# 指定数据卷名称删除$ docker volume rm volume_name volume_name 删除所有的数据卷 1docker volume rm $(docker volume ls -f dangling=true -q) 数据卷容器如果有些数据，需要在多个容器之间进行共享，这时候可以使用数据卷容器创建数据卷容器 1docker run --name mysql-volume -v /data mysql 其它容器可以使用–volumes-from标识，来使用通过刚刚创建的数据卷容器，来挂载对应的数据卷 123$ docker run -d --volumes-from mysql-volume --name db1 mysql$ docker run -d --volumes-from mysql-volume --name db2 mysql 这样 db1 和 db2 两个容器都共享 mysql-volume 这个容器中的文件 挂载相同数据卷的容器，容器的停止和删除，不会对数据卷产生影响 我们也还可以对一个容器使用多个 –volumes-from 标识，来将多个数据卷桥接到这个容器中","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 容器","slug":"docker-容器","date":"2018-03-29T06:17:03.000Z","updated":"2018-05-02T08:45:56.359Z","comments":true,"path":"2018/03/29/docker-容器/","link":"","permalink":"http://www.gulj.cn/2018/03/29/docker-容器/","excerpt":"介绍Docker 容器是用于运行镜像的沙箱环境，它是 Docker 镜像的运行实例；容器都是相互隔离、互不可见的，我们可以理解为：镜像是Docker生命周期的打包和构建阶段，而容器是Docker的启动和执行阶段。 容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。 镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。","text":"介绍Docker 容器是用于运行镜像的沙箱环境，它是 Docker 镜像的运行实例；容器都是相互隔离、互不可见的，我们可以理解为：镜像是Docker生命周期的打包和构建阶段，而容器是Docker的启动和执行阶段。 容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。 镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 运行容器使用 docker run 命令来运行一个容器格式： 1$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] [flags] OPTIONS说明： 由于 docker run 命令 OPTIONS 比较多，这里只选择大家常用的几个选项来说明 -i, --interactive=false 打开STDIN，用于控制台交互 -t, --tty 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上 -d, --detach=false 指定容器运行于前台还是后台，默认为false -p, --publish list 指定主机的端口和容器端口的映射 -P, --publish-all 使用容器内随机一个网络端口映射到我们使用的主机上 -v, --volume list 给容器挂载存储卷，挂载到容器的某个目录 -m, --memory 指定容器的内存上限 --link list 指定容器间的关联，使用其他容器的IP、env等信息 -e, --env list 设置环境变量 --restart string 指定容器的重启策略 示例： 后台运行一个nginx 1$ docker run --name mynginx -p 8088:80 -v $PWD/nginx/www:/www -v $PWD/nginx/logs:/wwwlogs -d nginx 查看运行的容器 查看正在运行的容器 123$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES76ea0a1383d4 nginx &quot;nginx -g &apos;daemon of…&quot; Less than a second ago Up 3 seconds 0.0.0.0:8088-&gt;80/tcp mynginx 查看所有容器（包含正在运行和退出的容器） 123$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES76ea0a1383d4 nginx \"nginx -g 'daemon of…\" 3 minutes ago Exited (0) 2 seconds ago mynginx 查看容器的详细信息 1$ dokcer inspect mygnix 进入容器使用 docker exec 命令进入容器格式： 1$ docker exec [OPTIONS] CONTAINER COMMAND [ARG...] OPTIONS说明： -d, --detach 分离模式: 在后台运行 -i, --interactive 即使没有附加也保持STDIN 打开 -t, --tty 分配一个伪终端 -e, --env list 设置环境变量 示例： 以交互模式进入容器 12$ docker exec -it mynginx /bin/bashroot@76ea0a1383d4:/# 停止和重启容器如果是交互式运行的一个容器，可以通过exit命令和Ctrl+d来退出终端，这样容器会立刻终止 123# exit 直接退出，容器终止；或者快捷键Ctrl+d $ docer run -it centos /bin/bash[root@f7b52eb5ab02 /]# exit 使用 docker stop 命令来停止正在运行的容器格式： 1$ docker stop [OPTIONS] CONTAINER [CONTAINER...] 示例： 指定容器名称停止正在运行的多个容器 1$ docker stop mynginx myredis 重新启动容器 12345# 启动终止的容器$ docker start mynginx# 将一个运行态的容器终止，然后再重新启动它$ docker restart myredis 删除容器使用 docker rm 命令删除一个或多个容器格式： 1$ docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明： -f, --force 强制删除 -l, --link 移除容器间的网络连接，而非容器本身 -v, --volumes 删除与容器关联的卷 示例： 强制删除容器mynginx 1$ docker rm -f mynginx 删除mygninx，并删除容器挂载的数据卷 1$ docker rm -v mynginx 强制删除所有的容器 1$ docker rm -f $(docker ps -aq) 删除容器使用 docker rm 命令 而 删除容器使用 docker rmi 命令，注意两者区别 导出容器使用命令 docker export 导出本地某个容器 123456789# 查看容器列表$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf7b52eb5ab02 centos \"/bin/bash\" 18 hours ago Exited (0) 18 hours ago heuristic_edison06a6eb00f8bc centos \"/bin/bash\" 18 hours ago Up 18 hours stupefied_euler76ea0a1383d4 nginx \"nginx -g 'daemon of…\" 19 hours ago Up 19 hours 0.0.0.0:8088-&gt;80/tcp mynginx# 导出容器快照,到本地文件$ docker export 76ea0a1383d4 &gt; mynginx.tar.gz 导入容器使用命令 docker import 从快照文件中导入为镜像 1cat mynginx.tar.gz | docker import - sqgulj/nginx:2.0","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 镜像发布","slug":"docker-镜像发布","date":"2018-03-28T05:37:58.000Z","updated":"2018-05-02T08:45:56.365Z","comments":true,"path":"2018/03/28/docker-镜像发布/","link":"","permalink":"http://www.gulj.cn/2018/03/28/docker-镜像发布/","excerpt":"介绍如果我们自己在本地制作一个镜像，想提供给他人使用或者作为自己的日常学习，那么我们可以把我们制作的镜像发布到DockerHub上，这样不管是其它人还是我们自己就可以直接使用 docker pull 命令获取到我们发布的镜像，这样我们再也不用担心一不小心把本地镜像删除了；当然发布到DockerHub上的镜像是公开的，每个人都能获取，如果我们希望我们发布的镜像是私有的只有我们自己可以看见，我们可以利用官方提供的registry镜像来搭建自己私有的镜像仓库,当然我们也还可以使用Harbor来搭建企业级私有仓库服务器","text":"介绍如果我们自己在本地制作一个镜像，想提供给他人使用或者作为自己的日常学习，那么我们可以把我们制作的镜像发布到DockerHub上，这样不管是其它人还是我们自己就可以直接使用 docker pull 命令获取到我们发布的镜像，这样我们再也不用担心一不小心把本地镜像删除了；当然发布到DockerHub上的镜像是公开的，每个人都能获取，如果我们希望我们发布的镜像是私有的只有我们自己可以看见，我们可以利用官方提供的registry镜像来搭建自己私有的镜像仓库,当然我们也还可以使用Harbor来搭建企业级私有仓库服务器 镜像发布到 DockerHub镜像发布到 DockerHub，首先我们需要注册 DockerHub 账号，假设现在大家都有了DokcerHub的账号，那么接下来我们在本地制作一个自己的镜像 创建一个getip目录，进入到getip目录，编写Dockerfile 12345$ mkdir getip$ cd getip $ vim Dockerfile Dokcerfile文件中内容 1234567FROM ubuntu:16.04RUN apt-get update \\ &amp;&amp; apt-get install -y curl \\ &amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [\"curl\",\"-s\",\"http://ip.cn\"] 在getip目录执行 docker build 命令构建镜像 12# 构建镜像(注意仓库名必须是你注册的 dockerhub 的用户名)docker build -t sqgulj/get-ip:1.0 . 查看构建的镜像 123$ docker images;REPOSITORY TAG IMAGE ID CREATED SIZEsqgulj/get-ip 1.0 e381e0c1b380 3 hours ago 129MB 在终端使用 docker login 命令，输入自己的DockerHub账号信息进行登录 123docker loginLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.Username (sqgulj): 使用 docker push 命令把我刚制作的镜像推送到DockerHub 123456789$ docker push sqgulj/get-ipThe push refers to repository [docker.io/sqgulj/get-ip]83dc3de4596c: Pusheddb584c622b50: Mounted from library/ubuntu52a7ea2bb533: Mounted from library/ubuntu52f389ea437e: Mounted from library/ubuntu88888b9b1b5b: Mounted from library/ubuntua94e0d5a7c40: Mounted from library/ubuntu1.0: digest: sha256:1a3fa4e93464054c2f8050d6f846cccbe943c5e9f6d67f98f2013a32652f3f0b size: 1568 浏览器登录到DockerHub查看我们推送的镜像","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 镜像加速器","slug":"docker-镜像加速器","date":"2018-03-27T14:29:18.000Z","updated":"2018-05-02T08:45:56.365Z","comments":true,"path":"2018/03/27/docker-镜像加速器/","link":"","permalink":"http://www.gulj.cn/2018/03/27/docker-镜像加速器/","excerpt":"介绍由于国内访问官方（DockerHub）的镜像比较慢，可以使用阿里云和DaoCloud为我们提供的镜像 阿里云镜像加速器地址 DaoCloud 镜像加速器地址 本文笔者会分别介绍MacOs平台和Centos7平台下配置这两种的镜像加速器地址","text":"介绍由于国内访问官方（DockerHub）的镜像比较慢，可以使用阿里云和DaoCloud为我们提供的镜像 阿里云镜像加速器地址 DaoCloud 镜像加速器地址 本文笔者会分别介绍MacOs平台和Centos7平台下配置这两种的镜像加速器地址 MacOS 平台配置阿里云Docker加速器 登录阿里云控制台（需要注册阿里云开发者平台账号），访问地址：https://cr.console.aliyun.com/#/accelerator 可查看自己专有的镜像库加速器地址 下图展示的是笔者的阿里云镜像加速器界面 右键点击桌面顶栏的 docker 图标 Perferences… -&gt; Daemon -&gt; Registry mirrors，添加代理地址，记得点击 Apply &amp; Restart 按钮使设置生效。 出现的 “registry-mirrors” : No certs for 6wnqhom.mirror.aliyuncs.com… 警告可以忽略。 配置DaoCloud的Docker加速器 打开地址：https://www.daocloud.io/mirror#accelerator-doc 可以使用github账号登录或者微信 添加DaoCloud的dokcer镜像代理地址和添加阿里云Docker代理地址方法一样，读者可以参考上面添加的阿里云docker加速器代理地址 Centos7 平台配置阿里云Docker加速器通过上面我们已经知道了如何获取自己的的阿里云docker镜像代理地址 修改daemon配置文件/etc/docker/daemon.json来使用加速器： 分别执行以下命令，记得把加速器的地址，改成自己的加速器地址。 123456789101112sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://XXXXX.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 针对Docker客户端版本大于1.10.0的用户 检查加速器是否生效 Linux系统下配置完加速器需要检查是否生效，在命令行执行 ps -ef | grep dockerd，如果从结果中看到了配置的 –registry-mirror 参数说明配置成功 如果Docker版本大于1.13或17.05.0-ce 123$ sudo docker info|grep \"Registry Mirrors\" -A 1Registry Mirrors: https://16wnqhom.mirror.aliyuncs.com/","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 镜像","slug":"docker-镜像","date":"2018-03-27T11:03:41.000Z","updated":"2018-05-02T08:45:56.360Z","comments":true,"path":"2018/03/27/docker-镜像/","link":"","permalink":"http://www.gulj.cn/2018/03/27/docker-镜像/","excerpt":"获取镜像官方的 DockerHub 上有很多开源的高质量镜像，可以直接供我们使用 使用docker pull 命令直接从 DockerHub 上获取 格式： 1docker pull [选项] [docker registry 地址]:&lt;仓库名&gt;:&lt;标签&gt; 示例： 123456789# 获取nginx镜像$ docker pull nginxUsing default tag: latestlatest: Pulling from library/nginx2a72cbf407d6: Pull completefefa2faca81f: Pull complete080aeede8114: Pull completeDigest: sha256:c4ee0ecb376636258447e1d8effb56c09c75fe7acf756bf7c13efadf38aa0acaStatus: Downloaded newer image for nginx:latest","text":"获取镜像官方的 DockerHub 上有很多开源的高质量镜像，可以直接供我们使用 使用docker pull 命令直接从 DockerHub 上获取 格式： 1docker pull [选项] [docker registry 地址]:&lt;仓库名&gt;:&lt;标签&gt; 示例： 123456789# 获取nginx镜像$ docker pull nginxUsing default tag: latestlatest: Pulling from library/nginx2a72cbf407d6: Pull completefefa2faca81f: Pull complete080aeede8114: Pull completeDigest: sha256:c4ee0ecb376636258447e1d8effb56c09c75fe7acf756bf7c13efadf38aa0acaStatus: Downloaded newer image for nginx:latest 使用Dockerfile构建Docker镜像 （建议使用Dockerfile构建自己的Docker镜像） 格式： docker image build [OPTIONS] PATH | URL | - [flags] 简写： docker build [OPTIONS] PATH | URL | - [flags] 创建一个nginx目录，编写dockerfile文件 123456789# 创建一个nginx目录$ mkdir nginx# 编写Dockerfile文件 (注意名称必须为:Dockerfile)$ vim Dockerfile# Dockerfile 文件中内容FROM nginxRUN echo '&lt;h1&gt;Hello, nginx!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html 在 Dockerfile 文件所在目录执行下面命令，构建名为 gulj/nginx:v1 的docker镜像 12# 构建名为 mynginx:v1 的镜像$ docker build -t gulj/nginx:v1 . 使用docker commit 命令通过已有的 容器 创建镜像（不建议使用） 格式：docker container commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 简写：docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 既然通过容器创建镜像，那么首先需要运行一个容器，而运行一个容器需要一个基础镜像，下面将使用官方的centos镜像，通过加工来构建自己的镜像 大致流程如下： ① 获取官方的centos镜像 ② 对获取的centos镜像执行docker run 命令获取一个容器 ③ 对获取的容器进行安装vim操作，安装结束，退出容器（默认官方的centos镜像没有vim命令） ④ 通过docker commit 命令构建镜像，这样我们就能得到了一个带有vim命令的centos镜像 按照流程操作演示 1234567891011121314151617181920212223242526272829# 获取centos镜像$ docker pull centosUsing default tag: latestlatest: Pulling from library/centos5e35d10a3eba: Pull completeDigest: sha256:dcbc4e5e7052ea2306eed59563da1fec09196f2ecacbe042acbdcd2b44b05270Status: Downloaded newer image for centos:latest# 以交互式方式获取一个容器,这样我们就会进入容器内，安装vim，安装完之后退出容器$ docker run -it centos# 在容器内安装vim[root@34046cf71732 /] yum install vim -y # 退出容器[root@34046cf71732 /] exit # 查看我们刚才运行的容器$ dokcer ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES34046cf71732 centos \"/bin/bash\" 10 minutes ago Exited (0) 15 seconds ago cocky_euler# 构建安装vim的centos镜像, --author 是指定修改的作者，而 --message 则是记录本次修改的内容，可省略$ docker commit --author \"gulj &lt;sqgulj@gmail.com&gt;\" --message \"安装了vim\" cocky_euler gulj/centos-vim:1.0sha256:1109b8f3ea7826225d1dc1ee2693507fe8402eaeeafc57d24b907018a5cc0951# 查看我们构建的镜像$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgulj/centos-vim 1.0 1109b8f3ea78 15 seconds ago 354MBcentos latest 2d194b392dd1 3 weeks ago 195MB 下面我们通过docker history 命令查看镜像内的历史记录，与 centos:latest 的镜像历史记录比较，我们会很明显地发现，gulj/centos-vim:1.0 的镜像历史记录比 centos:latest 的镜像历史记录多了一层，也就是我们提交的一层（sha256:1109b8f3ea7826225d1…） 1234567891011121314# centos:latest 镜像$ docker history centosIMAGE CREATED CREATED BY SIZE COMMENT2d194b392dd1 3 weeks ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0B&lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) LABEL name=CentOS Base Im… 0B&lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) ADD file:8d83f3e2c14f39e7f… 195MB# 我们自己构建的gulj/centos-vim:1.0镜像$ docker history gulj/centos-vim:1.0IMAGE CREATED CREATED BY SIZE COMMENT1109b8f3ea78 9 minutes ago /bin/bash 158MB2d194b392dd1 3 weeks ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0B&lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) LABEL name=CentOS Base Im… 0B&lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) ADD file:8d83f3e2c14f39e7f… 195MB docker commit 操作只专注于可读可写层（Read-Write Layer），数据卷 VOLUME 挂载的目录内容，还有类似于 hosts、hostsname 和resolv.conf 等挂载文件，当然还有一些如 /proc 和 /sys 等虚拟文件系统的内容都将不会出现在打包后的镜像中 镜像常用命令搜索镜像使用 docker search 命令从DockerHub中搜索格式： 1docker search [OPTIONS] TERM OPTIONS说明： -f, --filter filter 根据指定条件过滤结果 --format string 通过Go语言模板文件展示镜像 --limit int 限制显示的个数 --no-trunc 显示完整的镜像描述 示例： 从Docker Hub查找所有镜像名包含nginx，并且收藏数大于500的镜像 12345docker search -f=stars=500 nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 8227 [OK]jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1300 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 538 [OK] 列出镜像使用 docker images 命令列出本地镜像格式： 1docker images [OPTIONS] [REPOSITORY[:TAG]] OPTIONS说明： -a, --all 显示所有的镜像 (默认隐藏中间层镜像) --digests 显示摘要 -f, --filter filter 显示满足条件的镜像 --format string 通过Go语言模板文件展示镜像 --no-trunc 显示完整的镜像信息 -q, --quiet 只显示镜像ID 示例： 查看本地镜像列表 123456docker images 或者 docker images lsgulj/centos-vim 1.0 1109b8f3ea78 4 hours ago 354MBnginx latest 7f70b30f2cc6 6 days ago 109MBcentos latest 2d194b392dd1 3 weeks ago 195MBpostgres latest 6152297591eb 3 weeks ago 289MBbusybox latest f6e427c148a7 3 weeks ago 1.15MB 其它使用方式： 123456789101112131415docker image lsdocker images -q # 只展示镜像的IDdocker images mysqldocker images mysql:5.7docker images --digests mysql:5.7 docker images -f since=mysql:5.7 # 展示 mysql:5.7 之后建立的镜像docker images --format \"&#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\" # 只展示镜像ID和仓库docker images -f \"dangling=true\" # 展示虚悬镜像 删除镜像使用 docker rmi 命令删除本地一个或多个镜像格式： 1docker rmi [OPTIONS] IMAGE [IMAGE...] [flags] OPTIONS说明： -f, --force 强制删除 --no-prune 不移除该镜像的过程镜像，默认移除 示例： 强制删除本地指定名称的镜像 1docker images rmi -f gitlab/gitlab-ce 其它使用方式： 123456789docker rmi -f 2aa1fe2f052b # 根据镜像ID删除指定镜像docker rmi gulj/centos-vim nginx busybox # 删除多个镜像docker rmi $(docker images -q redis) # 删除所有仓库名为reids的镜像docker rmi $(docker images -q -f dangling=true) # 删除所有的虚悬镜像docker rmi $(docker images -aq) # 删除所有的镜像","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 初识","slug":"docker-初识","date":"2018-03-27T01:44:09.000Z","updated":"2018-05-02T08:45:56.356Z","comments":true,"path":"2018/03/27/docker-初识/","link":"","permalink":"http://www.gulj.cn/2018/03/27/docker-初识/","excerpt":"介绍Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。 系统架构","text":"介绍Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。 系统架构 核心技术 Namespaces (namespace) Namespace是Linux提供的一种内核级别环境隔离的方法,提供了对UTS、IPC、mount、PID、network、User等的隔离机制。 Control groups (CGroup) 用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等） 可​​以让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU 时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合。 主要提供了一下功能 Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。 Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。 Accounting: 一些审计或一些统计，主要目的是为了计费。 Control: 挂起进程，恢复执行进程 Union file systems (AUFS) AUFS是一个能透明覆盖一或多个现有文件系统的层状文件系统。 支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。这种是一种虚拟的文件系统，文件系统不用格式化，直接挂载即可 当一个进程需要修改一个文件时，AuFS创建该文件的一个副本。AuFS可以把多层合并成文件系统的单层表示。这个过程称为写入复制copy on write ….等 核心组件 客户端 Client Docker client 是给用户和 Docker daemon 建立通信的客户端，安装了 docker 之后，二进制文件 docker 就是 Docker client，与 Docker daemon 交互， 通过客户端 docker 命令，我们可以方便地实现对 Docker image 和 container 的管理请求。 Docker client 与 docker daemon 建立请求的方式有三种，分别是： tcp://host:port unix://path/to/socket fd://socketfd 常驻后台的系统进程 Docker daemon Docker daemon 是一个常驻后台的系统进程，所谓“运行 docker”，指的就是运行 Docker daemon，其作用主要有以下两点： 接受并处理 Docker Client 发送的请求 管理所有的 Docker containers 和 Docker images Docker daemon 的架构大致可以分为三部分：Docker Server、Engine 和 Job。 docker daemon 监听来自 remote api 的请求的方式有三种：unix、tcp 和 fd 默认配置下，Docker daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，可以使用dockerd命令： 1dockerd -H 0.0.0.0 镜像 &nbsp;Image 镜像是一个只读的层（layer），由文件系统叠加构成，就相当于是一个 root 文件系统，通过它可以创建 Docker 容器（Container）。 分层存储，每一层都可以添加改变和删除文件，形成一个新的镜像 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层 不同的镜像可以共享相同的层 容器 &nbsp;Container Docker 容器是用于运行镜像的沙箱环境，它是 Docker 镜像的运行实例；容器都是相互隔离、互不可见的，我们可以理解为：镜像是Docker生命周期的打包和构建阶段，而容器是Docker的启动和执行阶段。 镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 在Image Layer之上建立一个 Container Layer（读写层），镜像（image）负责app的存储和分发，容器（Container）负责运行app 仓库 &nbsp;Registry Registry 是集中的存储、分发镜像的文件仓库 仓库分为公有仓库和私有仓库，常用的公有仓库是官方的 Docker Hub，默认的 docker pull 命令就是从官方的公有仓库中拉取镜像；个人可以根据Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"【Docker教程】Docker 安装","slug":"Docker-安装","date":"2018-03-26T09:23:17.000Z","updated":"2018-05-02T08:45:56.366Z","comments":true,"path":"2018/03/26/Docker-安装/","link":"","permalink":"http://www.gulj.cn/2018/03/26/Docker-安装/","excerpt":"导读本系列的docker学习笔者均采用Vagrant和VirtualBox进行，下面我会给出这两款工具的简单介绍。 Vagrant介绍Vagrant是hashicorp这家公司的产品，是一个让你可以方便设置你想要的虚拟机的便携式工具，它底层支持VirtualBox、VMware甚至AWS作为虚拟机系统。 我们可以通过Vagrant提供的命令行工具vagrant，可以快速启动根据我们事先定义好的Vagrantfile文件，来创建一个或者多个虚拟机。 Vagrantfile是用来定义vagrant project的，使用ruby语法。","text":"导读本系列的docker学习笔者均采用Vagrant和VirtualBox进行，下面我会给出这两款工具的简单介绍。 Vagrant介绍Vagrant是hashicorp这家公司的产品，是一个让你可以方便设置你想要的虚拟机的便携式工具，它底层支持VirtualBox、VMware甚至AWS作为虚拟机系统。 我们可以通过Vagrant提供的命令行工具vagrant，可以快速启动根据我们事先定义好的Vagrantfile文件，来创建一个或者多个虚拟机。 Vagrantfile是用来定义vagrant project的，使用ruby语法。 安装Vagrant支持Mac、Window,Centos 等各种平台，下图展示支持的各种平台列表 下载地址：https://www.vagrantup.com/downloads.html 查看是否安装成功 12# 查看vagrant版本信息$ vagrant version 使用 添加一个box 格式：vagrant box add 远端的box地址或者本地的box文件名 12# 添加 centos/7 的box$ vagrant box add centos/7 通过这个步骤，vagrant会去box列表中找centos/7这个镜像，如果没有就去官方下载 box的名称我们通过官方提供的地址:https://app.vagrantup.com/boxes/search?page=1 去search 初始化 格式： vagrant init box列表中box的名称 12345# 新建一个目录，为centos7$ mkdir centos7# 进入centos7目录，初始化box,这里的（centos/7）就是我们第一步添加的box名称$ vagrant init centos/7 这样就会在当前目录(centos7)生成一个Vagrantfile的文件,注意每个目录只能存放一个Vagrantfile文件，所以我们要事先定义好我们需要创建系统的目录 启动虚拟机 我们已经通过vagrant init centos/7 命令，得到了vagrantfile文件，下面我们可以通过vagrant up 命令来启动vagrantfile中定义的虚拟机 1$ vagrant up 这样我们就在在Virtualbox中创建了一个虚拟机 连接虚拟机 1$ vagrant ssh Vagrant 的其它基本命令 查看命令帮助 1$ vagrant --help 查看虚拟机的状态 1$ vagrant status 查看box列表 1$ vagrant box list 停止虚拟机 1$ vagrant halt 销毁虚拟机 1$ vagrant destory 通过自定义Vagrantfile来创建虚拟机 编写Vagrantfile,灵活的设置虚拟机的参数 1234567891011121314151617181920212223242526272829303132333435363738# -*- mode: ruby -*-# vi: set ft=ruby : Vagrant.require_version \"&gt;= 1.6.0\" boxes = [ &#123; :name =&gt; \"docker-node-test1\", :eth1 =&gt; \"192.168.215.10\", :mem =&gt; \"2048\", :cpu =&gt; \"2\" &#125;] Vagrant.configure(2) do |config| config.vm.box = \"centos/7\" boxes.each do |opts| config.vm.define opts[:name] do |config| config.vm.hostname = opts[:name] config.vm.provider \"vmware_fusion\" do |v| v.vmx[\"memsize\"] = opts[:mem] v.vmx[\"numvcpus\"] = opts[:cpu] end config.vm.provider \"virtualbox\" do |v| v.customize [\"modifyvm\", :id, \"--memory\", opts[:mem]] v.customize [\"modifyvm\", :id, \"--cpus\", opts[:cpu]] end config.vm.network :private_network, ip: opts[:eth1] end end #config.vm.synced_folder \"./labs\", \"/home/vagrant/labs\" #config.vm.provision \"bash\", privileged: true, path: \"./setup.sh\"end Vagrantfile下载地址： xxxx 创建虚拟机 1vagrant up Docker 安装 在 Mac 平台上安装 下载地址：https://www.docker.com/community-edition 在 centos7 平台上安装步骤 官网地址：https://docs.docker.com/install/linux/docker-ce/centos/#install-from-a-package 卸载老的版本 12345678910$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装docker ce (注意docker 有docker ce 和 docker ee 两个版本，我们学习使用docker ce版本) ①、安装依赖包 123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 ②、设置稳定仓库地址 123$ sudo yum-config-manager \\--add-repo \\https://download.docker.com/linux/centos/docker-ce.repo ③、【可选】启用 edge 和 test 仓库 1234567# 启用 --enable$ sudo yum-config-manager --enable docker-ce-edge$ sudo yum-config-manager --enable docker-ce-test# 禁用 --disable$ sudo yum-config-manager --disable docker-ce-edge ④、安装稳定版本的docker ce 1$ sudo yum install docker-ce ⑤、【可选】查看具体的docker ce 版本，这样我们可以在生产环境安装具体的docker ce 版本 1234567# 查看docker ce 版本列表$ yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 18.03.ce-1.el7.centos docker-ce-stable# 使用命令安装具体的docker ce 版本$ sudo yum install &lt;FULLY-QUALIFIED-PACKAGE-NAME&gt; ⑥、启动docker 1$ sudo systemctl start docker ⑦、验证docker是否正确安装，可以通过运行 helloworld 镜像 1$ sudo docker run hello-world docker-machine 创建docker主机如果我们已经在mac平台安装过docker，默认会自带docker-machine；到现在我们已经知道了，可以通过virtualbox这个虚拟机软件直接创建虚拟机，安装docker，得到一台docker主机、也可以通过编写vagrantfile创建虚拟机，安装docker，也能得到一台docker主机、现在我们还可以通过docker-machine命令，来创建一台带有docker的主机 查看版本信息 12345$ docker-machine -v # 或者 $ docker-machine create -d virtualbox demo 创建docker虚拟机 (使用 virtualbox 类型的驱动) 1$ docker-machine create demo 你也可以在创建时加上如下参数，来配置主机或者主机上的 Docker。 –engine-opt dns=114.114.114.114 配置 Docker 的默认 DNS –engine-registry-mirror https://registry.docker-cn.com 配置 Docker 的仓库镜像 –virtualbox-memory 2048 配置主机内存 –virtualbox-cpu-count 2 配置主机 CPU 查看虚拟机列表 1$ docker-machine ls 进入虚拟机 1$ docker-machine ssh demo 停止虚拟机 1$ docker-machine stop demo 现在我们已经在mac(宿主机)上安装了docker，又通过 docker-machine 方式创建，得到了一台docker主机；那么现在我们有这样一种需求，如何让宿主机上的docker client端连接，通过docker-machine创建的docker server端。 步骤 查看docker-machine创建虚拟机的环境变量 123456789# 在 mac（宿主机上） 执行 查看docker-machine$ docker-machine env demoexport DOCKER_TLS_VERIFY=\"1\"export DOCKER_HOST=\"tcp://192.168.99.100:2376\"export DOCKER_CERT_PATH=\"/Users/gulj/.docker/machine/machines/demo\"export DOCKER_MACHINE_NAME=\"demo\"# Run this command to configure your shell:# eval $(docker-machine env demo) 设置宿主机的docker环境变量为docker-machine创建的docker主机环境变量 1$ eval $(docker-machine env demo) 查看是否修改成功 123456789101112131415161718$ docker versionClient: Version: 17.12.0-ce API version: 1.35 Go version: go1.9.2 Git commit: c97c6d6 Built: Wed Dec 27 20:03:51 2017 OS/Arch: darwin/amd64Server: Engine: Version: 18.03.0-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.4 Git commit: 0520e24 Built: Wed Mar 21 23:14:54 2018 OS/Arch: linux/amd64 Experimental: false 这样宿主机的docker client端就已经连接到通过docker-machine创建的docker主机server端，那么我们在本地操作的docker任何命令，直接作用于 docker-machine 创建的docker主机 Docker 在线实验室 ，无需安装，直接使用地址 https://labs.play-with-docker.com/ 介绍Play With Docker ( Docker 在线实验室) 是一个运行在浏览器中的 Docker Playground，无需安装任何环境，就可以在线体验 Docker 使用","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.gulj.cn/tags/docker/"}]},{"title":"Charles进行HTTPS抓包","slug":"Charles进行HTTPS抓包","date":"2017-12-27T07:28:29.000Z","updated":"2018-05-02T08:45:56.364Z","comments":true,"path":"2017/12/27/Charles进行HTTPS抓包/","link":"","permalink":"http://www.gulj.cn/2017/12/27/Charles进行HTTPS抓包/","excerpt":"介绍Charles其实是一款代理服务器，通过成为电脑或者浏览器的代理，然后截取请求和请求结果达到分析抓包的目的。charles有Window版本和Mac OS版本，也同时支持ios和Android手机系统 下载百度云：Charles 4.2.1 Mac破解版 环境 Charles 4.2.1 Iphone 7P ios 11.0.1","text":"介绍Charles其实是一款代理服务器，通过成为电脑或者浏览器的代理，然后截取请求和请求结果达到分析抓包的目的。charles有Window版本和Mac OS版本，也同时支持ios和Android手机系统 下载百度云：Charles 4.2.1 Mac破解版 环境 Charles 4.2.1 Iphone 7P ios 11.0.1 使用前提 保证iOS设备iphone或ipad与运行Charles的mac电脑处于同一个wifi环境下 基本配置 ①、配置HTTP代理，这步与抓取HTTP请求是一样的 打开: charles 的 Proxy 选项选择 Proxy Settings 按照下图配置: x备注：选择在8888端口上监听，然后确定。够选了SOCKS proxy，还能截获到浏览器的http访问请求。 ②、配置SSL代理 打开： charles 的 Proxy 选项选择 SSL Proxy Settings在 SSL Proxying 的Tab项中 点击 Add 按钮，按下图填写 添加好之后，如下图展示： 手机端设置代理和安装Charles根证书1、手机端安装Charles根证书在Safri上地址栏粘贴 chls.pro/ss 点击立即前往，自动下载根证书 而在ios10.3之后，安装新的自定义证书默认是不受信任的，如果要信任已安装的自定义证书,需要手动打开开关以信任证书。 开始信任证书步骤：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可. 2、手机端手机设置代理打开： charles 的 Help 选项选择 Install Charles Root Certificate On a Mobile Device Or a Remote Browser 点击 ok 按钮 首先在Mac上，查看IP地址：方法一：系统偏好设置-&gt;网络-&gt;wifi-&gt;高级-&gt;TCP/IP方法二：ifcofnig 命令 （在终端或者Iterm上）本机Ip：192.168.6.174 打开手机： 设置界面，选择无线局域网 进入无线局域网界面，点击所连的无线网旁边的 i 图标 进入配置代理界面，点击底部的配置代理，改为手动模式 配置代理服务器地址：填写本机Mac的Ip地址，端口：填写 charles 的 代理端口，默认是：8888；也可以自定义修改 配置好之后，Mac上会弹出以下提示框，表示Charles软件检测到可供检测的设备。两个按钮选项：Allow 允许 ， Deny拒绝。我们要选择允许 电脑端(Mac)安装Charles根证书直接在Charles的Help菜单中安装；安装完成后去系统的钥匙串访问中信任它 在本机的系统的钥匙串访问中，找到Charles证书，默认是不被信任的，双击，该证书，修改为始终信任 效果展示 __","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"charles","slug":"charles","permalink":"http://www.gulj.cn/tags/charles/"}]},{"title":"ELK(5.6.3)技术栈集群搭建","slug":"ELK5-X技术栈集群搭建","date":"2017-11-24T14:28:29.000Z","updated":"2018-05-02T08:45:56.366Z","comments":true,"path":"2017/11/24/ELK5-X技术栈集群搭建/","link":"","permalink":"http://www.gulj.cn/2017/11/24/ELK5-X技术栈集群搭建/","excerpt":"1、ElasticSearch单节点和集群搭建 系统环境 系统/软件 版本 centos 7 jdk # es 依赖jdk 8 node # es 安装head插件需要 8.2.1 elasticsearch 5.6.3 logstash 5.6.3 kibana 5.6.3","text":"1、ElasticSearch单节点和集群搭建 系统环境 系统/软件 版本 centos 7 jdk # es 依赖jdk 8 node # es 安装head插件需要 8.2.1 elasticsearch 5.6.3 logstash 5.6.3 kibana 5.6.3 机器规划及节点分布 主机 节点 节点 节点 192.168.1.110 elasticsearch-master logstash kibana 192.168.1.111 Elasticsearch-slave1 logstash 192.168.1.112 Elasticsearch-slave2 logstash 目录分配 下载软件源码包存放的位置: 1/usr/local/src/ 安装位置: 1/usr/local/ 相关软件包官方下载地址 https://www.elastic.co/downloads ①、elasticsearch 单节点安装（192.168.1.110）下载： 1wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.3.tar.gz 解压缩 1tar -zxvf elasticsearch-5.6.3.tar.gz 创建软链接 1ln -s /usr/local/elasticsearch-5.6.3/ /usr/local/elasticsearch-master 创建elasticsearch用户，把elasticsearch-master的所有者和所有组设置为用户elasticsearch（ES不能以root用户启动） 123456# 添加 elasticsearch 用户useradd elasticsearch# 为 elasticsearch 用户设置密码passwd elasticsearch# 将 elasticsearch-master 的目录的所有者和所属组设置为用户 elasticsearchchown -R elasticsearch:elasticsearch /usr/local/elasticsearch-master 启动 123456# 进入es的根目录cd elasticsearch-master# 启动(放入后台启动，注意不能以root用户启动,以elasticsearch用户启动)./bin/elasticsearch -d# 访问eshttp://localhost:9200 elastisearch 安装常见错误日志和解决方案参考地址： 报错”max virtual memory areas vm.maxmapcount [65530] is too low”，要运行下面的命令。 1sudo sysctl -w vm.max_map_count=262144 其它报错信息解决方案参考地址 1http://www.jianshu.com/p/4c6f9361565b 测试ES服务是否启动正常（默认监听9200端口） 12345678910111213141516# 访问地址http://192.168.1.110:9200# 返回数据&#123;name: \"aRvmIj4\",cluster_name: \"elasticsearch\",cluster_uuid: \"tXoxyBvmSFGNkiJfAOJWXw\",version: &#123; number: \"5.6.3\", build_hash: \"1a2f265\", build_date: \"2017-11-24T20:33:39.012Z\", build_snapshot: false, lucene_version: \"6.6.1\"&#125;,tagline: \"You Know, for Search\"&#125; ES的Head插件安装（提供友好的web界面，es一些基本信息的查询） 下载 1wget https://github.com/mobz/elasticsearch-head/archive/master.zip 解压缩 1unzip master.zip 安装 123456# 进入 elasticsearch-head-master 目录cd elasticsearch-head-master# 执行 npm install npm install# 运行 npm run startnpm run start 访问ESHead插件（默认监听9100端口） http://localhost:9100 ES和Head插件关联配置(ES和Head插件属于两个不同的进程，解决跨域问题) 修改:elasticsearch-5.6.3/config/elasticsearch.yml配置文件 12345# 编辑ES配置文件vim elasticsearch.yml# 在配置文件最后添加两行配置http.cors.enabled: true # 注意yml文件的格式，true 前面有空格http.cors.allow-origin: \"*\" 最后重启ES服务和ES的Head插件，配置完成 ②、elasticsearch 集群（1 master，2个slave）-&gt; (192.168.1.110(master),192.168.1.111,192.168.1.112)基于第一步单节点(192.168.1.110)安装集群（我们把它设置为Master节点） 修改:elasticsearch-master/config/elasticsearch.yml配置文件 123456789101112131415161718192021# 解决跨域问题http.cors.enabled: truehttp.cors.allow-origin: \"*\"# 集群名称cluster.name: gulj-es# 节点名称node.name: es-master# 告知节点为master节点node.master: true# 设置是否为数据节点node.data: true# Ip地址network.host: 192.168.1.110# 端口http.port: 9200# 日志存放位置path.logs: /data/elasticsearch/logs# 数据存放位置path.data: /data/elasticsearch/data# 单播，配置集群中的所有节点discovery.zen.ping.unicast.hosts: [\"192.168.1.110\",\"192.168.1.111\"] 重新解压缩elasticsearch-5.6.3.tar.gz包复制两份， 分别命名为 elasticsearch_slave1（节点：192.168.1.111）和elasticsearch_slave2（节点：192.168.1.112） 12345# 解压缩 es 包tar -zxvf elasticsearch-5.6.3.tar.gz# 复制两份 es 并重命名cp -r elasticsearch-5.6.3 elasticsearch_slave1cp -r elasticsearch-5.6.3 elasticsearch_slave2 分别修改 elasticsearch_slave1、elasticsearch_slave2 的 elasticsearch.yml 配置文件 123456789101112131415161718192021# 集群名称cluster.name: gulj-es# 节点名称,注意salve2节点,需要命名为对应的es-slave02node.name: es-slave01# 不是masternode.master: false# 数据节点node.data: true# 绑定的Ipnetwork.host: 0.0.0.0# 绑定端口http.port: 9200# 日志位置path.logs: /data/elasticsearch/logs# 数据位置path.data: /data/elasticsearch/data# 单播发现discovery.zen.ping.unicast.hosts: [\"192.168.1.110\"]# 解决跨域http.cors.enabled: truehttp.cors.allow-origin: \"*\" elasticsearch_slave2的配置文件和elasticsearch_slave1的配置文件大致相同，只需要修改node.name（节点名称）这里不再演示(注意防火墙的设置，建议关闭) Elasticsearch Head 插件页面展示 2、logStash安装下载1wget https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.tar.gz 解压缩 1tar -zxvf logstash-5.6.3.tar.gz 创建软链接 12# 创建软连接ln -s /usr/local/logstash-5.6.3 /usr/local/logstash 创建logstash配置文件 12# 创建logstash配置文件vim logstash.conf logstash.conf 文件内容（根据各自的业务需求，收集相应的日志，具体语法，参考官方文档） 12345678910111213141516171819input &#123; file &#123; # 收集ES的Log日志 path =&gt; \"/data/elasticsearch/logs/gulj-es.log\" # 自定义类型 type =&gt; \"es-master\" # 从开始位置进行收集 start_position =&gt; \"beginning\" &#125;&#125;output&#123; elasticsearch&#123; # ES节点主机地址 hosts =&gt; [\"192.168.1.110:9200\"] # 设置索引名称 index =&gt; \"es-master-log\" &#125;&#125; 启动 12# 启动logstash./bin/logstash -f logstash.conf 3、Kibana安装下载 1wget https://artifacts.elastic.co/downloads/kibana/kibana-5.6.3-linux-x86_64.tar.gz 解压缩 1tar -zxvf kibana-5.6.3-linux-x86_64.tar.gz 创建软连接 1ln -s /usr/local/kibana-5.6.3-linux-x86_64 /usr/local/kibana 修改配置文件 1234567891011# 打开kibana配置文件vim kibana/conf/kibana.yml# 打开或修改以下配置参数# 监听端口server.port: 5601# 监听主机server.host: \"192.168.1.110\"# ES服务地址elasticsearch.url: \"http://192.168.1.110:9200\"# kibana的索引kibana.index: \".kibana\" 启动 12# 启动kibana./bin/kibana Kibana页面展示","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://www.gulj.cn/tags/elk/"}]},{"title":"ElasticSearch常用API使用教程","slug":"ElasticSearch常用API使用教程","date":"2017-11-10T02:44:00.000Z","updated":"2018-05-02T08:45:56.355Z","comments":true,"path":"2017/11/10/ElasticSearch常用API使用教程/","link":"","permalink":"http://www.gulj.cn/2017/11/10/ElasticSearch常用API使用教程/","excerpt":"ElasticSearch 常用API使用教程1、基本概念介绍 索引：含有相同属性的集合 类型：索引可以定义一个或者多个类型，文档必须属于一个类型 文档：文档是可以被索引的基本数据单位 分片：每个索引都有多个分片，每个分片都是Lucene索引 备份：拷贝一份分片就完成了分片的备份","text":"ElasticSearch 常用API使用教程1、基本概念介绍 索引：含有相同属性的集合 类型：索引可以定义一个或者多个类型，文档必须属于一个类型 文档：文档是可以被索引的基本数据单位 分片：每个索引都有多个分片，每个分片都是Lucene索引 备份：拷贝一份分片就完成了分片的备份 2、API使用 API基本格式：http://:/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt; 常用的HTTP动词：GET/PUT/POST/DELETE 索引操作新建索引 直接新建一个book索引 1$ curl -X PUT 'localhost:9200/book' 通过新建类型为program_book来新建book索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ curl -X PUT 'localhost:9200/book' -d '&#123; \"mappings\": &#123; \"program_book\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"author\": &#123; \"type\": \"keyword\" &#125;, \"number\": &#123; \"type\": \"integer\" &#125;, \"create_time\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125; &#125;&#125;'# 或者curl -X POST 'localhost:9200/book/program_book/_mapping?pretty' -d'&#123; \"program_book\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"author\": &#123; \"type\": \"keyword\" &#125;, \"number\": &#123; \"type\": \"integer\" &#125;, \"create_time\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125;&#125;' 通过插入一个或者多个文档来新建book索引 1234567$ curl -X PUT 'localhost:9200/book/program_book/1' -d ' &#123; \"title\": \"Java并发编程实战\", \"author\": \"Doug\", \"number\": 100, \"create_time\":\"2017-08-01\" &#125;' 查看新建的所有索引 1$ curl -X GET 'localhost:9200/_cat/indices?v' 删除索引 删除 book 索引 1$ curl -X DELETE 'localhost:9200/book' 类型操作 新建类型 新建 program_book 类型 123456789101112131415161718192021222324$ curl -X PUT 'localhost:9200/book' -d '&#123; \"mappings\": &#123; \"program_book\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"author\": &#123; \"type\": \"keyword\" &#125;, \"number\": &#123; \"type\": \"integer\" &#125;, \"create_time\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125; &#125;&#125;' 修改类型 索引book，给类型program_book 新增一个update_time字段 12345678910$ curl-XPOST'localhost: 9200/book/program_book/_mapping?pretty'-d'&#123; \"program_books\": &#123; \"properties\": &#123; \"update_time\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125;&#125;' 文档操作 新增文档 新增单条文档，指定Id 123456$ curl-XPUT'localhost: 9200/book/program_book/1'-d'&#123; \"title\": \"重构\", \"author\": \"佚名\", \"number\": 50, \"create_time\": \"2017-01-11\"&#125;' 新增单条文档，不指定id 123456$ curl-XPUT'localhost: 9200/book/program_book'-d'&#123; \"title\": \"重构\", \"author\": \"佚名\", \"number\": 50, \"create_time\": \"2017-01-11\"&#125;' 查看文档 查看/book/program_book/1这条记录，URL 的参数pretty=true表示以易读的格式返回。 1$ curl 'localhost:9200/book/program_book/1?pretty=true' 修改文档 修改就是使用 PUT 请求，重新发送一次新增文档的数据。 123456$ curl-XPUT'localhost: 9200/book/program_book/1'-d'&#123; \"title\": \"修改操作-重构\", \"author\": \"佚名\", \"number\": 50, \"create_time\": \"2017-01-11\"&#125;' 删除文档 1$ curl -X DELETE 'localhost:9200/book/program_book/1' 复杂查询 查询指定索引，指定类型的的所有文档(/Index/Type/_search) 1$ curl 'localhost:9200/book/program_book/_search?pretty' 使用 Match 查询,指定的匹配条件查询 12345678910111213141516171819curl'localhost: 9200/book/program_book/_search?pretty'-d'&#123; \"query\": &#123; \"match\": &#123; \"title\": \"重构\" &#125; &#125;, \"from\": 1, \"size\": 1, \"sort\": &#123; \"create_time\": &#123; \"order\": \"desc\" &#125; &#125;&#125;'# 参数解释# from 偏移量，指定查询从位置1开始（默认是从位置0开始）# size 指定返回数据的个数为1条# 根据 create_time 进行排序 使用 Match 查询,指定的匹配条件查询 （查询多个搜索关键字， Elastic 认为它们是or关系） 1234567curl'localhost: 9200/book/program_book/_search?pretty'-d'&#123; \"query\": &#123; \"match\": &#123; \"title\": \"重构 修改\" &#125; &#125;,&#125;' 使用 Must 查询,指定的匹配条件查询 （查询多个搜索关键字， Elastic 认为它们是and关系） 1234567891011$ curl 'localhost:9200/book/program_book/_search?pretty' -d ' &#123; \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"match\": &#123; \"desc\": \"重构\" &#125; &#125;, &#123; \"match\": &#123; \"desc\": \"修改\" &#125; &#125; ] &#125; &#125; &#125;'","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://www.gulj.cn/tags/elasticsearch/"}]},{"title":"Linux服务管理","slug":"Linux服务管理","date":"2017-10-11T09:36:27.000Z","updated":"2018-05-02T08:45:56.364Z","comments":true,"path":"2017/10/11/Linux服务管理/","link":"","permalink":"http://www.gulj.cn/2017/10/11/Linux服务管理/","excerpt":"运行级别 运行级别 含义 0 关机 1 单用户模式，只要用于系统修复 2 不完全的命令行模式，不含NFS模式 3 完整的命令行模式，就是标准字符页面 4 系统保留 5 图形模式 6 重启","text":"运行级别 运行级别 含义 0 关机 1 单用户模式，只要用于系统修复 2 不完全的命令行模式，不含NFS模式 3 完整的命令行模式，就是标准字符页面 4 系统保留 5 图形模式 6 重启 查看及修改系统运行级别12345678910// 查看系统运行级别// N：NULL。当前级别为3即字符界面，其上一个级别为N即为空，表示系统开机直接进入字符界面# runlevelN 3 // 修改系统运行级别// 进入图形级别，前提是安装图形界面# init 5 // 若未安装图形界面则会报错# runlevel3 5 // 仍然进入了5级别 查看及修改系统默认的运行级别12# vim /etc/inittabid:3:initdefault: 注：不要把开机启动级别设置为0或6级别。 服务启动和自启动启动：就是在当前系统中让服务启动，并提供功能。 自启动：指让服务在系统开机或重启动之后，随着系统的启动而自动启动服务。 注：在chkconfig –list 查看到服务在不同运行级别时，服务自启动是否开启，不能确定现在服务是否已经开启。 查询已安装的服务①、RPM包安装的服务chkconfig –list命令查看服务自启动状态，可以看到所有RPM包安装的服务 ②、源码包安装的服务查看服务安装位置，一般是/usr/local/目录下service、chkconfig、ntsysv都不能找到源码包安装的服务。 两者区别：主要是安装位置的不同 源码包：一般安装在/usr/local/目录下RPM包：默认安装位置 RMP包服务管理常规的rpm包文件安装位置： 路径 作用 /etc/init.d/ 启动脚本位置 /etc/sysconfig/ 初始化环境配置文件位置 /etc/ 配置文件位置 /etc/xinetd.conf xinetd配置文件 /etc/xinetd.d 基于xinetd服务的启动脚本 /var/lib/ 服务产生的数据放在这里 /var/log/ 日志 RMP包服务管理——独立服务的管理①、独立服务的启动 法一：/etc/init.d/ 独立服务名 或者 /etc/rc.d/init.d/ 独立服务名 start|stop|status|restart| 1234567// 查看apache http服务的状态，其中httpd为一个shell脚本文件# /etc/init.d/httpd status// 启动apache服务# /etc/init.d/httpd start// 早期Linux版本服务管理脚本放在/etc/rc.d/init.d/目录# /etc/rc.d/init.d/httpd status 法二：service 独立服务名 start|stop|restart|status| 123# service httpd status// centos 7# systemctl [start/stop/status/restart] 独立服务名 备注：上面两种方法一般无法管理源码包启动脚本，但可以把源码包启动脚本放置在/etc/init.d/目录下统一管理 ②、独立服务的自启动 法一：chkconfig [ - - level 运行级别 ] 服务名 1234# chkconfig [--level 运行级别] [独立服务名] [on/off]例如：# chkconfig --level 2345 httpd on # chkconfig httpd off # --level 2345 可以省略，默认就是2345级别 法二：修改文件：/etc/rc.d/rc.local 或者 /etc/rc.local 文件 123# vi /etc/rc.local 或者 vi /etc/rc.d/rc.local// 然后在尾部添加一行，例如# /etc/init.d/httpd start # 开机apache服务就会自启动 法三：ntsysv 命令管理自启动（可管理独立服务，和基于xinetd服务） 备注 ①、/etc/rc.d/rc.local文件是在系统启动时，把所有的服务启动完，用户登录到系统前最后执行的文件，因此系统会执行这个文件中的命令 ②、/etc/rc.local文件是/etc/rc.d/rc.local文件的软连接 RMP包服务管理——基于xinetd服务的管理安装xinetd服务 1# yum -y install xinetd 基于xinetd服务的启动 1234567891011121314151617181920// 显示rsync服务的端口# grep rsync /etc/services# vim /etc/xinetd.d/rsyncservice rsync&#123; flags = REUSE // 设置TCP/IP socket可重用 socket_type = stream wait = no // 允许多个连接同时连接 user = root // 启动服务的用户为root server = /usr/bin/rsync server_args = --daemon log_on_failure += USERID // 登录失败后，记录用户的ID disable = no // 开启rsync服务，开启：no 关闭：yes&#125;// 重启动xinetd服务# service xinetd restart 或者# systemctl restart xinetd (centos 7) 基于xinetd服务的自启动 123# checkconfig time-stream on// ntsysv命令# ntsysv 备注 xinetd的服务：实际上自启动与启动完全同步，自启动关闭/开启，启动同时关闭/开启,启动关闭/开启，自启动同时关闭/开启 源码包服务管理①、源码包安装服务的启动使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不通，可以查看源码包的安装说明，查看启动脚本的方法 1# /usr/local/apache2/bin/apachectl start|stop ②、源码包安装服务的自启动通过修改/etc/rc.d/rc.local文件加入启动命令 1# vim /etc/rc.d/rc.local // 加入/usr/local/apache2/bin/apachectl start ③、让源码包服务被服务管理命令识别（chkconfig，ntsysv，service） 让源码包的apache服务能被service命令管理启动 12# ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache # 软链接# service apache start 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动 1234567891011vim /etc/init.d/apache // 在apache启动脚本中添加# chkconfig: 35 86 76 # 格式：chkconfig : 运行级别 启动顺序 关闭顺序# description: source package apache # description的内容随意// 把源码包apache加入chkconfig 命令# chkconfig --add apache# chkconfig --list |grep apache# apache 0:关闭 1:关闭 2:关闭 3:开启 4:关闭 5:开启 6:关闭// 这时，ntsysv命令也可以管理apache# ntsysv systemctlsystemctl命令将service和chkconfig命令结合在了一起。这样通过一个命令就可以实现两个命令的功能。(CentOS 7 和 Ubuntu可用) 格式： 12systemctl 动作 服务名.servicesystemctl start|stop|restart|status 服务名.service 设置开机启动： 1systemctl enable httpd.service 取消开机启动： 1systemctl disable httpd.service 系统操作 1234systemctl reboot 重启systemctl poweroff 关机systemctl suspend 睡眠systemctl hibernate 休眠 分析启动进程 1systemd-analyze 分析各进程启动的时间 1systemd-analyze blame 服务管理总结","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.gulj.cn/tags/linux/"}]},{"title":"Java设计模式—适配器模式","slug":"Java设计模式—适配器模式","date":"2017-09-28T03:31:50.000Z","updated":"2018-05-22T06:42:41.693Z","comments":true,"path":"2017/09/28/Java设计模式—适配器模式/","link":"","permalink":"http://www.gulj.cn/2017/09/28/Java设计模式—适配器模式/","excerpt":"介绍适配器模式将一个类的接口适配成用户所期待的。一个适配器通常允许因为接口不兼容而不能一起工作的类能够在一起工作，做法是将类自己的接口包裹在一个已存在的类中 结构 目标(Target)角色：这就是所期待得到的接口 源(Adapee)角色：现在需要适配的接口。 适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。","text":"介绍适配器模式将一个类的接口适配成用户所期待的。一个适配器通常允许因为接口不兼容而不能一起工作的类能够在一起工作，做法是将类自己的接口包裹在一个已存在的类中 结构 目标(Target)角色：这就是所期待得到的接口 源(Adapee)角色：现在需要适配的接口。 适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。 类适配器 采用继承的方式 12345678910111213141516// 适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。public class Adapter extends Adaptee implements Target &#123; /** * 1.目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request() * * 2.但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容 * * 3.所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已 */ @Override public void Request() &#123; this.SpecificRequest(); &#125;&#125; 对象适配器 采用对象组合方式 代码示例假设在我们的系统中有一个已经存在的方法（Adaptee可以实现一个接口，也可以是一个对象类） Adaptee 12345678910111213/** * 需要被适配的对象 */public class Adaptee &#123; /** * 已经存在的方法 */ public void specificRequest() &#123; // TODO 具体业务方法 &#125;&#125; 由于已经存在的接口不能满足我们的需求，现在我们定义一个我们期望的目标接口 Target 123456789/** * 目标接口 */public interface Target &#123; /** * 目标方法 */ void request();&#125; 定义适配器 Adapter ，进行适配 Adaptee 123456789101112131415161718192021222324/** * 适配器类 */public class Adapter implements Target &#123; /** * 持有需要被适配的接口对象 */ private Adaptee adaptee; /** * 传入需要被适配的对象 * @param adaptee */ public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void request() &#123; // 新接口中，调用的是已经存在的方法 adaptee.specificRequest(); &#125;&#125; 测试代码 1234567891011121314public class Client &#123; public static void main(String[] args) &#123; // 创建需要被适配的对象 Adaptee adaptee = new Adaptee(); // 创建客户端需要调用的接口对象 Target target = new Adapter(adaptee); // 表面上调用的是自己的新定义的接口，其内部实现还是原有的方法 target.request(); &#125;&#125; 缺省适配器 在任何时候，如果不准备实现一个接口的所有方法时，就可以使用“缺省适配模式”制造一个抽象类，给出所有方法的默认空实现。这样，从这个抽象类再继承下去的子类就不必实现所有的方法了 代码示例定义一个动物 Animal 行为的接口 1234567891011121314151617public interface Animal &#123; /** * 游泳 */ void swim(); /** * 睡觉 */ void sleep(); /** * 飞翔 */ void fly();&#125; 我们知道麻雀只能飞翔，睡觉，但是不能在水里游泳；如我我们直接定义一个麻雀（Bird）类直接去实现动物（Animal）这个接口，那么 Animal 中游泳的方法我们也必须去实现 (这是接口的特性所导致)，为了解决这个问题，我们定义一个抽象类作为适配器的角色来解决这个问题 适配器类 Adapter 12345678910111213141516public abstract class Adapter implements Animal &#123; @Override public void swim() &#123; // 空实现 &#125; @Override public void sleep() &#123; // 空实现 &#125; @Override public void fly() &#123; // 空实现 &#125;&#125; 接下来我们定义麻雀类（Bird） 我们不直接实现接口（Animal），而是继承我们定义的适配器类 Adapter 1234567891011public class Bird extends Adapter &#123; @Override public void sleep() &#123; // TODO 业务实现 &#125; @Override public void fly() &#123; // TODO 业务实现 &#125;&#125; 适配器模式使用注意事项 适配器模式中被适配的接口 Adaptee 和适配成为的接口 Target 是没有关联的，Adaptee 和 Target 中的方法既可以是相同的，也可以是不同的","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java设计模式—装饰器模式","slug":"Java设计模式-装饰器模式","date":"2017-09-27T01:42:22.000Z","updated":"2018-05-02T08:45:56.365Z","comments":true,"path":"2017/09/27/Java设计模式-装饰器模式/","link":"","permalink":"http://www.gulj.cn/2017/09/27/Java设计模式-装饰器模式/","excerpt":"1、介绍装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能 ①、要点： 不改变原类文件 不使用继承 动态扩展","text":"1、介绍装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能 ①、要点： 不改变原类文件 不使用继承 动态扩展 ②、使用场景： 扩展一个类的功能 动态增加功能，动态撤销 在不想增加很多子类的情况下扩展类。 ③、优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 2、类图（经典） 在装饰模式中的角色有： 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 类图的结构可以变化的地方： Component接口可以是接口也可以是抽象类，甚至是一个普通的父类（这个强烈不推荐，普通的类作为继承体系的超级父类不易于维护） 装饰器的抽象父类Decorator并不是必须的。 3、代码示例抽象构件角色 12345public interface Component &#123; void operation();&#125; 具体的接口实现类，也就是俗称的原始对象，或者说待装饰对象 12345678public class ConcreteComponent implements Component &#123; @Override public void operation() &#123; //TODO 相关的业务代码 &#125;&#125; 抽象装饰器父类，它主要是为装饰器定义了我们需要装饰的目标是什么，并对Component进行了基础的装饰 12345678910111213public class Decorator implements Component &#123; private Component component; public Decorator(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; component.operation(); &#125;&#125; 具体装饰角色 12345678910111213public class ConcreteDecoratorA extends Decorator &#123; public ConcreteDecoratorA(Component component) &#123; super(component); &#125; @Override public void operation() &#123; super.operation(); // TODO 相关的修饰业务代码 A &#125;&#125; 12345678910111213public class ConcreteDecoratorB extends Decorator &#123; public ConcreteDecoratorA(Component component) &#123; super(component); &#125; @Override public void operation() &#123; super.operation(); // TODO 相关的修饰业务代码 B &#125;&#125; 测试类 1234567891011121314151617181920public class TestDecoratorPattern &#123; public static void main(String[] args) &#123; //原来的对象 Component component = new ConcreteComponent(); //装饰成A Decorator concreteDecoratorA = new ConcreteDecoratorA(component); //装饰成A以后再装饰成B Decorator concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA); concreteDecoratorB.operation(); //简写方式 Decorator decorator = new ConcreteDecoratorA(new ConcreteDecoratorB(component)); decorator.operation(); &#125;&#125; 4、装饰模式的简化类图如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如下图所示: 如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。如下图所示：","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java设计模式—策略模式","slug":"Java设计模式-策略模式","date":"2017-09-26T05:45:07.000Z","updated":"2018-05-02T08:45:56.365Z","comments":true,"path":"2017/09/26/Java设计模式-策略模式/","link":"","permalink":"http://www.gulj.cn/2017/09/26/Java设计模式-策略模式/","excerpt":"1、介绍 策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 2、 类图","text":"1、介绍 策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 2、 类图 3、角色划分● 环境(Context)角色：持有一个Strategy的引用。 ● 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 ● 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 4、代码示例抽象策略类 Strategy.java 123456789public interface Strategy &#123; /** * 策略方法 * * @param os */ void strategy(String os);&#125; 具体策略类(实现策略接口，提供具体算法) ConcreteStrategyA.java 123456789101112131415public class ConcreteStrategyA implements Strategy &#123; /** * 策略方法实现 A * * @param os */ @Override public void strategy(String os) &#123; // 具体的业务方法 &#125;&#125; ConcreteStrategyB.java 1234567891011121314public class ConcreteStrategyB implements Strategy &#123; /** * 策略方法实现 B * * @param os */ @Override public void strategy(String os) &#123; // 具体的业务方法 &#125;&#125; Context.java 持有具体策略类的实例，负责调用具体算法 123456789101112131415161718public class Context &#123; // 策略的引用 private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 策略方法 */ public void action(String os) &#123; strategy.strategy(os); &#125;&#125; 测试类 123456789101112public class TestStrategyPattern &#123; public static void main(String[] args) &#123; Context context = new Context(new ConcreteStrategyA()); context.action(\"A\"); context = new Context(new ConcreteStrategyB()); context.action(\"B\"); &#125;&#125; 5、策略模式优缺点①、 优点 算法可以自由切换 避免使用多重条件判断 扩展性良好 ②、缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java设计模式—代理模式","slug":"Java设计模式—代理模式","date":"2017-09-20T07:54:23.000Z","updated":"2018-05-02T08:45:56.362Z","comments":true,"path":"2017/09/20/Java设计模式—代理模式/","link":"","permalink":"http://www.gulj.cn/2017/09/20/Java设计模式—代理模式/","excerpt":"为什么使用代理我们在写一个功能函数时，经常需要在其中写入与功能不是直接相关但很有必要的代 码，如日志记录，信息发送，安全和事务支持等，这些枝节性代码虽然是必要的，但它会带来以下麻烦： 枝节性代码游离在功能性代码之外，它不是函数的目的，这是对OO是一种破坏 枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合，可重用性降低 从法理上说，枝节性代码应该监视着功能性代码，然后采取行动，而不是功能性代码通知枝节性代码采取行动，这好比吟游诗人应该是主动记录骑士的功绩而不是骑士主动要求诗人记录自己的功绩","text":"为什么使用代理我们在写一个功能函数时，经常需要在其中写入与功能不是直接相关但很有必要的代 码，如日志记录，信息发送，安全和事务支持等，这些枝节性代码虽然是必要的，但它会带来以下麻烦： 枝节性代码游离在功能性代码之外，它不是函数的目的，这是对OO是一种破坏 枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合，可重用性降低 从法理上说，枝节性代码应该监视着功能性代码，然后采取行动，而不是功能性代码通知枝节性代码采取行动，这好比吟游诗人应该是主动记录骑士的功绩而不是骑士主动要求诗人记录自己的功绩 定义代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能. 代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象 1、静态代理静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类. 下面举个案例来解释:模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.需要注意的是,代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法 代码示例 接口:IUserDao.java 123public interface IUserDao &#123; void save();&#125; 目标对象类:UserDao.java 12345public class UserDao implements IUserDao &#123; public void save() &#123; System.out.println(\"----已经保存数据!----\"); &#125;&#125; 代理对象:UserDaoProxy.java 12345678910111213public class UserDaoProxy implements IUserDao&#123; //接收保存目标对象 private IUserDao target; public UserDaoProxy(IUserDao target)&#123; this.target=target; &#125; public void save() &#123; System.out.println(\"开始事务...\"); target.save();//执行目标对象的方法 System.out.println(\"提交事务...\"); &#125;&#125; 测试类:App.java 1234567891011public class App &#123; public static void main(String[] args) &#123; //目标对象 UserDao target = new UserDao(); //代理对象,把目标对象传给代理对象,建立代理关系 UserDaoProxy proxy = new UserDaoProxy(target); proxy.save();//执行的是代理的方法 &#125;&#125; 静态代理总结 可以做到在不修改目标对象的功能前提下,对目标功能扩展. 缺点: 代理类和委托类实现相同的接口，同时要实现相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 2、动态代理动态代理有以下特点:​ ①、代理对象,不需要实现接口​ ②、代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)​ ③、动态代理也叫做:JDK代理,接口代理 JDK中生成代理对象的API： 代理类所在包:java.lang.reflect.Proxy JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是: 1static Object newProxyInstance(ClassLoader loader, Class [] interfaces, InvocationHandler handler) 注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为: ClassLoader loader:指定当前目标对象使用类加载器,用null表示默认类加载器 Class [] interfaces:需要实现的接口数组 InvocationHandler handler:调用处理器,执行目标对象的方法时,会触发调用处理器的方法,从而把当前执行目标对象的方法作为参数传入 代码示例: 接口类IUserDao.java以及接口实现类UserDao是一样的.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类中先建立目标对象和代理对象的联系,然后使用代理对象中的同名方法 1）、JDK动态代理 代理工厂类:ProxyFactory.java 1234567891011121314151617181920public class ProxyFactory &#123; //维护目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象生成代理对象 public Object getProxyInstance1() &#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), (Object proxy, Method method, Object[] args) -&gt; &#123; System.out.println(\"开始事务2\"); //执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(\"提交事务2\"); return returnValue; &#125;); &#125; &#125; 测试类:App.java 123456789101112131415161718/** * 测试类*/public class App &#123;public static void main(String[] args) &#123; // 目标对象 IUserDao target = new UserDao(); // 【原始的类型】 System.out.println(target.getClass()); // 给目标对象，创建代理对象 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); // com.sun.proxy.$Proxy0 内存中动态生成的代理对象 System.out.println(proxy.getClass()); // 执行方法 【代理对象】 proxy.save(); &#125;&#125; JDK动态代理总结: 代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理 Cglib代理 上面的静态代理和动态代理模式都是要求目标对象实现一个接口或者多个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用构建目标对象子类的方式实现代理,这种方法就叫做:Cglib代理 Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展. Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截) Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的子类. 代理的类不能为final,否则报错；目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法 代码示例:目标对象类:UserDao.java 123456789/** * 目标对象,没有实现任何接口 */public class UserDao &#123; public void save() &#123; System.out.println(\"----已经保存数据!----\"); &#125;&#125; Cglib代理工厂:ProxyFactory.java 123456789101112131415161718192021222324252627282930313233/** * Cglib子类代理工厂 * 对UserDao在内存中动态构建一个子类对象*/public class ProxyFactory implements MethodInterceptor&#123; //维护目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(target.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(\"开始事务...\"); //执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(\"提交事务...\"); return returnValue; &#125;&#125; 测试类: 12345678910111213141516/** * 测试类 */public class App &#123; @Test public void test()&#123; //目标对象 UserDao target = new UserDao(); //代理对象 UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance(); //执行代理对象的方法 proxy.save(); &#125;&#125; 在Spring的AOP编程中:如果加入容器的目标对象有实现接口,用JDK代理如果目标对象没有实现接口,用Cglib代理","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java设计模式—模板方法模式","slug":"JAVA设计模式—模板方法模式","date":"2017-09-19T05:27:12.000Z","updated":"2018-05-02T08:45:56.361Z","comments":true,"path":"2017/09/19/JAVA设计模式—模板方法模式/","link":"","permalink":"http://www.gulj.cn/2017/09/19/JAVA设计模式—模板方法模式/","excerpt":"1、介绍模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。","text":"1、介绍模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。 2、结构①、模板方法模式结构可以分为两个角色：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;抽象模板(Abstract Template)角色&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;具体模板(Concrete Template)角色②、模板方法模式的静态结构图如下所示： 这里涉及到两个角色：抽象模板(Abstract Template)角色职责： 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色职责： 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 3、代码示例抽象模板角色类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 抽象模板类 * * @author gulj * @create 2017-09-08 下午2:48 **/public abstract class AbstractTemplate &#123; /** * 模板方法（定义模板的算法，整体骨架，业务方法由具体子类实现） * * @param params * @return */ public final String templateMethod(String params) &#123;//核心的模板方法，不允许子类覆盖 long startTime = System.currentTimeMillis();//模板方法，统一的模板 /** * 具体的业务方法，可以有以下三种方式 */ System.out.println(\"---------------------------\"); // ①、需要所有子类实现各自的业务逻辑 String result = abstractMethod(params); // ②、本类已经实现的方法 concreteMethod(); // ③、需要的子类可以重写 hookMethod(); System.out.println(\"---------------------------\"); long endTime = System.currentTimeMillis();//模板方法，统一的模板 System.out.println(\"耗时时间：\" + (endTime - startTime)); return result; &#125; /** * 抽象方法，供子类具体实现，定义为protected，可以只保证子类来实现，外界不允许调用 * * @param params * @return */ protected abstract String abstractMethod(String... params); /** * 基本方法（已经实现） */ private final String concreteMethod() &#123; System.out.println(\"concreteMethod : 模板类实现已经实现的放方法\"); return null; &#125; /** * 基本方法(空方法) */ protected void hookMethod() &#123; /** * 我们可以定义一个空方法，这样可以保证不是所有子类都需要重写该方法 */ System.out.println(\"hookMethod : 模板类的空方法，可供某些子类进行重写\"); &#125;&#125; 具体模板角色类 123456789101112131415161718192021/** * 具体模板角色类 * * @author gulj * @create 2017-09-08 下午3:25 **/public class ConcreteTemplate extends AbstractTemplate &#123; /** * 重写父类的抽象方法 * * @param params * @return */ @Override protected String abstractMethod(String... params) &#123; System.out.println(\"abstractMethod : 子类实现模板类中的抽象方法\"); return null; &#125;&#125; 测试代码 12345678910111213141516171819202122232425262728/** * @author gulj * @create 2017-09-08 下午3:29 **/public class TestTemplateDesignMain &#123; public static void main(String[] args) &#123; //子类实例 ConcreteTemplate concreteTemplate = new ConcreteTemplate(); //调用弗父类的模板方法 concreteTemplate.templateMethod(\"\"); /** * 测试结果 * --------------------------- abstractMethod : 子类实现模板类中的抽象方法 concreteMethod : 模板类实现已经实现的放方法 hookMethod : 模板类的空方法，可供某些子类进行重写 --------------------------- 耗时时间：1 */ &#125;&#125; 4、说明模板方法中的方法可以分为两大类：模板方法和基本方法。 ①、模板方法 一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。 一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 ②、基本方法 基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。 抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换，如代码示例中的：concreteMethod()方法。 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现，如代码示例中的：hookMethod()方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"java设计模式-单例模式","slug":"java设计模式-单例模式","date":"2017-09-18T09:43:24.000Z","updated":"2018-05-08T09:45:08.160Z","comments":true,"path":"2017/09/18/java设计模式-单例模式/","link":"","permalink":"http://www.gulj.cn/2017/09/18/java设计模式-单例模式/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"java设计模式-建造者模式","slug":"java设计模式-建造者模式","date":"2017-09-17T10:43:13.000Z","updated":"2018-05-22T07:52:56.990Z","comments":true,"path":"2017/09/17/java设计模式-建造者模式/","link":"","permalink":"http://www.gulj.cn/2017/09/17/java设计模式-建造者模式/","excerpt":"介绍建造者模式（英：Builder Pattern）是一种创建型设计模式，又名：生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)。 结构","text":"介绍建造者模式（英：Builder Pattern）是一种创建型设计模式，又名：生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)。 结构 抽象建造者（Builder）角色: 可以是一个接口或者抽象类，主要用于规范产品对象的各个组成成分的建造 具体建造者（ConcreteBuilder）角色: 实现抽象建造者Builder所声明的接口 提供产品实例，用户构建产品 导演者（Director）角色: 调用具体建造者角色以创建产品对象 产品（Product）角色: 最终构建成具体产品 导演者角色是与客户端打交道的角色。导演者将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体建造者角色。具体建造者角色是做具体建造工作的，但是却不为客户端所知 代码示例产品 Product 123456789101112public class Product &#123; private String partA; private String partB; private String partC; // .......省去 get set 方法 ......&#125; 抽象建造者 Builder 123456789101112131415161718public interface Builder &#123; /** * 定义构造产品 A 部件 */ void buildPartA(); /** * 定义构造产品 B 部件 */ void buildPartB(); /** * 定义构造产品 C 部件 */ void buildPartC();&#125; 具体建造者 ConcreteBuilder 12345678910111213141516171819202122232425262728293031323334353637public class ConcreteBuilder implements Builder &#123; // 创建一个产品的实例 Product product = new Product(); /** * 具体实现构建产品的 A 部件 */ @Override public void buildPartA() &#123; product.setPartA(); &#125; /** * 具体实现构建产品的 B 部件 */ @Override public void buildPartB() &#123; product.setPartB(); &#125; /** * 具体实现构建产品的 C 部件 */ @Override public void buildPartC() &#123; product.setPartC(); &#125; /** * 返回构建的产品 * @return */ public Product getProduct() &#123; return product; &#125;&#125; 导演者 Director 1234567891011121314151617181920212223public class Director &#123; // 建造器对象 private Builder builder; // 通过构造函数传入 public Director(Builder builder) &#123; this.builder = builder; &#125; /** * 负责调用构建产品的各个方法 */ public void construct() &#123; builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); &#125;&#125; 测试代码 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); // 构造产品 director.construct(); // 获取构造后的产品 Product product = builder.getProduct(); &#125;&#125; 使用Builder模式来构建复杂对象 遇到多个构造器参数时要考虑用构建器 若User类，只有姓名(name) 和 手机号(phone) 是必选参数，其它都是可选参数，如果此刻我们不同的业务需要构建不同参数的User对象，我们可以使用不同参数的构造函数，那么我们的类中是这样 使用构造函数方式构造对象的User类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class User &#123; /** * 姓名 */ private String name; /** * 手机号 */ private String phone; /** * 邮件 */ private String email; /** * 年龄 */ private int age; /** * 出生日期 */ private Date birthDay; public User() &#123; &#125; /** * 必选参数的构造器 * * @param name * @param phone */ public User(String name, String phone) &#123; this.name = name; this.phone = phone; &#125; /** * 含有可选参数的构造器 * * @param name * @param phone * @param email */ public User(String name, String phone, String email) &#123; this.name = name; this.phone = phone; this.email = email; &#125; /** * 含有可选参数的构造器 * * @param name * @param phone * @param email */ public User(String name, String phone, String email, int age) &#123; this.name = name; this.phone = phone; this.email = email; this.age = age; &#125; /** * 含有可选参数的构造器 * * @param name * @param phone * @param email */ public User(String name, String phone, String email, int age, Date birthDay) &#123; this.name = name; this.phone = phone; this.email = email; this.age = age; this.birthDay = birthDay; &#125;&#125; 测试代码1234567891011121314public class Cient &#123; public static void main(String[] args) &#123; User user1 = new User(\"admin\",\"110\"); User user2 = new User(\"admin\",\"110\",\"110@gmail.com\"); User user3 = new User(\"admin\",\"110\",\"110@gmail.com\",110); &#125; &#125; 使用建造者模式来构建对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class User &#123; /** * 姓名 */ private String name; /** * 手机号 */ private String phone; /** * 邮件 */ private String email; /** * 年龄 */ private int age; /** * 出生日期 */ private Date birthDay; // 私有构造方法 private User(UserBuilder builder) &#123; this.name = builder.name; this.phone = builder.phone; this.email = builder.email; this.age = builder.age; this.birthDay = builder.birthDay; &#125; public static class UserBuilder &#123; // required (必须) private String name; private String phone; // optional (可选) private String email; private int age; private Date birthDay; /** * 构造方法，传入必须的参数 * * @param name * @param phone */ public UserBuilder(String name, String phone) &#123; this.name = name; this.phone = phone; &#125; /** * 构造可选参数 email * * @param email * @return */ public UserBuilder setEmail(String email) &#123; this.email = email; return this; &#125; /** * 构建可选参数 age * * @param age * @return */ public UserBuilder setAge(int age) &#123; this.age = age; return this; &#125; /** * 构建可选参数 birthDay * * @param birthDay * @return */ public UserBuilder setBirthDay(Date birthDay) &#123; this.birthDay = birthDay; return this; &#125; /** * 构建 User 对象并返回 * * @return */ public User build() &#123; return new User(this); &#125; &#125;&#125; 测试代码123456789101112public class Cient &#123; public static void main(String[] args) &#123; User user = new User.UserBuilder(\"admin\",\"110\") .setAge(100) .setEmail(\"110@gmail.com\") .build(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.gulj.cn/tags/设计模式/"}]},{"title":"Java静态代码块，构造代码块，构造函数","slug":"Java-静态代码块，构造块，构造函数","date":"2017-09-12T06:17:00.000Z","updated":"2018-05-02T08:45:56.364Z","comments":true,"path":"2017/09/12/Java-静态代码块，构造块，构造函数/","link":"","permalink":"http://www.gulj.cn/2017/09/12/Java-静态代码块，构造块，构造函数/","excerpt":"1、介绍①、构造函数 123pubic HelloWorld()&#123; &#125; 说明 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的。 构造函数的作用是用于给对象进行初始化。 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。","text":"1、介绍①、构造函数 123pubic HelloWorld()&#123; &#125; 说明 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的。 构造函数的作用是用于给对象进行初始化。 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。 ②、构造代码块 123&#123; // 构造代码块&#125; 说明 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的 构造函数的作用是用于给对象进行初始化 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次 ③、静态代码块 123static &#123; // 静态代码块&#125; 说明 它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的 静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。 静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。 一个类中可以有多个静态代码块 2、三者执行顺序1、静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。 三者的执行顺序应该为：静态代码块 &gt; main() &gt; 构造代码块 &gt; 构造函数。 3、代码示例①、普通类初始化 123456789101112131415161718192021public class HelloWorld &#123; public HelloWorld() &#123; System.out.println(\"helloWorld 构造函数.....\"); &#125; &#123; System.out.println(\"普通代码块......\"); &#125; static &#123; System.out.println(\"静态代码块\"); System.out.println(\"--------------------\"); &#125; public static void main(String[] args) &#123; HelloWorld A = new HelloWorld(); System.out.println(\"*******************\"); HelloWorld B = new HelloWorld(); &#125;&#125; 执行结果 1234567静态代码块--------------------普通代码块......helloWorld 构造函数.....*******************普通代码块......helloWorld 构造函数..... ②、继承体系初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class HelloWorld &#123; public static String name = \"父类:HelloWorld——&gt;静态变量\"; public HelloWorld() &#123; System.out.println(\"父类:HelloWorld——&gt;构造函数.....\"); &#125; &#123; System.out.println(\"父类:HelloWorld——&gt;普通代码块......\"); &#125; static &#123; System.out.println(name); System.out.println(\"父类:HelloWorld——&gt;静态代码块\"); &#125;&#125;public class ChildHelloWorld extends HelloWorld &#123; private static String childName = \"子类:ChildHelloWord——&gt;静态变量\"; public ChildHelloWorld() &#123; System.out.println(\"子类:ChildHelloWorld——&gt;构造函数.....\"); &#125; &#123; System.out.println(\"子类:ChildHelloWorld——&gt;普通代码块......\"); &#125; static &#123; System.out.println(childName); System.out.println(\"子类:ChildHelloWorld——&gt;静态代码块......\"); &#125; public static void main(String[] args) &#123; System.out.println(\"子类:main()方法.....\"); new ChildHelloWorld(); &#125;&#125; 执行结果 123456789父类:HelloWorld——&gt;静态变量父类:HelloWorld——&gt;静态代码块子类:ChildHelloWord——&gt;静态变量子类:ChildHelloWorld——&gt;静态代码块......子类:main()方法.....父类:HelloWorld——&gt;普通代码块......父类:HelloWorld——&gt;构造函数.....子类:ChildHelloWorld——&gt;普通代码块......子类:ChildHelloWorld——&gt;构造函数..... Java 初始化顺序图","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.gulj.cn/tags/java/"}]},{"title":"JAVA三大特性—多态","slug":"JAVA三大特性—多态","date":"2017-09-12T03:13:27.000Z","updated":"2018-05-02T08:45:56.361Z","comments":true,"path":"2017/09/12/JAVA三大特性—多态/","link":"","permalink":"http://www.gulj.cn/2017/09/12/JAVA三大特性—多态/","excerpt":"1、介绍 多态是同一个行为具有多个不同表现形式或形态的能力 多态就是同一个接口，使用不同的实例而执行不同操作 多态性是对象多种表现形式的体现。 2、多态存在的必要条件","text":"1、介绍 多态是同一个行为具有多个不同表现形式或形态的能力 多态就是同一个接口，使用不同的实例而执行不同操作 多态性是对象多种表现形式的体现。 2、多态存在的必要条件 继承 子类重写父类方法 父类引用指向子类对象 比如： 1Parent parent = new Child(); // 使用父类类型的引用指向子类的对象 3、代码示例①、基于继承实现的多态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Animal &#123; public String name = \"animal\"; public void eat(Animal animal)&#123; System.out.println(\"animal say ......\"); &#125; public void sleep()&#123; System.out.println(\"animal sleep......\"); &#125; public static void speak()&#123; System.out.println(\"animal speak .......\"); &#125;&#125;public class Cat extends Animal &#123; /** * 重写父类的eat()方法 * * @param animal */ @Override public void eat(Animal animal) &#123; System.out.println(\"****************************************\"); if (animal instanceof Animal) &#123; System.out.println(\"animal is instanceof Animal.....\"); &#125; if (animal instanceof Cat) &#123; System.out.println(\"animal is instanceof Cat.....\"); &#125; if (animal instanceof Dog) &#123; System.out.println(\"animal is instanceof Dog.....\"); &#125; if (animal instanceof Object) &#123; System.out.println(\"animal is instanceof Object.....\"); &#125; System.out.println(animal + \" say .......\"); System.out.println(\"****************************************\"); &#125;&#125;public class Dog extends Animal &#123; public String name = \"dog\"; /** * 重写父类的sleep()方法 */ @Override public void sleep() &#123; System.out.println(\"dog sleep......\"); &#125; public static void speak() &#123; System.out.println(\"dog speak .......\"); &#125;&#125;//测试案例public class TestMain &#123; public static void main(String[] args) &#123; Animal animal1 = new Cat(); //父类的引用，根据传入不同的子类实例，在运行期间会表现出具体子类的特征 animal1.eat(new Cat()); animal1.eat(new Dog()); Animal animal2 = new Dog(); animal2.sleep(); // 非静态方法，JVM调用的是具体子类的sleep(Dog)的方法 animal2.speak(); // 静态方法不能被重写，仍然调用的是父类的speak方法 System.out.println(animal2.name); //字段不具有多态性，仍然是父类的属性值 &#125;&#125; 测试结果 1234567891011121314151617// animal 对象体现的多态性，是 Animal,Dog,Object的实例****************************************animal is instanceof Animal.....animal is instanceof Cat.....animal is instanceof Object.....com.gulj.springbootvalidator.duotai.Cat@378bf509 say .......********************************************************************************animal is instanceof Animal.....animal is instanceof Dog.....animal is instanceof Object..... com.gulj.springbootvalidator.duotai.Dog@5fd0d5ae say .......****************************************dog sleep......animal speak ....... 总结说明 对象具有两种类型： 编译类型（编译类型必须是运行类型的父类或相同） 运行类型 在形式上，类定义的对象只能看到自己所属类中的成员。父类对象无法看到子类的新扩充方法。 父类被关键词static修饰的静态方法是不能被子类覆盖的，可以利用这一特性达到隐藏的效果 使用父类类型的引用指向子类的对象 当子类和父类存在相同的字段时候，无论修饰符是什么，都会在各自的内存空间中存储数据，则字段不具有多态性 如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法 12// final修饰的对象不能改变其值；只能指向animal这个地址（引用关系不能变）但是对象里面的值可以改变。final Animal animal = new Cat(); ②、基于接口实现的多态（不在举例，读者可以自行实现） 在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.gulj.cn/tags/java/"}]},{"title":"Java内部类—匿名内部类","slug":"Java-内部类之匿名内部类","date":"2017-09-11T06:19:43.000Z","updated":"2018-05-02T08:45:56.363Z","comments":true,"path":"2017/09/11/Java-内部类之匿名内部类/","link":"","permalink":"http://www.gulj.cn/2017/09/11/Java-内部类之匿名内部类/","excerpt":"1、介绍①、匿名内部类是没有名字的内部类，因为没有名字所以没办法引用。必须在创建时，作为 new 语句的一部分来声明，只能使用一次 ②、使用前提：必须继承一个父类或实现一个接口 2、结构","text":"1、介绍①、匿名内部类是没有名字的内部类，因为没有名字所以没办法引用。必须在创建时，作为 new 语句的一部分来声明，只能使用一次 ②、使用前提：必须继承一个父类或实现一个接口 2、结构 ①、匿名内部类形式如下： new 类或接口{ ​ //方法主体 } 3、代码示例①、原始抽象类的基本实现 123456789101112131415161718192021222324public abstract class Animal &#123; /** * 动物有吃的行为 */ public abstract void eat();&#125;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼。。。。\"); &#125;&#125;public class TestCatMain &#123; public static void main(String[] args) &#123; Animal animal = new Cat(); animal.eat(); &#125;&#125; 备注： ​ 如果此处的Cat类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？这个时候就引入了匿名内部类 ②、在抽象类中使用内部类 1234567891011121314151617181920212223public abstract class Animal &#123; /** * 动物有吃的行为 */ public abstract void eat();&#125;public class TestAnonymousInnerClassCatMain &#123; public static void main(String[] args) &#123; Animal animal = new Animal() &#123;//直接将抽象类Animal中的方法在大括号中实现了 @Override public void eat() &#123; System.out.println(\"在chou。。。。\"); &#125; &#125;; animal.eat(); &#125;&#125; ③、在接口上使用匿名内部类 12345678910111213141516171819202122//接口定义public interface IAnimal &#123; /** * 动物有吃的行为 */ void eat();&#125;//测试匿名内部类public class TestAnonymousInnerClassCatMain &#123; public static void main(String[] args) &#123; IAnimal iAnimal = new IAnimal() &#123; @Override public void eat() &#123; System.out.println(\"在接口中使用的匿名内部类。。。。\"); &#125; &#125;; iAnimal.eat(); &#125;&#125; 总结 匿名内部类不能有构造方法，但可以调用父类的构造方法。 匿名内部类不能定义任何静态成员，方法和类。 一般使用代码块为匿名内部类提供初始化工作","categories":[{"name":"Java","slug":"Java","permalink":"http://www.gulj.cn/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.gulj.cn/tags/java/"}]},{"title":"shell编程—条件表达式","slug":"shell编程之条件表达式","date":"2017-09-01T01:32:39.000Z","updated":"2018-05-02T08:45:56.359Z","comments":true,"path":"2017/09/01/shell编程之条件表达式/","link":"","permalink":"http://www.gulj.cn/2017/09/01/shell编程之条件表达式/","excerpt":"1、字符串操作符比较 常用字符串测试操作符 说明 -z “字符串” 若串长度为0则真，-z可以理解为zero -n “字符串” 若串长度不为0则真，-n可以理解成no zero “串 1” = “串2” 若串1等于串2则真，可使用“==” 代替“=“ “串 1” != “串2” 若串1不等于串2则真，可使用“!==” 代替“!=“","text":"1、字符串操作符比较 常用字符串测试操作符 说明 -z “字符串” 若串长度为0则真，-z可以理解为zero -n “字符串” 若串长度不为0则真，-n可以理解成no zero “串 1” = “串2” 若串1等于串2则真，可使用“==” 代替“=“ “串 1” != “串2” 若串1不等于串2则真，可使用“!==” 代替“!=“ 注意： ①、以上表格中的字符串测试操作符好务必使用”“引起来（字符串或字符串变量比较都要加双引号之后再比较） ②、比较符号两端有空格（字符串或字符串变量比较，比较符号两端最好有空格） 代码示例： 123# 字符串比较[root@docker-02 ~]# [ -z \"abc\" ] &amp;&amp; echo 1 || echo 00 2、整数二元比较操作符 在[]以及test中使用的比较符 在(())和[[]]中使用的比较符 说明 -eq == 或 = equal 的缩写，相等 -ne != not equal 的缩写，不相等 -gt &gt; 大于 greater than -ge &gt;= 大于等于 greater equal -lt &lt; 小于 类似 less than -le &lt;= 小于等于 less equal 代码示例： 123456789#[root@docker-02 ~]# [ 2 -eq 1 ] &amp;&amp; echo 1 || echo 00#[root@docker-02 ~]# [ 2 -eq 2 ] &amp;&amp; echo 1 || echo 01#[root@docker-02 ~]# ((2&gt;3)) &amp;&amp; echo 1 || echo 00 小结：整数比较笔者推荐下面用法 ①、[ $num1 -eq $num2 ] # 注意空格，和比较符号 ②、(($num1&gt;$num2)) # 无需空格，常规数学比较符号 3、逻辑连接符 在[]和test中使用的逻辑操作符 在[[]]中使用的逻辑操作符 说明 -a &amp;&amp; and与，两端都为真，则真 -o or或，两端有一个为真则真 ! ! not非，相反则为真 代码示例： 12345#a=1b=2[root@docker-02 ~]# [ $a -eq 1 -a $b -eq 2 ] &amp;&amp; echo 1 || echo 01 小结：①、-a 和 &amp;&amp; 的运算规则：只有两端都是1才是真 ②、[] 中用-a、-o、！ ③、[[]] 中用&amp;&amp;、||、！","categories":[{"name":"运维","slug":"运维","permalink":"http://www.gulj.cn/categories/运维/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://www.gulj.cn/tags/shell/"}]},{"title":"Adobe Photoshop CC 2017 Mac中文破解版","slug":"Adobe-Photoshop-CC-2017-Mac中文破解版","date":"2017-08-22T09:26:06.000Z","updated":"2018-05-02T08:45:56.357Z","comments":true,"path":"2017/08/22/Adobe-Photoshop-CC-2017-Mac中文破解版/","link":"","permalink":"http://www.gulj.cn/2017/08/22/Adobe-Photoshop-CC-2017-Mac中文破解版/","excerpt":"Photoshop CC 2017是一个全新的版本，拥有很多新的特性，比如：应用程式内搜寻、加快上手速度、增强属性面板、Creative Cloud Assets改良功能等等，总之功能更加的强大。","text":"Photoshop CC 2017是一个全新的版本，拥有很多新的特性，比如：应用程式内搜寻、加快上手速度、增强属性面板、Creative Cloud Assets改良功能等等，总之功能更加的强大。 1、破解安装方法①、打开dmg镜像，双击“Install”进行安装，登陆Adobe ID（没有注册一个）完成安装； ②、解压缩“Adobe Zii cc2017.zip”，双击“Adobe Zii.app”，点击“PATCH OR DRAG”后提示“COMPLETED”完成破解；（如果之前安装了其他旧版本的Adobe软件，这里建议拖拽“PS CC 2017.app”到破解补丁中的“PATCH OR DRAG”上，否则会导致旧版本崩溃！) 2、下载地址 ①、Adobe Photoshop CC 2017 Mac中文版下载 密码：cthe ②、Adobe Zii 2.2 破解补丁下载 备注: 1、安装Adobe系列的软件时显示文件破坏或者文件不全的解决方案：大家到Adobe文件中右键程序显示包内容—Contents—MacOS里直接双击“Install”即可 2、如果大家需要切换中、英文语言，可以到“首选项”—“界面…”—“文本”—“用户界面语言”中选择，重启生效！ 3、系统版本要求：OS X 10.10 或更高。","categories":[{"name":"工具","slug":"工具","permalink":"http://www.gulj.cn/categories/工具/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.gulj.cn/tags/mac/"}]},{"title":"Frp 的介绍使用与安装","slug":"Frp-的介绍使用与安装","date":"2017-08-20T10:53:05.000Z","updated":"2018-05-02T08:45:56.367Z","comments":true,"path":"2017/08/20/Frp-的介绍使用与安装/","link":"","permalink":"http://www.gulj.cn/2017/08/20/Frp-的介绍使用与安装/","excerpt":"1、frp 介绍 frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 2、frp 作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。","text":"1、frp 介绍 frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 2、frp 作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。 3、frp 安装( server 端 ) frp : 分为Server端和Client端 请根据自己的机器系统分别下载最新稳定的Frp版本 例如： 服务端是Linux系统， 则下载Linx系统对应的版本：frp_0.13.0_linux_amd64.tar.gz 客户端是Osx系统，则下载Osx系统对应的版本：frp_0.13.0_darwin_amd64.tar.gz Frp下载地址：frp release 各种版本下载 Server 端 ①、安装与配置修改 frps.ini 文件，这里使用了最简化的配置： [common] bind_port = 7000 # 与客户端通信接口 建议保持不变 dashboard_port = 7001 # dashboard 端口 控制台界面端口 自定义 dashboard_user = test # dashboard 控制台界面 用户名 自定义 dashboard_pwd = test # dashboard 控制台界面 密码 自定义 privilege_token = token # 权限token 自定义 ②、启动nohup ./frps -c ./frps.ini &amp; Client 端 ①、安装与配置修改 frpc.ini 文件，假设 frps 所在服务器的公网 IP 为 x.x.x.x [common] server_addr = x.x.x.x # 服务器的公网Ip server_port = 7000 # 与服务端的 bind_port 值 保持一致 dashboard_user = test # 与服务端的 dashboard_user 值 保持一致 dashboard_pwd = test # 与服务端的 dashboard_pwd 值 保持一致 privilege_token = token # 与服务端的 privilege_token 值 保持一致 [ssh] type = tcp # 采取Tcp协议 local_ip = 127.0.0.1 # 本地地址 local_port = 8083 # 映射的本地端口 remote_port = 6000 # 与服务端连接端口 备注： 12345678nginx 配置server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://服务器IP:6000; &#125; &#125; 简易流程图如下： ②、启动nohup ./frpc -c ./frpc.ini &amp;","categories":[{"name":"工具","slug":"工具","permalink":"http://www.gulj.cn/categories/工具/"}],"tags":[{"name":"frp","slug":"frp","permalink":"http://www.gulj.cn/tags/frp/"}]},{"title":"使用 ShadowSocks 在 VPS 上搭建 VPN","slug":"使用-ShadowSocks-在-VPS-上搭建-VPN","date":"2017-08-16T08:45:56.000Z","updated":"2018-05-02T08:45:56.362Z","comments":true,"path":"2017/08/16/使用-ShadowSocks-在-VPS-上搭建-VPN/","link":"","permalink":"http://www.gulj.cn/2017/08/16/使用-ShadowSocks-在-VPS-上搭建-VPN/","excerpt":"&nbsp;&nbsp;&nbsp;我们都使用过很多免费的VPN工具，比如蓝灯，但是使用效果并不是很理想，而且有流量限制。有的人也使用过一些收费的VPN，比如：Astrill，鱼摆摆等等。虽然价格并不是很高，但是还是有一定的费用，而且有的还有多用户限制。总之不管收费的，免费的，或多或少我们在使用的过程中有些不爽，今天笔者为大家带来在自己的VPS上搭建一套VPN，想怎么用就怎么用，话不多说，直奔主题。","text":"&nbsp;&nbsp;&nbsp;我们都使用过很多免费的VPN工具，比如蓝灯，但是使用效果并不是很理想，而且有流量限制。有的人也使用过一些收费的VPN，比如：Astrill，鱼摆摆等等。虽然价格并不是很高，但是还是有一定的费用，而且有的还有多用户限制。总之不管收费的，免费的，或多或少我们在使用的过程中有些不爽，今天笔者为大家带来在自己的VPS上搭建一套VPN，想怎么用就怎么用，话不多说，直奔主题。 本文以VPS（Centos7）为例子假设你已经有一台VPS，公网IP为：46.18.171.153 如果没有笔者可以推荐购买Linode，vultr，阿里云（国内版，国际版【阿里云国际版有点小麻烦哦，改天笔者可以写一篇，分享给大家】） 1、在VPS上安装 shadowsocks-libev（ Server 端 ）①、获取 shadowsocks-libev 源代码123git clone https://github.com/shadowsocks/shadowsocks-libev.gitcd shadowsocks-libevgit submodule update --init --recursive ②、对源码进行构建12yum install epel-release -yyum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto udns-devel libev-devel libsodium-devel mbedtls-devel -y ③、下载yum源，并配置放入在 /etc/yum.repos.d/ 目录下 下载地址： shadowsocks repo ④、安装 shadowsocks-libev12su -c 'yum update'su -c 'yum install shadowsocks-libev' ④、测试 shadowsocks-libev 是否正确安装在终端输入：ss 命令，按Tab键看到以下，说明安装成功 123[root@izt4nax70m2dsl3yoh6uxlz ~]# ssss ssh ssh-agent sshd ssh-keygen ss-local ss-manager ss-redir ss-tunnelsserver ssh-add ssh-copy-id sshd-keygen ssh-keyscan ssltap ss-nat ss-server ⑤、配置 shadowsocks-libev，编辑 /etc/shadowsocks-libev/config.json 文件12345678&#123; \"server\":\"0.0.0.0\", # 监听所有的端口 \"server_port\":2020, # 指定server端口，自定义 \"local_port\":1080, # 指定本地端口，默认 \"password\":\"xxx\", # 配置密码 \"timeout\":60, \"method\":\"rc4-md5\" # 加密方式 &#125; ⑥、启动 shadowsocks-libev启动: 1nuhup ss-server &amp; # 后台启动 查看是否成功启动:123[root@izt4nax70m2dsl3yoh6uxlz ~]# ps -ef | grep ss-serverroot 14046 1 0 Aug10 ? 00:00:12 ss-serverroot 32356 32306 0 17:46 pts/0 00:00:00 grep --color=auto ss-server 备注: 其它VPS系统 shadowsocks-libev 安装以及详细配置请参考地址： shadowsocks-libev 其它系统安装以及详细配置 2、shadowsocks 客户端安装与使用（ Client 端 ）①、下载 ShadowsocksX-NG ，并安装，解压直接打开 下载地址： ShadowsocksX-NG.1.5.1.zip ②、客户端，服务器配置点击客户端图标——&gt;服务器——&gt;服务器设置 选择 + 号添加一台服务器，配置参数如下： 备注： 1、地址: 填写你VPS公网的IP 2、端口: 是你在 /etc/shadowsocks-libev/config.json 中配置的 server_port 中的端口 3、密码: 是你在 /etc/shadowsocks-libev/config.json 中配置的 password 中的密码 4、加密方式: 是你在 /etc/shadowsocks-libev/config.json 中配置的 method 中的加密方式 ③、客户端设置开启全局模式 备注： &nbsp;PAC自动模式、全局模式、手动模式三种模式主要区别，供大家参考选择 1、PAC自动模式: 可保证所有浏览器都能够使用代理，和访问你们公司内网 2、全局模式: 可保证所有浏览器能够使用代理，但不能访问公司内网 3、手动模式: 仅仅适用于指定浏览器（配套的插件：如 Chrome 浏览器的：SwitchyOmega 插件） 能够使用代理和访问公司内网，下文将会介绍。 ④、测试VPN搭建是否成功1、 Google 一下 备注：如果Google不了，可能原因如下 1、首先确保客户端和服务端的配置参数一致 2、购买时候的VPS安全组规则，没有开启相应的端口 3、VPS上防火墙以及相关端口没有开启问题 3、shadowsocks 客户端管理工具Google插件SwitchyOmega安装与使用（ 可选择 ①、安装大家在goole商店里自行Google检索词 SwitchyOmega 添加到扩展程序里 ①、情景模式： proxy 选项配置点击 SwitchyOmega 选项 按钮 打开 SwitchyOmega 的配置界面，找到情景模式模块下的 proxy 选项如图： 说明： 1、代理协议: SOCKET5 2、代理服务器: 写本机（127.0.0.1） 3、代理端口: 和服务端 /etc/shadowsocks-libev/config.json 文件中的 local_port 值保持一致 ②、情景模式： auto switch 说明： 在切换规则栏目下，你可以添加正则匹配哪些域名走直连，和代理;如果觉得这样麻烦，我们可以在规则列表设置里面， 通过添加规则网址(https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt)， 为我们生成一些常用的规律列表，（请注意规则列表规则要选择Proxy模式，否则不起作用）","categories":[{"name":"工具","slug":"工具","permalink":"http://www.gulj.cn/categories/工具/"}],"tags":[{"name":"vpn","slug":"vpn","permalink":"http://www.gulj.cn/tags/vpn/"}]},{"title":"Mac用户使用 Aria2GUI 绕过百度网盘满速下载","slug":"Aria2GUI-绕过百度网盘满速下载","date":"2017-08-15T18:15:07.000Z","updated":"2018-05-02T08:45:56.359Z","comments":true,"path":"2017/08/16/Aria2GUI-绕过百度网盘满速下载/","link":"","permalink":"http://www.gulj.cn/2017/08/16/Aria2GUI-绕过百度网盘满速下载/","excerpt":"分享一下Mac用户使用最新的 Aria2GUI 绕过百度网盘下载的方法一、操作流程 1.下载Aria2GUI主程序，解压缩拖拽“Aria2GUI.app”到应用程序完成安装","text":"分享一下Mac用户使用最新的 Aria2GUI 绕过百度网盘下载的方法一、操作流程 1.下载Aria2GUI主程序，解压缩拖拽“Aria2GUI.app”到应用程序完成安装 2.下载并解压缩Chrome文件夹放置任意位置（以后勿删）； 3.打开Chrome浏览器，点击偏好设置—扩展程序—勾上“开发者模式”—点击“加载已解压的扩展程序”选择第二步下载的Chrome文件夹； 4.打开需要下载的百度云盘链接，Chrome浏览器提示“初始化完成”并出现“导出选项”—“ARIA2 RPC”，同时打开应用程序中的“Aria2GUI.app”即可自动实现绕过百度盘慢速下载，默认下载路径在下载目录中； 5.完成 二、下载地址 1、Aria2GUI 1.2.8 for Mac下载 2、Chrome最新插件下载 备注：该工具只适合Chrome浏览器","categories":[{"name":"工具","slug":"工具","permalink":"http://www.gulj.cn/categories/工具/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.gulj.cn/tags/mac/"}]},{"title":"Hexo 博客配置","slug":"hexo-博客配置","date":"2017-08-15T07:34:40.000Z","updated":"2018-05-02T08:47:56.899Z","comments":true,"path":"2017/08/15/hexo-博客配置/","link":"","permalink":"http://www.gulj.cn/2017/08/15/hexo-博客配置/","excerpt":"添加RSS和Sitemapnpm安装插件1$ npm install hexo-generator-feed --save","text":"添加RSS和Sitemapnpm安装插件1$ npm install hexo-generator-feed --save 配置根目录_config.yml12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 添加Git部署插件，部署到GitHub的仓库1$ npm install hexo-deployer-git --save 添加不蒜子统计（统计文章阅读数，站点访客数，访问量） http://ibruce.info/2015/04/04/busuanzi/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.gulj.cn/tags/hexo/"}]}]}